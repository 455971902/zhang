
//*****************************Copyright(c)*************************************
//** 公      司：         深圳国技仪器有限公司(AMAE)
//** 项      目：         多通道气体采样器
//** 硬件版本号：
//**==================================================================
//**------------------------------------ 文件信息-------------------------------
//** 文  件 名:      display.c
//** 文件 描述:      实现整个系统菜单的按键处理函数，菜单的定义函数，即系统
//**                 的菜单在此实现
//** 版     本:      v0.2
//** 创  建 人:	     潘端炎
//** 创建 日期:	     2011.6
//**============================================================================


#include "lcd.h"
#include "key.h"
#include "display.h"
#include "stdlib.h"
#include "adc12.h"
#include "pump.h"
#include "charger.h"
#include "test.h"

static struct WINDOWS *win;     //窗口指针
static struct GUI     *gui;


SYSTEM systems;
struct PASSWORD password;




struct GUI* newGui(void)    //新建一个界面
{
    struct GUI* re = 0;
    
    re = (struct GUI*)malloc(sizeof(struct GUI));
    
    if(re == 0)
    {
        return 0;
    }
    
    
    re->guiExec = guiExec;       //设置线程函数
    re->batLevel = 0;
    re->win = 0;
    
    gui = re;
    
    
    clr_lcd();
    charge();                        //执行充电操作
    charge();                        //执行充电操作
    check();          //执行自检操作
    gui->win = newWindow();       //新建一个窗口
    gui->win->curfous->show();    //显示新窗口
    
    setMaxFlow(MAX_FLOW);    //设置仪器的最大采样流量
    setMinFlow(MIN_FLOW);    //设置仪器的最小采样流量
    setMidflow(MID_FLOW);    //设置间隔流量
    
    
    
    return re;
}



void guiExec(void)                //界面执行中的循环程序
{
    charge();                        //执行充电操作
    gui->batLevel = getBatLev();
    
    if(gui->win)
    {
        gui->win->batLevel = gui->batLevel;
        gui->win->keyEventFun(getKey());   //执行窗口事件查询函数
    }
}


void drawBatBigIcn(int x,int y,int mod)
{
    static int batCount = 0;
    static int oldChargeState = -1;
    int newChargeState = 0;
    
    
    newChargeState = isCharge();
    if(x >= 0 && y >=0 && mod)
    {
        batCount = 0;
        fill_rect(x,y,60,4);
        fill_rect(x,y+4,4,24);
        fill_rect(x,y+28,60,4);
        fill_rect(x+56,y+4,4,24);
        fill_rect(x+64,y+4,4,24);
        fill_rect(x+60,y+4,4,4);
        fill_rect(x+60,y+24,4,4);
        
        oldChargeState = newChargeState;
        fill_rect(x+32,y+8,8,16);
        fill_rect(x+44,y+8,8,16);
        fill_rect(x+20,y+8,8,16);
        fill_rect(x+8,y+8,8,16);
    }
    
    if(newChargeState)
    {
        if(gui->batLevel == 0)
        {
            if(batCount == 100)
            {
                clr_rect(x+8,y+8,44,16);
                batCount = 0;
            }else if(batCount == 80)
            {
                fill_rect(x+44,y+8,8,16);
                fill_rect(x+32,y+8,8,16);
                fill_rect(x+20,y+8,8,16);
                fill_rect(x+8,y+8,8,16);
            }else if(batCount == 60)
            {
                fill_rect(x+32,y+8,8,16);
                fill_rect(x+20,y+8,8,16);
                fill_rect(x+8,y+8,8,16);
            }else if(batCount == 40)
            {
                fill_rect(x+20,y+8,8,16);
                fill_rect(x+8,y+8,8,16);
            }else if(batCount == 20)
            {
                fill_rect(x+8,y+8,8,16);
            }
        }else if(gui->batLevel == 1)
        {
            if(batCount == 80)
            {
                clr_rect(x+20,y+8,32,16);
                batCount = 0;
            }else if(batCount == 60)
            {
                fill_rect(x+44,y+8,8,16);
                fill_rect(x+32,y+8,8,16);
                fill_rect(x+20,y+8,8,16);
                fill_rect(x+8,y+8,8,16);
            }else if(batCount == 40)
            {
                fill_rect(x+32,y+8,8,16);
                fill_rect(x+20,y+8,8,16);
                fill_rect(x+8,y+8,8,16);
            }else if(batCount == 20)
            {
                fill_rect(x+20,y+8,8,16);
                fill_rect(x+8,y+8,8,16);
            }
        }else if(gui->batLevel == 2)
        {
            if(batCount == 60)
            {
                clr_rect(x+32,y+8,20,16);
                batCount = 0;
            }else if(batCount == 40)
            {
                fill_rect(x+44,y+8,8,16);
                fill_rect(x+32,y+8,8,16);
                fill_rect(x+20,y+8,8,16);
                fill_rect(x+8,y+8,8,16);
            }else if(batCount == 20)
            {
                fill_rect(x+32,y+8,8,16);
                fill_rect(x+20,y+8,8,16);
                fill_rect(x+8,y+8,8,16);
            }
        }else if(gui->batLevel == 3)
        {
            if(batCount == 40)
            {
                clr_rect(x+44,y+8,8,16);
                batCount = 0;
            }else if(batCount == 20)
            {
                fill_rect(x+44,y+8,8,16);
                fill_rect(x+32,y+8,8,16);
                fill_rect(x+20,y+8,8,16);
                fill_rect(x+8,y+8,8,16);
            }
        }else if(gui->batLevel == 4)
        {
            batCount = 0;
            fill_rect(x+44,y+8,8,16);
        }
        batCount ++;
        oldChargeState = newChargeState;
    }else
    {
        if(newChargeState != oldChargeState)
        {
            oldChargeState = newChargeState;
            fill_rect(x+32,y+8,8,16);
            fill_rect(x+44,y+8,8,16);
            fill_rect(x+20,y+8,8,16);
            fill_rect(x+8,y+8,8,16);
        }
    }
}

void freeWindow(void)
{
    if(win)
    {
        freeAllMenu();
        memset(win,0,sizeof(struct WINDOWS));
        free(win);
    }
}

struct WINDOWS* newWindow(void)       //新建窗口函数
{
    struct WINDOWS *re;

    re =(struct WINDOWS*)malloc(sizeof(struct WINDOWS));

    re->keyEventFun = keyEvent;          //连接按键处理函数

    re->mLevel = 0;                      //第0级菜单

    re->oldMLevel = 0;

    win = re;

    re->batLevel = 3;

    // 手动模式采样各参数默认值
    InitAllPara();

    /*
    * 错误菜单
    */
    struct MENU *errorMenu;
    errorMenu = newMenu();
    win->errMenu = errorMenu;
    
    connectShowfun( errorMenu, errorMenuShow );
    connectLeftKey( errorMenu, errorMenuLeft );
    connectRightKey( errorMenu, errorMenuRight );
    connectOkKey( errorMenu, errorMenuOnOk );

    struct MENU *twoErrMenu;      // 第二个出错处理菜单指针
   
    twoErrMenu = newMenu();
   
    win->twoErrMenu = twoErrMenu;
    connectShowfun( twoErrMenu, twoErrMenuShow );
    connectOkKey( twoErrMenu, twoErrMenuOkKey );
    //connectExec( twoErrMenu, twoErrMenuExec );
    
    
    

    struct MENU *topAssistMenu;
    topAssistMenu = newMenu();

    win->menu = topAssistMenu;
    win->curfous = win->menu;

    connectShowfun( topAssistMenu, topAssistMenuShow );


    /**
    ** 系统待机时手动模式的菜单
    **/
    struct MENU *topManuMenu;
    topManuMenu = newMenu();
//    win->menu = topInitMenu;
//    win->curfous = win->menu;
    addSubMenu( topAssistMenu, topManuMenu );

    connectShowfun( topManuMenu, topManuMenuShow );

    connectUpKey( topManuMenu, topManuMenuOnUp );
    connectDownKey( topManuMenu, topManuMenuOnDown );
    
    connectLeftKey( topManuMenu, topManuMenuOnLeft );
    connectRightKey( topManuMenu, topManuMenuOnRight );
    
    connectOkKey( topManuMenu, topManuMenuOnOk );
//    connectEscKey( topManuMenu, topManuMenuOnEsc );

    connectExec( topManuMenu, topManuMenuExec );



    /**
    ** 系统待机时定时模式的菜单
    **/
    struct MENU *topTimeMenu;
    topTimeMenu = newMenu();

    connectMenu( topManuMenu, topTimeMenu );

    connectShowfun( topTimeMenu, topTimeMenuShow );

    connectUpKey( topTimeMenu, topTimeMenuOnUp );
    connectDownKey( topTimeMenu, topTimeMenuOnDown );
    
    connectOkKey( topTimeMenu, topTimeMenuOnOk );
//    connectEscKey( topTimeMenu, topTimeMenuOnEsc );

    connectExec( topTimeMenu, topTimeMenuExec );





    /**
    ** 系统待机时循环模式的菜单
    **/
    struct MENU *topCylMenu;

    topCylMenu = newMenu();

    connectMenu( topTimeMenu, topCylMenu );

    connectShowfun( topCylMenu, topCylMenuShow );

    connectUpKey( topCylMenu, topCylMenuOnUp );
    connectDownKey( topCylMenu, topCylMenuOnDown );

    connectOkKey( topCylMenu, topCylMenuOnOk );
//    connectEscKey( topCylMenu, topCylMenuOnEsc );

    connectExec( topCylMenu, topCylMenuExec );







    /*
     * 手动模式启动菜单
     */
    struct MENU *manuStartMenu;
    manuStartMenu = newMenu();
    addSubMenu( topManuMenu, manuStartMenu );

    connectShowfun( manuStartMenu, manuStartMenuShow );

    connectUpKey( manuStartMenu, manuStartMenuOnUp );
    connectDownKey( manuStartMenu, manuStartMenuOnDown );

    connectLeftKey( manuStartMenu, manuStartMenuOnLeft );
    connectRightKey( manuStartMenu, manuStartMenuOnRight );

    connectOkKey( manuStartMenu, manuStartMenuOnOk );
    connectEscKey( manuStartMenu, manuStartMenuOnEsc );

    connectExec( manuStartMenu, manuStartMenuExec );


    /*
     * 手动模式停止警告菜单
     */
    struct MENU *MwarnStopMenu;
    MwarnStopMenu = newMenu();
    addSubMenu( manuStartMenu, MwarnStopMenu );
    connectShowfun( MwarnStopMenu, MwarnStopMenuShow );

    connectLeftKey( MwarnStopMenu, MwarnStopMenuOnLeft );
    connectRightKey( MwarnStopMenu, MwarnStopMenuOnRight );

    connectOkKey( MwarnStopMenu, MwarnStopMenuOnOk );
    connectEscKey( MwarnStopMenu, MwarnStopMenuOnEsc );






    /*
     * 定时模式启动菜单
     */
    struct MENU *timeStartMenu;
    timeStartMenu = newMenu();
    addSubMenu( topTimeMenu, timeStartMenu );

    connectShowfun( timeStartMenu, timeStartMenuShow );

    connectUpKey( timeStartMenu, timeStartMenuOnUp );
    connectDownKey( timeStartMenu, timeStartMenuOnDown );

    connectLeftKey( timeStartMenu, timeStartMenuOnLeft );
    connectRightKey( timeStartMenu, timeStartMenuOnRight );

    connectOkKey( timeStartMenu, timeStartMenuOnOk );
    connectEscKey( timeStartMenu, timeStartMenuOnEsc );

    connectExec( timeStartMenu, timeStartMenuExec );


    /*
     * 定时模式停止警告菜单
     */
    struct MENU *TwarnStopMenu;
    TwarnStopMenu = newMenu();
    addSubMenu( timeStartMenu, TwarnStopMenu );
    connectShowfun( TwarnStopMenu, TwarnStopMenuShow );

    connectLeftKey( TwarnStopMenu, TwarnStopMenuOnLeft );
    connectRightKey( TwarnStopMenu, TwarnStopMenuOnRight );

    connectOkKey( TwarnStopMenu, TwarnStopMenuOnOk );
    connectEscKey( TwarnStopMenu, TwarnStopMenuOnEsc );





    /*
     * 循环模式启动菜单
     */
    struct MENU *cylStartMenu;
    cylStartMenu = newMenu();
    addSubMenu( topCylMenu, cylStartMenu );

    connectShowfun( cylStartMenu, cylStartMenuShow );

    connectUpKey( cylStartMenu, cylStartMenuOnUp );
    connectDownKey( cylStartMenu, cylStartMenuOnDown );

    connectLeftKey( cylStartMenu, cylStartMenuOnLeft );
    connectRightKey( cylStartMenu, cylStartMenuOnRight );

    connectOkKey( cylStartMenu, cylStartMenuOnOk );
    connectEscKey( cylStartMenu, cylStartMenuOnEsc );

    connectExec( cylStartMenu, cylStartMenuExec );


    /*
     * 循环模式停止警告菜单
     */
    struct MENU *CwarnStopMenu;
    CwarnStopMenu = newMenu();
    addSubMenu( cylStartMenu, CwarnStopMenu );
    connectShowfun( CwarnStopMenu, CwarnStopMenuShow );

    connectLeftKey( CwarnStopMenu, CwarnStopMenuOnLeft );
    connectRightKey( CwarnStopMenu, CwarnStopMenuOnRight );

    connectOkKey( CwarnStopMenu, CwarnStopMenuOnOk );
    connectEscKey( CwarnStopMenu, CwarnStopMenuOnEsc );

    /*
     * 手动模式采样时长设置菜单
     */
    struct MENU *smpTimeMenued;
    smpTimeMenued = newMenu();

    // 已启动采样
    connectMenu( MwarnStopMenu, smpTimeMenued );

    connectShowfun( smpTimeMenued, smpTimeMenuShow );

    connectUpKey( smpTimeMenued, smpTimeMenuOnUp );
    connectDownKey( smpTimeMenued, smpTimeMenuOnDown );

    connectLeftKey( smpTimeMenued, smpTimeMenuOnLeft );
    connectRightKey( smpTimeMenued, smpTimeMenuOnRight );

    connectOkKey( smpTimeMenued, smpTimeMenuOnOk );
    connectEscKey( smpTimeMenued, smpTimeMenuOnEsc );

    connectExec( smpTimeMenued, smpTimeMenuExec );
////////////////////////////////////////////////////////////

    struct MENU *smpTimeMenu;
    smpTimeMenu = newMenu();

    // 未启动采样
    connectMenu( manuStartMenu, smpTimeMenu );

    connectShowfun( smpTimeMenu, smpTimeMenuShow );

    connectUpKey( smpTimeMenu, smpTimeMenuOnUp );
    connectDownKey( smpTimeMenu, smpTimeMenuOnDown );

    connectLeftKey( smpTimeMenu, smpTimeMenuOnLeft );
    connectRightKey( smpTimeMenu, smpTimeMenuOnRight );

    connectOkKey( smpTimeMenu, smpTimeMenuOnOk );
    connectEscKey( smpTimeMenu, smpTimeMenuOnEsc );

    connectExec( smpTimeMenu, smpTimeMenuExec );

    
    
    
    /*
     * 手动模式采样时长设置警告菜单
    */
    // 已启动
    struct MENU *smpTimeWarnMenued;
    smpTimeWarnMenued = newMenu();
    addSubMenu( smpTimeMenued, smpTimeWarnMenued );
    connectShowfun( smpTimeWarnMenued, smpTimeWarnMenuShow );
    connectOkKey( smpTimeWarnMenued, smpTimeWarnMenuOnOk );
    ////////////////////////////////////////////////////////
    // 未启动
    struct MENU *smpTimeWarnMenu;
    smpTimeWarnMenu = newMenu();
    addSubMenu( smpTimeMenu, smpTimeWarnMenu );
    connectShowfun( smpTimeWarnMenu, smpTimeWarnMenuShow );
    connectOkKey( smpTimeWarnMenu, smpTimeWarnMenuOnOk );
    
    



    /*
     * 定时模式查看菜单
     */
    struct MENU *timeViewMenued;
    timeViewMenued = newMenu();
    // 已启动采样
    connectMenu( TwarnStopMenu, timeViewMenued );

    connectShowfun( timeViewMenued, timeViewMenuShow );

    connectUpKey( timeViewMenued, timeViewMenuOnUp );
    connectDownKey( timeViewMenued, timeViewMenuOnDown );

    connectOkKey( timeViewMenued, timeViewMenuOnOk );
    connectEscKey( timeViewMenued, timeViewMenuOnEsc );

    connectExec( timeViewMenued, timeViewMenuExec );

////////////////////////////////////////////////////
    struct MENU *timeViewMenu;
    timeViewMenu = newMenu();
    // 未启动采样
    connectMenu( timeStartMenu, timeViewMenu );

    connectShowfun( timeViewMenu, timeViewMenuShow );

    connectUpKey( timeViewMenu, timeViewMenuOnUp );
    connectDownKey( timeViewMenu, timeViewMenuOnDown );

    connectOkKey( timeViewMenu, timeViewMenuOnOk );
    connectEscKey( timeViewMenu, timeViewMenuOnEsc );

    connectExec( timeViewMenu, timeViewMenuExec );



    /*
     * 循环模式查看菜单
     */
    // 未启动采样
    struct MENU *cylViewMenu;
    cylViewMenu = newMenu();
    connectMenu( cylStartMenu, cylViewMenu );

    connectShowfun( cylViewMenu, cylViewMenuShow );

    connectUpKey( cylViewMenu, cylViewMenuOnUp );
    connectDownKey( cylViewMenu, cylViewMenuOnDown );

    connectOkKey( cylViewMenu, cylViewMenuOnOk );
    connectEscKey( cylViewMenu, cylViewMenuOnEsc );

    connectExec( cylViewMenu, cylViewMenuExec );
/////////////////////////////////////////////////////////////
    // 已启动采样
    struct MENU *cylViewMenued;
    cylViewMenued = newMenu();
    connectMenu( CwarnStopMenu, cylViewMenued );

    connectShowfun( cylViewMenued, cylViewMenuShow );

    connectUpKey( cylViewMenued, cylViewMenuOnUp );
    connectDownKey( cylViewMenued, cylViewMenuOnDown );

    connectOkKey( cylViewMenued, cylViewMenuOnOk );
    connectEscKey( cylViewMenued, cylViewMenuOnEsc );

    connectExec( cylViewMenued, cylViewMenuExec );




    /*
     * 定时模式各组参数查看菜单
     */
    struct MENU *timeViewSetMenu;
    timeViewSetMenu = newMenu();
    // 未启动采样
    addSubMenu( timeViewMenu, timeViewSetMenu );

    connectShowfun( timeViewSetMenu, timeViewSetMenuShow );

    connectLeftKey( timeViewSetMenu, timeViewSetMenuOnLeft );
    connectRightKey( timeViewSetMenu, timeViewSetMenuOnRight );

    connectOkKey( timeViewSetMenu, timeViewSetMenuOnOk );
    connectEscKey( timeViewSetMenu, timeViewSetMenuOnEsc );

    connectExec( timeViewSetMenu, timeViewSetMenuExec );
////////////////////////////////////////////////////////////////

    // 已启动采样
    addSubMenu( timeViewMenued, timeViewSetMenu );

    connectShowfun( timeViewSetMenu, timeViewSetMenuShow );

    connectLeftKey( timeViewSetMenu, timeViewSetMenuOnLeft );
    connectRightKey( timeViewSetMenu, timeViewSetMenuOnRight );

    connectOkKey( timeViewSetMenu, timeViewSetMenuOnOk );
    connectEscKey( timeViewSetMenu, timeViewSetMenuOnEsc );

    connectExec( timeViewSetMenu, timeViewSetMenuExec );



    /*
     * 定时模式各组状态查看菜单
     */
    struct MENU *timeViewStatusMenu;
    timeViewStatusMenu = newMenu();
    connectMenu( timeViewSetMenu, timeViewStatusMenu );

    connectShowfun( timeViewStatusMenu, timeViewStatusMenuShow );

    connectUpKey( timeViewStatusMenu, timeViewStatusMenuOnUp );
    connectDownKey( timeViewStatusMenu, timeViewStatusMenuOnDown );

    connectOkKey( timeViewStatusMenu, timeViewStatusMenuOnOk );
    connectEscKey( timeViewStatusMenu, timeViewStatusMenuOnEsc );

    connectExec( timeViewStatusMenu, timeViewStatusMenuExec );





    /*
     * 循环模式个参数查看菜单
     */
    struct MENU *cylViewSetMenu;
    cylViewSetMenu = newMenu();
    // 未启动采样
    addSubMenu( cylViewMenu, cylViewSetMenu );

    connectShowfun( cylViewSetMenu, cylViewSetMenuShow );

    connectLeftKey( cylViewSetMenu, cylViewSetMenuOnLeft );
    connectRightKey( cylViewSetMenu, cylViewSetMenuOnRight );

    connectOkKey( cylViewSetMenu, cylViewSetMenuOnOk );
    connectEscKey( cylViewSetMenu, cylViewSetMenuOnEsc );

    connectExec( cylViewSetMenu, cylViewSetMenuExec );
/////////////////////////////////////////////////////////////

    // 已启动采样
    addSubMenu( cylViewMenued, cylViewSetMenu );

    connectShowfun( cylViewSetMenu, cylViewSetMenuShow );

    connectLeftKey( cylViewSetMenu, cylViewSetMenuOnLeft );
    connectRightKey( cylViewSetMenu, cylViewSetMenuOnRight );

    connectOkKey( cylViewSetMenu, cylViewSetMenuOnOk );
    connectEscKey( cylViewSetMenu, cylViewSetMenuOnEsc );

    connectExec( cylViewSetMenu, cylViewSetMenuExec );




    /*
     * 循环模式查看状态菜单
     */
    struct MENU *cylViewStatusMenu;
    cylViewStatusMenu = newMenu();
    connectMenu( cylViewSetMenu, cylViewStatusMenu );

    connectShowfun( cylViewStatusMenu, cylViewStatusMenuShow );

    connectUpKey( cylViewStatusMenu, cylViewStatusMenuOnUp );
    connectDownKey( cylViewStatusMenu, cylViewStatusMenuOnDown );

    connectOkKey( cylViewStatusMenu, cylViewStatusMenuOnOk );
    connectEscKey( cylViewStatusMenu, cylViewStatusMenuOnEsc );

    connectExec( cylViewStatusMenu, cylViewStatusMenuExec );






    /*
     * 手动模式总设置菜单
     */
    struct MENU *allSetMenu;
    allSetMenu = newMenu();
    // 未启动采样
    connectMenu( smpTimeMenu, allSetMenu );

    connectShowfun( allSetMenu, allSetMenuShow );

    connectLeftKey( allSetMenu, allSetMenuOnLeft );
    connectRightKey( allSetMenu, allSetMenuOnRight );

    connectOkKey( allSetMenu, allSetMenuOnOk );
    connectEscKey( allSetMenu, allSetMenuOnEsc );

    connectExec( allSetMenu, allSetMenuExec );
////////////////////////////////////////////////////////
    struct MENU *MallSetMenued;
    MallSetMenued = newMenu();
    // 已启动采样
    connectMenu( smpTimeMenued, MallSetMenued );

    connectShowfun( MallSetMenued, allSetMenuShow );

    connectLeftKey( MallSetMenued, allSetMenuOnLeft );
    connectRightKey( MallSetMenued, allSetMenuOnRight );

    connectOkKey( MallSetMenued, allSetMenuOnOk );
    connectEscKey( MallSetMenued, allSetMenuOnEsc );

    connectExec( MallSetMenued, allSetMenuExec );



    /*
     * 定时模式总设置菜单
     */
    // 未启动采样
    connectMenu( timeViewMenu, allSetMenu );

    connectShowfun( allSetMenu, allSetMenuShow );

    connectLeftKey( allSetMenu, allSetMenuOnLeft );
    connectRightKey( allSetMenu, allSetMenuOnRight );

    connectOkKey( allSetMenu, allSetMenuOnOk );
    connectEscKey( allSetMenu, allSetMenuOnEsc );

    connectExec( allSetMenu, allSetMenuExec );
//////////////////////////////////////////////

    struct MENU *TallSetMenued;
    TallSetMenued = newMenu();
    // 已启动采样
    connectMenu( timeViewMenued, TallSetMenued );

    connectShowfun( TallSetMenued, allSetMenuShow );

    connectLeftKey( TallSetMenued, allSetMenuOnLeft );
    connectRightKey( TallSetMenued, allSetMenuOnRight );

    connectOkKey( TallSetMenued, allSetMenuOnOk );
    connectEscKey( TallSetMenued, allSetMenuOnEsc );

    connectExec( TallSetMenued, allSetMenuExec );




    /*
     * 循环模式总设置菜单
     */
    // 未启动采样
    connectMenu( cylViewMenu, allSetMenu );

    connectShowfun( allSetMenu, allSetMenuShow );

    connectLeftKey( allSetMenu, allSetMenuOnLeft );
    connectRightKey( allSetMenu, allSetMenuOnRight );

    connectOkKey( allSetMenu, allSetMenuOnOk );
    connectEscKey( allSetMenu, allSetMenuOnEsc );

    connectExec( allSetMenu, allSetMenuExec );
///////////////////////////////////////////////////////////////
    struct MENU *CallSetMenued;
    CallSetMenued = newMenu();
    // 已启动采样
    connectMenu( cylViewMenued, CallSetMenued );

    connectShowfun( CallSetMenued, allSetMenuShow );

    connectLeftKey( CallSetMenued, allSetMenuOnLeft );
    connectRightKey( CallSetMenued, allSetMenuOnRight );

    connectOkKey( CallSetMenued, allSetMenuOnOk );
    connectEscKey( CallSetMenued, allSetMenuOnEsc );

    connectExec( CallSetMenued, allSetMenuExec );





    /*
     * 模式设置菜单
     */
    struct MENU *modSetMenu;
    modSetMenu = newMenu();
    // 未启动采样
    addSubMenu( allSetMenu, modSetMenu );

    connectShowfun( modSetMenu, modSetMenuShow );

    connectUpKey( modSetMenu, modSetMenuOnUp );
    connectDownKey( modSetMenu, modSetMenuOnDown );

    connectLeftKey( modSetMenu, modSetMenuOnLeft );
    connectRightKey( modSetMenu, modSetMenuOnRight );

    connectOkKey( modSetMenu, modSetMenuOnOk );
    connectEscKey( modSetMenu, modSetMenuOnEsc );

    connectExec( modSetMenu, modSetMenuExec );
///////////////////////////////////////////////////
    // 已启动采样
//////////////////////////////////////////////////
    // 手动模式
    addSubMenu( MallSetMenued, modSetMenu );

    connectShowfun( modSetMenu, modSetMenuShow );

    connectUpKey( modSetMenu, modSetMenuOnUp );
    connectDownKey( modSetMenu, modSetMenuOnDown );

    connectLeftKey( modSetMenu, modSetMenuOnLeft );
    connectRightKey( modSetMenu, modSetMenuOnRight );

    connectOkKey( modSetMenu, modSetMenuOnOk );
    connectEscKey( modSetMenu, modSetMenuOnEsc );

    connectExec( modSetMenu, modSetMenuExec );
//////////////////////////////////////////////////////
    // 定时模式
    addSubMenu( TallSetMenued, modSetMenu );

    connectShowfun( modSetMenu, modSetMenuShow );

    connectUpKey( modSetMenu, modSetMenuOnUp );
    connectDownKey( modSetMenu, modSetMenuOnDown );

    connectLeftKey( modSetMenu, modSetMenuOnLeft );
    connectRightKey( modSetMenu, modSetMenuOnRight );

    connectOkKey( modSetMenu, modSetMenuOnOk );
    connectEscKey( modSetMenu, modSetMenuOnEsc );

    connectExec( modSetMenu, modSetMenuExec );
///////////////////////////////////////////////////////
    // 循环模式
    addSubMenu( CallSetMenued, modSetMenu );

    connectShowfun( modSetMenu, modSetMenuShow );

    connectUpKey( modSetMenu, modSetMenuOnUp );
    connectDownKey( modSetMenu, modSetMenuOnDown );

    connectLeftKey( modSetMenu, modSetMenuOnLeft );
    connectRightKey( modSetMenu, modSetMenuOnRight );

    connectOkKey( modSetMenu, modSetMenuOnOk );
    connectEscKey( modSetMenu, modSetMenuOnEsc );

    connectExec( modSetMenu, modSetMenuExec );




    /*
     * 参数设置菜单
     */
    struct MENU *parameterSetMenu;
    parameterSetMenu = newMenu();
    connectMenu( modSetMenu, parameterSetMenu );
    connectShowfun( parameterSetMenu, parameterSetMenuShow );


    /*
     * 手动模式流量参数设置菜单
     */
    struct MENU *manuFlowSetMenu;
    manuFlowSetMenu = newMenu();
    addSubMenu( parameterSetMenu, manuFlowSetMenu );

    connectShowfun( manuFlowSetMenu, manuFlowSetMenuShow );

    connectUpKey( manuFlowSetMenu, manuFlowSetMenuOnUp );
    connectDownKey( manuFlowSetMenu, manuFlowSetMenuOnDown );

    connectLeftKey( manuFlowSetMenu, manuFlowSetMenuOnLeft );
    connectRightKey( manuFlowSetMenu, manuFlowSetMenuOnRight );

    connectOkKey( manuFlowSetMenu, manuFlowSetMenuOnOk );
    connectEscKey( manuFlowSetMenu, manuFlowSetMenuOnEsc );

    connectExec( manuFlowSetMenu, manuFlowSetMenuExec );



    /*
     * 流量错误菜单
     */
    struct MENU *MerrFlowMenu;
    MerrFlowMenu = newMenu();

    addSubMenu( manuFlowSetMenu, MerrFlowMenu );
    connectShowfun( MerrFlowMenu, errFlowMenuShow );

    connectOkKey( MerrFlowMenu, errFlowMenuOnOk );






    /*
     * 定时模式参数设置菜单
     */
    struct MENU *groupSetMenu;
    groupSetMenu = newMenu();
    connectMenu( manuFlowSetMenu, groupSetMenu );

    connectShowfun( groupSetMenu, groupSetMenuShow );

    connectUpKey( groupSetMenu, groupSetMenuOnUp );
    connectDownKey( groupSetMenu, groupSetMenuOnDown );

    connectLeftKey( groupSetMenu, groupSetMenuOnLeft );
    connectRightKey( groupSetMenu, groupSetMenuOnRight );

    connectOkKey( groupSetMenu, groupSetMenuOnOk );
    connectEscKey( groupSetMenu, groupSetMenuOnEsc );

    connectExec( groupSetMenu, groupSetMenuExec );





    /*
     * 定时模式定时组参数设置菜单
     */
    struct MENU *groupParaSetMenu;
    groupParaSetMenu = newMenu();
    addSubMenu( groupSetMenu, groupParaSetMenu );

    connectShowfun( groupParaSetMenu, groupParaSetMenuShow );

    connectUpKey( groupParaSetMenu, groupParaSetMenuOnUp );
    connectDownKey( groupParaSetMenu, groupParaSetMenuOnDown );

//    connectLeftKey( groupParaSetMenu, groupParaSetMenuOnLeft );
//    connectRightKey( groupParaSetMenu, groupParaSetMenuOnRight );

    connectOkKey( groupParaSetMenu, groupParaSetMenuOnOk );
    connectEscKey( groupParaSetMenu, groupParaSetMenuOnEsc );

    connectExec( groupParaSetMenu, groupParaSetMenuExec );






    /*
     * 定时模式定时组工作时间设置菜单
     */
    struct MENU *groupWorkTimeSetMenu;
    groupWorkTimeSetMenu = newMenu();
    addSubMenu( groupParaSetMenu, groupWorkTimeSetMenu );

    connectShowfun( groupWorkTimeSetMenu, groupWorkTimeSetMenuShow );

    connectUpKey( groupWorkTimeSetMenu, groupWorkTimeSetMenuOnUp );
    connectDownKey( groupWorkTimeSetMenu, groupWorkTimeSetMenuOnDown );

    connectLeftKey( groupWorkTimeSetMenu, groupWorkTimeSetMenuOnLeft );
    connectRightKey( groupWorkTimeSetMenu, groupWorkTimeSetMenuOnRight );

    connectOkKey( groupWorkTimeSetMenu, groupWorkTimeSetMenuOnOk );
    connectEscKey( groupWorkTimeSetMenu, groupWorkTimeSetMenuOnEsc );

    connectExec( groupWorkTimeSetMenu, groupWorkTimeSetMenuExec );

    /*
     * 组冲突
     */
    struct MENU *groupWarnMenu;
    groupWarnMenu = newMenu();
    addSubMenu( groupWorkTimeSetMenu, groupWarnMenu );
    connectShowfun( groupWarnMenu, groupWarnMenuShow );
    connectOkKey( groupWarnMenu, groupWarnMenuOnOk );







    /*
     * 定时模式定时组流量设置菜单
     */
    struct MENU *groupFlowSetMenu;
    groupFlowSetMenu = newMenu();
    connectMenu( groupWorkTimeSetMenu, groupFlowSetMenu );

    connectShowfun( groupFlowSetMenu, groupFlowSetMenuShow );

    connectUpKey( groupFlowSetMenu, groupFlowSetMenuOnUp );
    connectDownKey( groupFlowSetMenu, groupFlowSetMenuOnDown );

    connectLeftKey( groupFlowSetMenu, groupFlowSetMenuOnLeft );
    connectRightKey( groupFlowSetMenu, groupFlowSetMenuOnRight );

    connectOkKey( groupFlowSetMenu, groupFlowSetMenuOnOk );
    connectEscKey( groupFlowSetMenu, groupFlowSetMenuOnEsc );

    connectExec( groupFlowSetMenu, groupFlowSetMenuExec );



    /*
     * 组冲突
     */
//    struct MENU *groupWarnMenu;
//    groupWarnMenu = newMenu();
    connectMenu( groupFlowSetMenu, groupWarnMenu );
    connectShowfun( groupWarnMenu, groupWarnMenuShow );
    connectOkKey( groupWarnMenu, groupWarnMenuOnOk );


    /*
     * 定时模式定时组错误流量警告菜单
     */
    struct MENU *TerrFlowMenu;
    TerrFlowMenu = newMenu();
    addSubMenu( groupFlowSetMenu, TerrFlowMenu );
    connectShowfun( TerrFlowMenu, errFlowMenuShow );

    connectOkKey( TerrFlowMenu, errFlowMenuOnOk );








    /*
     * 循环模式参数设置菜单
     */
    struct MENU *cylParaSetMenu;
    cylParaSetMenu = newMenu();
    connectMenu( groupSetMenu, cylParaSetMenu );

    connectShowfun( cylParaSetMenu, cylParaSetMenuShow );

    connectUpKey( cylParaSetMenu, cylParaSetMenuOnUp );
    connectDownKey( cylParaSetMenu, cylParaSetMenuOnDown );

//    connectLeftKey( cylParaSetMenu, cylParaSetMenuOnLeft );
//    connectRightKey( cylParaSetMenu, cylParaSetMenuOnRight );

    connectOkKey( cylParaSetMenu, cylParaSetMenuOnOk );
    connectEscKey( cylParaSetMenu, cylParaSetMenuOnEsc );

    connectExec( cylParaSetMenu, cylParaSetMenuExec );





    /*
     * 循环模式流量设置菜单
     */
    struct MENU *cylFlowSetMenu;
    cylFlowSetMenu = newMenu();
    addSubMenu( cylParaSetMenu, cylFlowSetMenu );

    connectShowfun( cylFlowSetMenu, cylFlowSetMenuShow );

    connectUpKey( cylFlowSetMenu, cylFlowSetMenuOnUp );
    connectDownKey( cylFlowSetMenu, cylFlowSetMenuOnDown );

    connectLeftKey( cylFlowSetMenu, cylFlowSetMenuOnLeft );
    connectRightKey( cylFlowSetMenu, cylFlowSetMenuOnRight );

    connectOkKey( cylFlowSetMenu, cylFlowSetMenuOnOk );
    connectEscKey( cylFlowSetMenu, cylFlowSetMenuOnEsc );

    connectExec( cylFlowSetMenu, cylFlowSetMenuExec );


    /*
     * 循环模式错误流量警告菜单
     */
    struct MENU *CerrFlowMenu;
    CerrFlowMenu = newMenu();
    addSubMenu( cylFlowSetMenu, CerrFlowMenu );
    connectShowfun( CerrFlowMenu, errFlowMenuShow );

    connectOkKey( CerrFlowMenu, errFlowMenuOnOk );






    /*
     * 循环模式间隔时间设置菜单
     */
    struct MENU *cylDelaySetMenu;
    cylDelaySetMenu = newMenu();
    connectMenu( cylFlowSetMenu, cylDelaySetMenu );

    connectShowfun( cylDelaySetMenu, cylDelaySetMenuShow );

    connectUpKey( cylDelaySetMenu, cylDelaySetMenuOnUp );
    connectDownKey( cylDelaySetMenu, cylDelaySetMenuOnDown );

    connectLeftKey( cylDelaySetMenu, cylDelaySetMenuOnLeft );
    connectRightKey( cylDelaySetMenu, cylDelaySetMenuOnRight );

    connectOkKey( cylDelaySetMenu, cylDelaySetMenuOnOk );
    connectEscKey( cylDelaySetMenu, cylDelaySetMenuOnEsc );

    connectExec( cylDelaySetMenu, cylDelaySetMenuExec );







    /*
     * 循环模式采样时长设置菜单
     */
    struct MENU *cylSmpTimeSetMenu;
    cylSmpTimeSetMenu = newMenu();
    connectMenu( cylDelaySetMenu, cylSmpTimeSetMenu );

    connectShowfun( cylSmpTimeSetMenu, cylSmpTimeSetMenuShow );

    connectUpKey( cylSmpTimeSetMenu, cylSmpTimeSetMenuOnUp );
    connectDownKey( cylSmpTimeSetMenu, cylSmpTimeSetMenuOnDown );

    connectLeftKey( cylSmpTimeSetMenu, cylSmpTimeSetMenuOnLeft );
    connectRightKey( cylSmpTimeSetMenu, cylSmpTimeSetMenuOnRight );

    connectOkKey( cylSmpTimeSetMenu, cylSmpTimeSetMenuOnOk );
    connectEscKey( cylSmpTimeSetMenu, cylSmpTimeSetMenuOnEsc );

    connectExec( cylSmpTimeSetMenu, cylSmpTimeSetMenuExec );





    /*
     * 循环模式循环次数设置菜单
     */
    struct MENU *cylCyclesSetMenu;
    cylCyclesSetMenu = newMenu();
    connectMenu( cylSmpTimeSetMenu, cylCyclesSetMenu );

    connectShowfun( cylCyclesSetMenu, cylCyclesSetMenuShow );

    connectUpKey( cylCyclesSetMenu, cylCyclesSetMenuOnUp );
    connectDownKey( cylCyclesSetMenu, cylCyclesSetMenuOnDown );

    connectLeftKey( cylCyclesSetMenu, cylCyclesSetMenuOnLeft );
    connectRightKey( cylCyclesSetMenu, cylCyclesSetMenuOnRight );

    connectOkKey( cylCyclesSetMenu, cylCyclesSetMenuOnOk );
    connectEscKey( cylCyclesSetMenu, cylCyclesSetMenuOnEsc );

    connectExec( cylCyclesSetMenu, cylCyclesSetMenuExec );









    /*
     * 语言设置菜单
     */
    struct MENU *languageSetMenu;
    languageSetMenu = newMenu();
    connectMenu( parameterSetMenu, languageSetMenu );

    connectShowfun( languageSetMenu, languageSetMenuShow );

    connectUpKey( languageSetMenu, languageSetMenuOnUp );
    connectDownKey( languageSetMenu, languageSetMenuOnDown );

    connectLeftKey( languageSetMenu, languageSetMenuOnLeft );
    connectRightKey( languageSetMenu, languageSetMenuOnRight );

    connectOkKey( languageSetMenu, languageSetMenuOnOk );
    connectEscKey( languageSetMenu, languageSetMenuOnEsc );

    connectExec( languageSetMenu, languageSetMenuExec );





    /*
     * 系统时间设置菜单
     */
    struct MENU *sysTimeSetMenu;
    sysTimeSetMenu = newMenu();
    connectMenu( languageSetMenu, sysTimeSetMenu );

    connectShowfun( sysTimeSetMenu, sysTimeSetMenuShow );

    connectUpKey( sysTimeSetMenu, sysTimeSetMenuOnUp );
    connectDownKey( sysTimeSetMenu, sysTimeSetMenuOnDown );

    connectLeftKey( sysTimeSetMenu, sysTimeSetMenuOnLeft );
    connectRightKey( sysTimeSetMenu, sysTimeSetMenuOnRight );

    connectOkKey( sysTimeSetMenu, sysTimeSetMenuOnOk );
    connectEscKey( sysTimeSetMenu, sysTimeSetMenuOnEsc );

    connectExec( sysTimeSetMenu, sysTimeSetMenuExec );





    /*
     * 定时关机设置菜单
     */
    struct MENU *timePowerOffSetMenu;
    timePowerOffSetMenu = newMenu();

    connectMenu( sysTimeSetMenu, timePowerOffSetMenu );

    connectShowfun( timePowerOffSetMenu, timePowerOffSetMenuShow );

    connectUpKey( timePowerOffSetMenu, timePowerOffSetMenuOnUp );
    connectDownKey( timePowerOffSetMenu, timePowerOffSetMenuOnDown );

//    connectLeftKey( timePowerOffSetMenu, timePowerOffSetMenuOnLeft );
//    connectRightKey( timePowerOffSetMenu, timePowerOffSetMenuOnRight );

    connectOkKey( timePowerOffSetMenu, timePowerOffSetMenuOnOk );
    connectEscKey( timePowerOffSetMenu, timePowerOffSetMenuOnEsc );

    connectExec( timePowerOffSetMenu, timePowerOffSetMenuExec );





    /*
     * 定时关机时间设置菜单
     */
    struct MENU *powerTimeSetMenu;
    powerTimeSetMenu = newMenu();
    addSubMenu( timePowerOffSetMenu, powerTimeSetMenu );

    connectShowfun( powerTimeSetMenu, powerTimeSetMenuShow );

    connectUpKey( powerTimeSetMenu, powerTimeSetMenuOnUp );
    connectDownKey( powerTimeSetMenu, powerTimeSetMenuOnDown );

    connectLeftKey( powerTimeSetMenu, powerTimeSetMenuOnLeft );
    connectRightKey( powerTimeSetMenu, powerTimeSetMenuOnRight );

    connectOkKey( powerTimeSetMenu, powerTimeSetMenuOnOk );
    connectEscKey( powerTimeSetMenu, powerTimeSetMenuOnEsc );

    connectExec( powerTimeSetMenu, powerTimeSetMenuExec );
    
    
    

    /*
    ** 输入密码菜单
    */
    struct MENU *inputNumberMenu;
    inputNumberMenu = newMenu();
    
    connectMenu( timePowerOffSetMenu, inputNumberMenu );
    
    connectShowfun( inputNumberMenu, inputNumberMenuShow );

    connectUpKey( inputNumberMenu, inputNumberMenuOnUp );
    connectDownKey( inputNumberMenu, inputNumberMenuOnDown );
    
    connectLeftKey(inputNumberMenu, inputNumberMenuOnLeft);
    connectRightKey(inputNumberMenu, inputNumberMenuOnRight);    

    connectOkKey( inputNumberMenu, inputNumberMenuOnOk );
    connectEscKey( inputNumberMenu, inputNumberMenuOnEsc );
    
    
    
    
    
    /*
    ** 提示菜单
    */
    struct MENU *clewMenu;
    clewMenu = newMenu();
    addSubMenu( inputNumberMenu, clewMenu );

    connectShowfun( clewMenu, clewMenuShow );
    
    connectLeftKey( clewMenu, clewMenuOnLeft);
    connectRightKey( clewMenu, clewMenuOnRight);    

    connectOkKey( clewMenu, clewMenuOnOk );
    connectEscKey( clewMenu, clewMenuOnEsc );
    
    connectExec( clewMenu, clewMenuExec );
    
    



    
    
     /*
     * 校准流量菜单
     */
    struct MENU *calibrateFlowMenu;
    calibrateFlowMenu = newMenu();
    addSubMenu( clewMenu, calibrateFlowMenu );

    connectShowfun( calibrateFlowMenu, calibrateFlowMenuShow );

    connectUpKey( calibrateFlowMenu, calibrateFlowMenuOnUp );
    connectDownKey( calibrateFlowMenu, calibrateFlowMenuOnDown );

    connectLeftKey( calibrateFlowMenu, calibrateFlowMenuOnLeft );
    connectRightKey( calibrateFlowMenu, calibrateFlowMenuOnRight );

    connectOkKey( calibrateFlowMenu, calibrateFlowMenuOnOk );
    connectEscKey( calibrateFlowMenu, calibrateFlowMenuOnEsc );

    connectExec( calibrateFlowMenu, calibrateFlowMenuExec );
    

    return re;
}


void InitAllPara(void)
{
    unsigned int index;
    
    // 手动模式采样各参数默认值
    systems.status = STOP;
    systems.mod = HAND_MOVE_MODE;
    systems.old_mod = HAND_MOVE_MODE;
    systems.manu.flow = ORIGIN_FLOW;
    systems.manu.smp_time = ORIGIN_SMP_TIME;
    systems.manu.tim_vol_status = TIMING;
    systems.manu.smp_volume = 1.0;
    
    for ( index=0; index<10; index++ )
    {
        systems.groups[index].flow = ORIGIN_FLOW;
        systems.groups[index].smp_time = 10;
    }

    // 循环模式采样各参数默认值
    systems.cyls.cyl_num = 1;
    systems.cyls.flow = ORIGIN_FLOW;
    systems.cyls.mid_time = 10;
    systems.cyls.smp_time = ORIGIN_SMP_TIME;
    systems.cyls.tim_vol_status = TIMING;
    systems.cyls.smp_volume = 1.0;

    systems.a_flow = ORIGIN_FLOW;
    systems.a_volume = 1.0;
    systems.a_min = 1;

    systems.language = CHINESE;
    systems.set_language = CHINESE;
    systems.used_time = 0;
    systems.percent = 0;
    systems.start_sec = 0;
    systems.start_min = 0;
    
}

void keyEvent(unsigned char key)      //按键处理函数
{
    
    if(systems.status == SAMPLING)
    {
        if(getFault())
        {
           key = CANCELKEY;
        }
    }
    
    if ( COMPLETE == systems.status )
    {
        if ( CENTERKEY == key )
        {
            win->curfous->onOk();
        }else if(KEY_POWER == key)
        {
            stopPump();   //停止泵转动
            powerOff();   //关机
            //powerOn();    //使关机线重新为低电平
            goto exit;
        }
    }
    else
    {
        switch(key)
        {
        case UPKEY:
        {
            win->curfous->onUp();
        }
        break;
        case DOWNKEY:
        {
            win->curfous->onDown();
        }
        break;
        case LEFTKEY:
        {
            win->curfous->onLeft();
        }
        break;
        case RIGHTKEY:
        {
            win->curfous->onRight();
        }
        break;
        case CENTERKEY:
        {
            win->curfous->onOk();
        }
        break;
        case LENTERKEY:
        {
            win->curfous->longOnOk();
        }
        break;
        case CANCELKEY:
        {
            win->curfous->onEsc();
        }
        break;
    
        case KEY_POWER:
        {
            stopPump();   //停止泵转动
            powerOff();   //关机
            
            //powerOn();    //使关机线重新为低电平
            goto exit;
        }
        //break;
        default:break;
        }
    }

    systems.dynamic_flow = getCurFlow();

    Get_time( &systems.sys_time );

    ///win->batLevel = getBatLev();   //获得电池电量

    win->curfous->menuExec();
    
    sysExec();
    
exit:
    _NOP();
}

void sysExec(void)             //系统的循环执行函数
{
	static unsigned int old_sec = 0;    // 旧的秒
	static unsigned int old_complete = 0;    // 旧的
	unsigned int group, index;
	unsigned int sys_time;          // 当前系统时间，按分计算
	unsigned int grp_start_time;    // 组的启动时间
	unsigned int min_time = 2880;     // 距离最近将要进行采样组所需时间

	switch ( systems.status )
	{
    case STOP:
        systems.start_sec = 0;
        systems.start_min = 0;
        systems.percent = 0;
        systems.used_time = 0;
        systems.dynamic_flow = 0; 
        systems.dynamic_volume = 0;        
        systems.group_status = 0;
       
        break;    
        
	case SAMPLING:
		switch ( systems.mod )
		{
		case HAND_MOVE_MODE:
			if ( old_sec != systems.sys_time.sec )
			{
				old_sec = systems.sys_time.sec;
				systems.start_sec++;
                if ( TIMING == systems.manu.tim_vol_status )
                {
                    systems.percent = systems.used_time * 60;
                    systems.percent += systems.start_sec;
    				systems.percent = 1.0 * systems.percent / ( systems.manu.smp_time * 60 );
                }
                else
                {
                    systems.dynamic_volume += systems.dynamic_flow / 60; // 计算已采气体体积
                    systems.percent = 1.0 * systems.dynamic_volume / ( systems.manu.smp_volume * 1000 );
                }

				if ( systems.percent >= 1 )
				{
					systems.percent = 1;
				}

				if ( systems.start_sec == 60 )    // 计满一分钟
				{
					systems.start_sec = 0;
					systems.used_time++;
				}
			}

            if ( TIMING == systems.manu.tim_vol_status )
            {
                if ( systems.manu.smp_time <= systems.used_time )
                {	// 采样完成
                    systems.used_time = 0;
                    systems.start_sec = 0;
                    systems.percent = 0;
                    systems.status = COMPLETE;
                    old_complete = 1;
                    
                    stopPump();
                    systems.dynamic_flow = 0;                
                }
            }
            else
            {
               if ( systems.dynamic_volume >= (systems.manu.smp_volume * 1000) )
               {
                    systems.used_time = 0;
                    systems.start_sec = 0;
                    systems.percent = 0;
                    systems.status = COMPLETE;
                    old_complete = 1;
                    
                    stopPump();
                    systems.dynamic_flow = 0; 
                    systems.dynamic_volume = 0;
               }
            }
			break;
		case TIMING_MODE:
			if ( old_sec != systems.sys_time.sec )
			{
				old_sec = systems.sys_time.sec;
				systems.start_sec++;
				systems.percent = systems.used_time * 60;
				systems.percent += systems.start_sec;
				group = systems.cur_group;
				systems.percent = systems.percent / ( systems.groups[group].smp_time * 60 );
				
				systems.presure = getPFromFlow( systems.groups[group].flow );

				if ( systems.percent >= 1 )
				{
					systems.percent = 1;
				}

				if ( systems.start_sec == 60 )    // 计满一分钟
				{
					systems.start_sec = 0;
					systems.used_time++;
				}

				if ( systems.used_time >= systems.groups[group].smp_time )   // 已采完成
				{
					systems.used_time = 0;
					systems.percent = 0;
					systems.start_sec = 0;
					systems.group_status &= ~( 0x00000001 << (group*2) );
					systems.group_status |= ( 0x00000002 ) << (group*2);     // 将当前组设为采样完成状态
					sys_time = systems.sys_time.hour * 60;
					sys_time += systems.sys_time.min;

					for ( index = 0; index < 10; index++ )
					{
						if ( 1 == systems.groups[index].srb
							&& !( systems.group_status & ( 0x00000003 << (index*2))))
						{
							grp_start_time = systems.groups[index].start_time.hour * 60;
							grp_start_time += systems.groups[index].start_time.min;

							if ( grp_start_time <= sys_time )
							{
								grp_start_time += 1440;
							}

							if ( min_time > grp_start_time )
							{
								min_time = grp_start_time;
								group = index;
							}
						}
					}

					if ( min_time != 2880 )
					{
						systems.status = WAITING;
                        
	                    stopPump();
	                    systems.dynamic_flow = 0;
                        
						systems.cur_group = group;
					}
					else
					{
						systems.status = COMPLETE;
                        old_complete = 1;
                        
                        stopPump();
                        systems.dynamic_flow = 0;
                        
						systems.group_status = 0;      // 所有组状态复位
					}
				}

			}
			break;
		case CIRCLE_MODE:
			if ( old_sec != systems.sys_time.sec )
			{
				old_sec = systems.sys_time.sec;
				systems.start_sec++;
                
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    systems.percent = systems.used_time * 60;
                    systems.percent += systems.start_sec;    
                    systems.percent = systems.percent / ( systems.cyls.smp_time * 60 );
                }
                else
                {
                    systems.dynamic_volume += systems.dynamic_flow / 60; // 计算已采气体体积
                    systems.percent = 1.0 * systems.dynamic_volume / ( systems.cyls.smp_volume * 1000 );
                }
				
				systems.presure = getPFromFlow( systems.cyls.flow );

				if ( systems.percent >= 1 )
				{
					systems.percent = 1;
				}

				if ( systems.start_sec == 60 )    // 计满一分钟
				{
					systems.start_sec = 0;
					systems.used_time++;
				}
			}

            if ( TIMING == systems.cyls.tim_vol_status )
            {
                if ( systems.used_time >= systems.cyls.smp_time )     //本次循环时间已到
                {
                    systems.used_time = 0;
                    systems.start_sec = 0;
                    systems.percent = 0;
    
                    if ( systems.cyls.cyl_num - systems.cur_cyls - 1 )
                    {
                        systems.cur_cyls++;           //当前循环次数加1
                        systems.wait_sec = 59;          //
                        systems.status = WAITING;       //进入等待状态，等下一次循环的到来
                        systems.wait_time = systems.cyls.mid_time - 1;    //距离下一次采样需要等待的时间
                        
                        stopPump();
                        systems.dynamic_flow = 0;                        
                    }
                    else      //所有循环已结束
                    {
                        systems.cur_cyls = 0;
                        systems.status = COMPLETE;
                        old_complete = 1;
                        
                        stopPump();
                        systems.dynamic_flow = 0;
                    }
                }
            }
            else
            {            
                if ( systems.dynamic_volume >= (systems.cyls.smp_volume * 1000 ) )
                {
                    systems.used_time = 0;
                    systems.start_sec = 0;
                    systems.percent = 0;
    
                    if ( systems.cyls.cyl_num - systems.cur_cyls - 1 )
                    {
                        systems.cur_cyls++;           //当前循环次数加1
                        systems.wait_sec = 59;          //
                        systems.status = WAITING;       //进入等待状态，等下一次循环的到来
                        systems.wait_time = systems.cyls.mid_time - 1;    //距离下一次采样需要等待的时间
                        
                        stopPump();
                        systems.dynamic_flow = 0;
                        systems.dynamic_volume = 0;                    
                    }
                    else      //所有循环已结束
                    {
                        systems.cur_cyls = 0;
                        systems.status = COMPLETE;
                        old_complete = 1;
                        
                        stopPump();
                        systems.dynamic_flow = 0;
                        systems.dynamic_volume = 0;
                    }
                }
            }
			break;
		default: break;
		}
		break;

	case COMPLETE:
        if ( old_complete )
        {
            old_complete = 0;
            
            systems.dynamic_flow = 0;
            systems.dynamic_volume = 0;
            
            win->twoOldCurfous = win->curfous;
            win->curfous = win->twoErrMenu;
            win->curfous->show();
        }
		break;

	case WAITING:
        systems.dynamic_flow = 0;
		switch ( systems.mod )
		{
		case CIRCLE_MODE:
			if ( old_sec != systems.sys_time.sec )
			{
				old_sec = systems.sys_time.sec;
				if ( systems.wait_sec == 0 )
				{
					systems.wait_sec = 59;
					if ( systems.wait_time == 0 )
					{
						systems.wait_sec = 0;
						systems.status = SAMPLING;         // 进入采样状态
                        
                        startPump( systems.cyls.flow );     // 启动采样                        
					}
					else
					{
						systems.wait_time--;       //等待时间自减1
					}
				}
				else
				{
					systems.wait_sec--;
				}
			}
			break;
		case TIMING_MODE:
			if ( old_sec != systems.sys_time.sec )
			{
				old_sec = systems.sys_time.sec;
                                    
				group = systems.cur_group;
				if ( systems.groups[group].start_time.hour == systems.sys_time.hour
						&& systems.groups[group].start_time.min == systems.sys_time.min )
				{
					systems.group_status |= 0x00000001 << (group*2);   // 设置为正在采样状态
                    
					systems.status = SAMPLING;    // 进行采样
					systems.start_sec = 0;
                    
                    startPump( systems.groups[group].flow );
				}
			}
			break;

		default: break;
		}

		break;
	default: break;
	}
    
    batlevelExec();
    
    if ( systems.power_status )   // 系统自动关机状态是否启用
    {   
        if ( systems.power_time.hour == systems.sys_time.hour
             && systems.power_time.min == systems.sys_time.min
             && systems.power_time.sec == systems.sys_time.sec )
        {
            stopPump();
            
            powerOff();
        }
    }
}

void batlevelExec(void)             
{
    if ( systems.bat_count > 0 )
    {
        systems.bat_count--;
    }
    else
    {
        if ( win->batLevel == 0 
            && win->curfous != win->errMenu 
            && COMPLETE != systems.status )
        {
            win->oldCurfous = win->curfous;
            win->curfous = win->errMenu;
            win->curfous->show();
        }
    }
}

void errorMenuShow(void)
{
    struct MENU *lp;
    lp = win->curfous;
    win->mLevel = 0;
    lp->status1 = 0;
    clr_lcd();

    if ( 0 == win->batLevel )
    {    
        draw_rect( 0, 0, 128, 64 );
        draw_rect( 44, 10, 37, 20 );
        draw_rect( 80, 13, 6, 14 );
        if ( ENGLISH == systems.language )
        {
            print_str( 37, 30, "Low Power!", 0 );
            draw_button( 85, 45, "OK", 1, 0 );
        }
        else
        {
            print_ch_str( 46, 30, "电量低", 0 );
            draw_button( 85, 45, "确定", 1, 1 );
        }
    }
    else if ( SAMPLING == systems.status 
        && ( HAND_MOVE_MODE == systems.mod || CIRCLE_MODE == systems.mod ) )
    {
        draw_rect( 0, 0, 128, 64 );
        draw_line( 15, 15, 112, 15 );    
    
        if ( ENGLISH == systems.language )
        {
            print_str( 40, 3, "Warning !", 0 );
            if ( TIMING == systems.manu.tim_vol_status
                 || TIMING == systems.cyls.tim_vol_status )
            {            
                print_str( 2, 20, "Cancel this timing?", 0 );
            }
            else
            {
                print_str( 4, 20, "Cancel this ration?", 0 );
            }
            draw_button( 26, 45, "OK", 1, ENGLISH );
            draw_button( 73, 45, "Esc", 0, ENGLISH );
        }
        else
        {
            print_ch_str( 40, 3, "警告", 0 );
            putchar( 70, 3, '!', 0 );
            if ( TIMING == systems.manu.tim_vol_status 
                 || TIMING == systems.cyls.tim_vol_status )
            {
                print_ch_str( 15, 20, "是否要取消定时", 0 );
                print_ch_str( 15, 32, "间模式采样", 0 );
            }
            else
            {
                print_ch_str( 15, 20, "是否要取消定", 0 );
                print_ch_str( 15, 32, "容模式采样", 0 );
            }
            putchar( 75, 32, '?', 0 );
            draw_button( 26, 45, "确定", 1, CHINESE );
            draw_button( 73, 45, "取消", 0, CHINESE );
        } 
    } 
}


void errorMenuLeft(void)
{
    struct MENU *lp;
    lp = win->curfous;
    if ( SAMPLING == systems.status 
        && ( HAND_MOVE_MODE == systems.mod || CIRCLE_MODE == systems.mod ) )
    {
        if ( ENGLISH == systems.language )
        {
            switch ( lp->status1 )
            {
            case 0:
                lp->status1 = 1;
                draw_button( 26, 45, "OK", 0, ENGLISH );
                draw_button( 73, 45, "Esc", 1, ENGLISH );
                break;
            case 1:
                lp->status1 = 0;
                draw_button( 26, 45, "OK", 1, ENGLISH );
                draw_button( 73, 45, "Esc", 0, ENGLISH );
                break;
            default: break;
            }
        }
        else
        {
            switch ( lp->status1 )
            {
            case 0:
                lp->status1 = 1;
                draw_button( 26, 45, "确定", 0, CHINESE );
                draw_button( 73, 45, "取消", 1, CHINESE );
                break;
            case 1:
                lp->status1 = 0;
                draw_button( 26, 45, "确定", 1, CHINESE );
                draw_button( 73, 45, "取消", 0, CHINESE );
                break;
            default: break;
            }
        }
    }
}

void errorMenuRight(void)
{
    errorMenuLeft();
}

void errorMenuOnOk(void)
{
    struct MENU *lp;
    
    if ( 0 == win->batLevel )
    {
        if ( COMPLETE == systems.status )
        {
            systems.status = STOP;
            win->curfous = win->oldCurfous;
            lp = win->curfous;
            if ( lp->topMenu )
            {
                win->curfous = lp->topMenu;
                win->curfous->show();
            }
        }
        else
        {
            systems.bat_count = 1000;
            win->curfous = win->oldCurfous;
            win->curfous->show();
        }
    }
    else if ( SAMPLING == systems.status )
    {
        lp = win->curfous;
        if ( 0 == lp->status1 )
        {
            systems.status = STOP;
            stopPump();
            if ( HAND_MOVE_MODE == systems.mod )
            {
                systems.manu.tim_vol_status = !systems.manu.tim_vol_status;
            }
            else if ( CIRCLE_MODE == systems.mod )
            {
                systems.cyls.tim_vol_status = !systems.cyls.tim_vol_status;
            }
            win->curfous = win->oldCurfous;
            win->curfous->show();
        }
        else if ( 1 == lp->status1 )
        {
            win->curfous = win->oldCurfous;
            win->curfous->show();
        }
    }
/*    else if ( systems.status == COMPLETE )
    {
        systems.status = STOP;
        win->curfous = win->oldCurfous;
        lp = win->curfous;
        if ( lp->topMenu )
        {
            win->curfous = lp->topMenu;
            win->curfous->show();
        }
    }*/
    
    if ( win->mLevel == 2 && ( systems.status == STOP || systems.status == COMPLETE ))
    {
        systems.status = STOP;
        win->curfous = win->oldCurfous;
        lp = win->curfous;
        if ( lp->topMenu )
        {
            win->curfous = lp->topMenu;
            win->curfous->show();
        }
    }
}

static void twoErrMenuShow(void)
{
    if ( systems.mod == TIMING_MODE && systems.status != COMPLETE )
    {
        draw_rect( 0, 0, 128, 64 );
        draw_line( 15, 15, 112, 15 );
        if ( ENGLISH == systems.language )
        {
            print_str( 40, 3, "Warning !", 0 );
            print_str( 20, 18, "No Group is ON !", 0 );
            print_str( 10, 33, "Please set a Group!", 0 );
            draw_button( 93, 46, "Exit", 1, ENGLISH );
        }
        else
        {
            print_ch_str( 52, 3, "警告", 0 );
            putchar( 82, 3, '!', 0 );
            print_ch_str( 20, 18, "无定时组被启用", 0 );
            putchar( 110, 18, '!', 0 );
            print_ch_str( 22, 33, "请设置一个组", 0 );
            draw_button( 93, 46, "退出", 1, CHINESE );
        }
    }
    //采样完成菜单
    else
    {
        clr_lcd();
        draw_rect( 0, 0, 128, 64 );
        if ( ENGLISH == systems.language )
        {
            switch ( systems.mod )
            {
            case HAND_MOVE_MODE:
                print_str( 9, 26, "Sampling complete!", 0 );
                draw_button( 93, 46, "Ok", 1, ENGLISH );
                break;
            case TIMING_MODE:
                print_str( 2, 25, "All groups is completed", 0 );
                draw_button( 93, 44, "OK", 1, ENGLISH );
                break;
            case CIRCLE_MODE:
                print_str( 1, 25, "All Cycles is Completed.", 0 );
                draw_button( 93, 44, "Ok", 1, ENGLISH );
                break;
            default: break;
            }
        }
        else
        {
            switch ( systems.mod )
            {
            case HAND_MOVE_MODE:
                print_ch_str( 38, 26, "采样完成", 0 );
                putchar( 87, 26, '!', 0 );
                draw_button( 93, 46, "确定", 1, CHINESE );
                break;
            case TIMING_MODE:
                print_ch_str( 10, 25, "所有组已采样完成", 0 );
                draw_button( 93, 44, "确定", 1 , CHINESE );
                break;
            case CIRCLE_MODE:
                print_ch_str( 10, 25, "所有循环已采样完成", 0 );
                draw_button( 93, 44, "确定", 1, CHINESE );
                break;
            default: break;
            }
        }
    }
}

static void twoErrMenuOkKey(void)
{
    struct MENU* lp;
    
    if ( systems.mod == TIMING_MODE && systems.status != COMPLETE )
    {
        win->curfous = win->twoOldCurfous;
        lp = win->curfous;
        if ( lp->topMenu )
        {
            win->curfous = lp->topMenu;
            win->curfous->show();
            systems.status = STOP;
            status_show( systems.status );
        }
    }
    //采样已完成
    else
    {
        if ( win->mLevel == 2 )   // 处于正在采样级别菜单
        {
            systems.status = STOP;
            win->curfous = win->twoOldCurfous;
            lp = win->curfous;
            win->curfous = lp->topMenu;
            win->curfous->show();
            status_show( systems.status );
        }
        else  // 其他级别菜当
        {
            systems.status = STOP;
            win->curfous = win->twoOldCurfous;
            win->curfous->show();            
        }
    }
}



void batShow( int mod)    //电池电量显示函数，mod=1为强行显示
{                        //mod = 0为只有电量变化时才显示
    static int oldLevel = 0;
    static int batCount = 0;
    static int modInter = 0;
    
    if(isCharge())     //处于充电状态
    {
        
        if(mod == 1)
        {
            batCount = 0;
            draw_symbol( 109, 1, 18, 8, battery_icn+win->batLevel*18, 0 );
        }
        
        if(win->batLevel == 0)
        {
            if(batCount == 100)
            {
                draw_symbol( 109, 1, 18, 8, battery_icn+4*18, 0 );
                batCount = 0;
            }else if(batCount == 80)
            {
                draw_symbol( 109, 1, 18, 8, battery_icn+3*18, 0 );
            }else if(batCount == 60)
            {
                draw_symbol( 109, 1, 18, 8, battery_icn+2*18, 0 );
            }else if(batCount == 40)
            {
                draw_symbol( 109, 1, 18, 8, battery_icn+18, 0 );
            }else if(batCount == 20)
            {
                draw_symbol( 109, 1, 18, 8, battery_icn, 0 );
            }
        }else if(win->batLevel == 1)
        {
            if(batCount == 80)
            {
                draw_symbol( 109, 1, 18, 8, battery_icn+4*18, 0 );
                batCount = 0;
            }else if(batCount == 60)
            {
                draw_symbol( 109, 1, 18, 8, battery_icn+3*18, 0 );
            }else if(batCount == 40)
            {
                draw_symbol( 109, 1, 18, 8, battery_icn+2*18, 0 );
            }else if(batCount == 20)
            {
                draw_symbol( 109, 1, 18, 8, battery_icn+18, 0 );
            }
        }else if(win->batLevel == 2)
        {
            if(batCount == 60)
            {
                draw_symbol( 109, 1, 18, 8, battery_icn+4*18, 0 );
                batCount = 0;
            }else if(batCount == 40)
            {
                draw_symbol( 109, 1, 18, 8, battery_icn+3*18, 0 );
            }else if(batCount == 20)
            {
                draw_symbol( 109, 1, 18, 8, battery_icn+2*18, 0 );
            }
        }else if(win->batLevel == 3)
        {
            if(batCount == 40)
            {
                draw_symbol( 109, 1, 18, 8, battery_icn+4*18, 0 );
                batCount = 0;
            }else if(batCount == 20)
            {
                draw_symbol( 109, 1, 18, 8, battery_icn+3*18, 0 );
            }
        }else if(oldLevel != win->batLevel)
        {
            oldLevel = win->batLevel;
            draw_symbol( 109, 1, 18, 8, battery_icn+4*18, 0 );
        }
        modInter = 1;
        batCount ++;
        
    }else
    {
        batCount = 0;
        if( mod == 0 && oldLevel != win->batLevel )  //如果新的电量值不等于旧的电量值
        {
            oldLevel = win->batLevel;
            draw_symbol( 109, 1, 18, 8, battery_icn+oldLevel*18, 0 );
        }
        else if( mod || modInter)
        {
            oldLevel = win->batLevel;
            modInter = 0;

            draw_symbol( 109, 1, 18, 8, battery_icn+oldLevel*18, 0 );
        }  
    }
    
}

void topAssistMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
    win->mLevel = 0;
    
    if ( WAITING == systems.status || SAMPLING == systems.status )
    {
        switch ( systems.mod )
        {
        case HAND_MOVE_MODE:
            if ( lp->subMenu )
            {
                win->curfous = lp->subMenu;
                lp = win->curfous;
                if ( lp->subMenu )
                {
                    win->curfous = lp->subMenu;
                    win->curfous->show();
                }
            }
            break;
        case TIMING_MODE:
            if ( lp->subMenu )
            {
                win->curfous = lp->subMenu->rMenu;
                lp = win->curfous;
                if ( lp->subMenu )
                {
                    win->curfous = lp->subMenu;
                    win->curfous->show();
                }
            }
            break;
        case CIRCLE_MODE:
            if ( lp->subMenu )
            {
                win->curfous = lp->subMenu->rMenu->rMenu;
                lp = win->curfous;
                if ( lp->subMenu )
                {
                    win->curfous = lp->subMenu;
                    win->curfous->show();
                }
            }
            break;
        default: break;
        }   
    }
    else
    {        
        switch ( systems.mod )
        {
        case HAND_MOVE_MODE:
            if ( lp->subMenu )
            {
                win->curfous = lp->subMenu;
                win->curfous->show();
            }
            break;
        case TIMING_MODE:
            if ( lp->subMenu )
            {
                win->curfous = lp->subMenu->rMenu;
                win->curfous->show();
            }
            break;
        case CIRCLE_MODE:
            if ( lp->subMenu )
            {
                win->curfous = lp->subMenu->rMenu->rMenu;
                win->curfous->show();
            }
            break;
        default: break;
        }
    }
}



/*
 * 待机状态下的显示菜单函数
 * 显示待机装下的用户界面
 */
void topManuMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
    win->mLevel = 1;

	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( STAT_X, STAT_Y, 12, 12, status_icn[systems.status], 0 );
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	print_str( USED_X+36, USED_Y, ":    ", 0 );     // 显示已采样时间min字样
	draw_rect( PERC_X, PERC_Y+1, 62, 10 );            // 画一个进度条

	print_int( 112, 36, 0, 0 );		// 打印百分比

	print_str( 100, 36, "   %", 0 );        // 显示%字样
	print_str( FLOW_X+24, FLOW_Y, ":    mL/min", 0 );  // 显示mL/min字样

	if ( ENGLISH == systems.language )
	{
		switch ( systems.mod )
		{
		case HAND_MOVE_MODE:
			print_str( MOD_X, MOD_Y, "MANU", 0 );
			break;
		case TIMING_MODE:
			print_str( MOD_X, MOD_Y, "TIM", 0 );
			break;
		case CIRCLE_MODE:
			print_str( MOD_X, MOD_Y, "CYL", 0 );
			break;
		default: break;
		}

		switch ( lp->status1 )
		{
		case 0:
		{
			draw_button( 0, 12, "S", 1, ENGLISH );
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "Time", 0, ENGLISH );
            }
            else
            {
			    draw_button( 0, 30, "V", 0, ENGLISH );
            }
			draw_button( 0, 48, "Set", 0, ENGLISH );
		}
			break;
		case 1:
		{
			draw_button( 0, 12, "S", 0, ENGLISH );
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "Time", 1, ENGLISH );
            }
            else
            {
                draw_button( 0, 30, "V", 1, ENGLISH );
            }
			draw_button( 0, 48, "Set", 0, ENGLISH );
		}
			break;
		case 2:
		{
			draw_button( 0, 12, "S", 0, ENGLISH );
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "Time", 0, ENGLISH );
            }
            else
            {
                draw_button( 0, 30, "V", 0, ENGLISH );
            }
			draw_button( 0, 48, "Set", 1, ENGLISH );
		}
			break;
		}

		print_str( 36, 12, "FLOW", 0 );
		print_str( USED_X, USED_Y, "SMPTim", 0 );    // 显示已采样字样
	}
	else
	{
		switch ( systems.mod )
		{
		case HAND_MOVE_MODE:
			print_ch_str( MOD_X, MOD_Y, "手动", 0 );
			break;
		case TIMING_MODE:
			print_ch_str( MOD_X, MOD_Y, "定时", 0 );
			break;
		case CIRCLE_MODE:
			print_ch_str( MOD_X, MOD_Y, "循环", 0 );
			break;
		default: break;
		}

		switch ( lp->status1 )
		{
		case 0:
		{
			draw_button( 0, 12, "启动", 1, CHINESE );
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "时长", 0, CHINESE );
            }
            else
            {
			    draw_button( 0, 30, "定容", 0, CHINESE );
            }
			draw_button( 0, 48, "设置", 0, CHINESE );
		}
			break;
		case 1:
		{
			draw_button( 0, 12, "启动", 0, CHINESE );
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "时长", 1, CHINESE );
            }
            else
            {
                draw_button( 0, 30, "定容", 1, CHINESE );
            }
			draw_button( 0, 48, "设置", 0, CHINESE );
		}
			break;
		case 2:
		{
			draw_button( 0, 12, "启动", 0, CHINESE );
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "时长", 0, CHINESE );
            }
            else
            {
			    draw_button( 0, 30, "定容", 0, CHINESE );
            }
			draw_button( 0, 48, "设置", 1, CHINESE );
		}
			break;
		}

		print_ch_str( 36, 12, "流量", 0 );
		print_ch_str( USED_X, USED_Y, "已采样", 0 );    // 显示已采样字样
	}


	// 打印系统当前时间
	show_time(1);
    
    print_str( 38, 50, "F:", 0 );
    draw_symbol( 50, 50, 9, 12, jian_mu, 0 );
    draw_symbol( 85, 50, 9, 12, plus_mu, 0 );
    if ( systems.manu.flow >= 1000 )
    {
        print_int( 60 , 50, systems.manu.flow, 0 );
    }
    else if ( systems.manu.flow >= 100 )
    {
         print_int( 63 , 50, systems.manu.flow, 0 );
    }
    else if ( systems.manu.flow > 10 )
    {
         print_int( 66 , 50, systems.manu.flow, 0 );
    }
	
    systems.dynamic_flow = 0;
    flow_show( (unsigned int)( systems.dynamic_flow ) );    // 动态流量显示
	percent_show( systems.percent );
    
    if ( TIMING == systems.manu.tim_vol_status )
    {
        putchar( USED_X+66, USED_Y, ':', 0 );    // 显示已采样时间字样的分与秒之间的 ：
        used_time_show( systems.used_time, systems.start_sec );  // 已用时显示
    }
    else
    {
        putchar( USED_X+80, USED_Y, 'L', 0 );      // 显示已采样体积的体积符号 L
        used_volume_show( systems.dynamic_volume );  // 已用时显示
    }
    
	batShow(1);    //显示电池图标
}

void topManuMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 2;
			draw_button( 0, 12, "S", 0, ENGLISH );
			draw_button( 0, 48, "Set", 1, ENGLISH );
			break;
            
		case 1:
			lp->status1 = 0;
			draw_button( 0, 12, "S", 1, ENGLISH );
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "Time", 0, ENGLISH );
            }
            else
            {
			    draw_button( 0, 30, "V", 0, ENGLISH );
            }
			break;
            
		case 2:
			lp->status1 = 1;
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "Time", 1, ENGLISH );
            }
            else
            {
			    draw_button( 0, 30, "V", 1, ENGLISH );
            }
			draw_button( 0, 48, "Set", 0, ENGLISH );
			break;
            
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 2;
			draw_button( 0, 12, "启动", 0, CHINESE );
			draw_button( 0, 48, "设置", 1, CHINESE );
			break;
            
		case 1:
			lp->status1 = 0;
			draw_button( 0, 12, "启动", 1, CHINESE );
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "时长", 0, CHINESE );
            }
            else
            {
			    draw_button( 0, 30, "定容", 0, CHINESE );
            }
			break;
            
		case 2:
			lp->status1 = 1;
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "时长", 1, CHINESE );
            }
            else
            {
			    draw_button( 0, 30, "定容", 1, CHINESE );
            }
			draw_button( 0, 48, "设置", 0, CHINESE );
			break;
		default: break;
		}
	}
}

void topManuMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			draw_button( 0, 12, "S", 0, ENGLISH );
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "Time", 1, ENGLISH );
            }
            else
            {
			    draw_button( 0, 30, "V", 1, ENGLISH );
            }
			break;
		case 1:
		{
			lp->status1 = 2;
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "Time", 0, ENGLISH );
            }
            else
            {
			    draw_button( 0, 30, "V", 0, ENGLISH );
            }
			draw_button( 0, 48, "Set", 1, ENGLISH );
		}
			break;
		case 2:
		{
			lp->status1 = 0;
			draw_button( 0, 12, "S", 1, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
		}
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			draw_button( 0, 12, "启动", 0, CHINESE );
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "时长", 1, CHINESE );
            }
            else
            {
			    draw_button( 0, 30, "定容", 1, CHINESE );
            }
			break;
            
		case 1:
			lp->status1 = 2;
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "时长", 0, CHINESE );
            }
            else
            {
			    draw_button( 0, 30, "定容", 0, CHINESE );
            }
			draw_button( 0, 48, "设置", 1, CHINESE );
			break;
            
		case 2:
		{
			lp->status1 = 0;
			draw_button( 0, 12, "启动", 1, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
		}
			break;
		default: break;
		}
	}
}

void topManuMenuOnLeft(void)
{
    print_str( 38, 50, "F:", 0 );
    draw_symbol( 50, 50, 9, 12, jian_mu, 0 );
    draw_symbol( 85, 50, 9, 12, plus_mu, 0 );

    if ( systems.manu.flow > MIN_FLOW )
    {
        systems.manu.flow -= MID_FLOW;
    }
    else
    {
        systems.manu.flow = MAX_FLOW;
    }
    
    clr_rect( 60, 50, 24, 12 );
    if ( systems.manu.flow >= 1000 )
    {
        print_int( 60 , 50, systems.manu.flow, 0 );
    }
    else if ( systems.manu.flow >= 100 )
    {
         print_int( 63 , 50, systems.manu.flow, 0 );
    }
    else if ( systems.manu.flow > 10 )
    {
         print_int( 66 , 50, systems.manu.flow, 0 );
    }
}


void topManuMenuOnRight(void)
{
    print_str( 38, 50, "F:", 0 );
    draw_symbol( 50, 50, 9, 12, jian_mu, 0 );
    draw_symbol( 85, 50, 9, 12, plus_mu, 0 );

    if ( systems.manu.flow < MAX_FLOW )
    {
        systems.manu.flow += MID_FLOW;
    }
    else
    {
        systems.manu.flow = MIN_FLOW;
    }
    
    clr_rect( 60, 50, 24, 12 );
    if ( systems.manu.flow >= 1000 )
    {
        print_int( 60 , 50, systems.manu.flow, 0 );
    }
    else if ( systems.manu.flow >= 100 )
    {
         print_int( 63 , 50, systems.manu.flow, 0 );
    }
    else if ( systems.manu.flow > 10 )
    {
         print_int( 66 , 50, systems.manu.flow, 0 );
    }
}

void topManuMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;

	switch ( lp->status1 )
	{
	case 0:
		if ( lp->subMenu )
		{
			systems.used_time = 0;
			systems.start_sec = 0;
			systems.percent = 0;

			systems.status = SAMPLING;	// 启动采样
			systems.presure = getPFromFlow( systems.manu.flow );
            
            startPump( systems.manu.flow );

			win->curfous = lp->subMenu;
			win->curfous->show();		// 进入启动菜单
		}
		break;
	case 1:
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu->rMenu;
			win->curfous->show();		// 进入采样时长设置菜单
		}
		break;
	case 2:
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu->rMenu->rMenu;
			win->curfous->show();		// 进入各种设置菜单
		}
		break;
	default: break;
	}
}

void topManuMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void topManuMenuExec(void)
{
	show_time(0);
    
    batShow( 0 );
}

/**
** 系统待机时定时模式的菜单
**/
void topTimeMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
    win->mLevel = 1;

	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( STAT_X, STAT_Y, 12, 12, status_icn[systems.status], 0 );
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	print_str( USED_X+36, USED_Y, ":    :", 0 );     // 显示已采样时间min字样
	draw_rect( PERC_X, PERC_Y+1, 62, 10 );            // 画一个进度条

	print_int( 112, 36, 0, 0 );		// 打印百分比

	print_str( 100, 36, "   %", 0 );        // 显示%字样
	print_str( FLOW_X+24, FLOW_Y, ":    mL/min", 0 );  // 显示mL/min字样

	if ( ENGLISH == systems.language )
	{
		switch ( systems.mod )
		{
		case HAND_MOVE_MODE:
			print_str( MOD_X, MOD_Y, "MANU", 0 );
			break;
		case TIMING_MODE:
			print_str( MOD_X, MOD_Y, "TIM", 0 );
			break;
		case CIRCLE_MODE:
			print_str( MOD_X, MOD_Y, "CYL", 0 );
			break;
		default: break;
		}

		switch ( lp->status1 )
		{
		case 0:
		{
			draw_button( 0, 12, "S", 1, ENGLISH );
			draw_button( 0, 30, "View", 0, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
		}
			break;
		case 1:
		{
			draw_button( 0, 12, "S", 0, ENGLISH );
			draw_button( 0, 30, "View", 1, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
		}
			break;
		case 2:
		{
			draw_button( 0, 12, "S", 0, ENGLISH );
			draw_button( 0, 30, "View", 0, ENGLISH );
			draw_button( 0, 48, "Set", 1, ENGLISH );
		}
			break;
		}

		print_str( 36, 12, "FLOW", 0 );
		print_str( USED_X, USED_Y, "SMPTim", 0 );    // 显示已采样字样
	}
	else
	{
		switch ( systems.mod )
		{
		case HAND_MOVE_MODE:
			print_ch_str( MOD_X, MOD_Y, "手动", 0 );
			break;
		case TIMING_MODE:
			print_ch_str( MOD_X, MOD_Y, "定时", 0 );
			break;
		case CIRCLE_MODE:
			print_ch_str( MOD_X, MOD_Y, "循环", 0 );
			break;
		default: break;
		}

		switch ( lp->status1 )
		{
		case 0:
		{
			draw_button( 0, 12, "启动", 1, CHINESE );
			draw_button( 0, 30, "查看", 0, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
		}
			break;
		case 1:
		{
			draw_button( 0, 12, "启动", 0, CHINESE );
			draw_button( 0, 30, "查看", 1, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
		}
			break;
		case 2:
		{
			draw_button( 0, 12, "启动", 0, CHINESE );
			draw_button( 0, 30, "查看", 0, CHINESE );
			draw_button( 0, 48, "设置", 1, CHINESE );
		}
			break;
		}

		print_ch_str( 36, 12, "流量", 0 );
		print_ch_str( USED_X, USED_Y, "已采样", 0 );    // 显示已采样字样
	}

	// 打印系统当前时间
	show_time(1);

    systems.dynamic_flow = 0;
	flow_show( (unsigned int)( systems.dynamic_flow ) );    // 动态流量显示
	percent_show( systems.percent );
	used_time_show( systems.used_time, systems.start_sec );  // 已用时显示
	batShow(1);    //显示电池图标
}

void topTimeMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
		{
			lp->status1 = 2;
			draw_button( 0, 12, "S", 0, ENGLISH );
			draw_button( 0, 48, "Set", 1, ENGLISH );
		}
			break;
		case 1:
		{
			lp->status1 = 0;
			draw_button( 0, 12, "S", 1, ENGLISH );
			draw_button( 0, 30, "View", 0, ENGLISH );
		}
			break;
		case 2:
		{
			lp->status1 = 1;
			draw_button( 0, 30, "View", 1, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
		}
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
		{
			lp->status1 = 2;
			draw_button( 0, 12, "启动", 0, CHINESE );
			draw_button( 0, 48, "设置", 1, CHINESE );
		}
			break;
		case 1:
		{
			lp->status1 = 0;
			draw_button( 0, 12, "启动", 1, CHINESE );
			draw_button( 0, 30, "查看", 0, CHINESE );
		}
			break;
		case 2:
		{
			lp->status1 = 1;
			draw_button( 0, 30, "查看", 1, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
		}
			break;
		default: break;
		}
	}
}

void topTimeMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
		{
			lp->status1 = 1;
			draw_button( 0, 12, "S", 0, ENGLISH );
			draw_button( 0, 30, "View", 1, ENGLISH );
		}
			break;
		case 1:
		{
			lp->status1 = 2;
			draw_button( 0, 30, "View", 0, ENGLISH );
			draw_button( 0, 48, "Set", 1, ENGLISH );
		}
			break;
		case 2:
		{
			lp->status1 = 0;
			draw_button( 0, 12, "S", 1, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
		}
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
		{
			lp->status1 = 1;
			draw_button( 0, 12, "启动", 0, CHINESE );
			draw_button( 0, 30, "查看", 1, CHINESE );
		}
			break;
		case 1:
		{
			lp->status1 = 2;
			draw_button( 0, 30, "查看", 0, CHINESE );
			draw_button( 0, 48, "设置", 1, CHINESE );
		}
			break;
		case 2:
		{
			lp->status1 = 0;
			draw_button( 0, 12, "启动", 1, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
		}
			break;
		default: break;
		}
	}
}

void topTimeMenuOnOk(void)
{
	struct MENU *lp;
    unsigned int grp_start_time;    //组的启动时间
    unsigned int sys_time;
    unsigned int min_time = 2880;     // 距离最近将要进行采样组所需时间
    unsigned int index;
    
	lp = win->curfous;

	switch ( lp->status1 )
	{
	case 0:
		if ( lp->subMenu )
		{
			systems.used_time = 0;
			systems.start_sec = 0;
			systems.percent = 0;

			win->curfous = lp->subMenu;
            systems.status = WAITING; 
            
			sys_time = systems.sys_time.hour * 60;
			sys_time += systems.sys_time.min;	// 当前系统时间
            
            for ( index=0; index<10; index++ )
            {
                if ( 1 == systems.groups[index].srb )
                {
                    // 索引到的组的启动时间
                    grp_start_time = systems.groups[index].start_time.hour * 60;
                    grp_start_time += systems.groups[index].start_time.min;

                    if ( grp_start_time <= sys_time )
                    {	// 索引到的组的启动时间  <= 当前系统时间
                        grp_start_time += 1440;
                    }

                    if ( min_time > grp_start_time )
                    {
                        min_time = grp_start_time;
                        systems.cur_group = index;
                    }
                }
            }
                        
			win->curfous->show();		// 进入启动菜单
                       
		}
		break;

	case 1:
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu->rMenu;
			win->curfous->show();		// 进入采样时长设置菜单
		}

		break;
	case 2:
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu->rMenu->rMenu;
			win->curfous->show();		// 进入各种设置菜单
		}
		break;

	default: break;
	}
}

void topTimeMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void topTimeMenuExec(void)
{
	show_time(0);
    
    batShow( 0 );
}



/**
** 系统待机时循环模式的菜单
**/
void topCylMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
    win->mLevel = 1;

	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( STAT_X, STAT_Y, 12, 12, status_icn[systems.status], 0 );
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	print_str( USED_X+36, USED_Y, ":    ", 0 );     // 显示已采样时间min字样
	draw_rect( PERC_X, PERC_Y+1, 62, 10 );            // 画一个进度条

	print_int( 112, 36, 0, 0 );		// 打印百分比

	print_str( 100, 36, "   %", 0 );        // 显示%字样
	print_str( FLOW_X+24, FLOW_Y, ":    mL/min", 0 );  // 显示mL/min字样

	if ( ENGLISH == systems.language )
	{
		switch ( systems.mod )
		{
		case HAND_MOVE_MODE:
			print_str( MOD_X, MOD_Y, "MANU", 0 );
			break;
		case TIMING_MODE:
			print_str( MOD_X, MOD_Y, "TIM", 0 );
			break;
		case CIRCLE_MODE:
			print_str( MOD_X, MOD_Y, "CYL", 0 );
			break;
		default: break;
		}

		switch ( lp->status1 )
		{
		case 0:
		{
			draw_button( 0, 12, "S", 1, ENGLISH );
			draw_button( 0, 30, "View", 0, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
		}
			break;
		case 1:
		{
			draw_button( 0, 12, "S", 0, ENGLISH );
			draw_button( 0, 30, "View", 1, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
		}
			break;
		case 2:
		{
			draw_button( 0, 12, "S", 0, ENGLISH );
			draw_button( 0, 30, "View", 0, ENGLISH );
			draw_button( 0, 48, "Set", 1, ENGLISH );
		}
			break;
		}

		print_str( 36, 12, "FLOW", 0 );
		print_str( USED_X, USED_Y, "SMPTim", 0 );    // 显示已采样字样
	}
	else
	{
		switch ( systems.mod )
		{
		case HAND_MOVE_MODE:
			print_ch_str( MOD_X, MOD_Y, "手动", 0 );
			break;
		case TIMING_MODE:
			print_ch_str( MOD_X, MOD_Y, "定时", 0 );
			break;
		case CIRCLE_MODE:
			print_ch_str( MOD_X, MOD_Y, "循环", 0 );
			break;
		default: break;
		}

		switch ( lp->status1 )
		{
		case 0:
		{
			draw_button( 0, 12, "启动", 1, CHINESE );
			draw_button( 0, 30, "查看", 0, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
		}
			break;
		case 1:
		{
			draw_button( 0, 12, "启动", 0, CHINESE );
			draw_button( 0, 30, "查看", 1, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
		}
			break;
		case 2:
		{
			draw_button( 0, 12, "启动", 0, CHINESE );
			draw_button( 0, 30, "查看", 0, CHINESE );
			draw_button( 0, 48, "设置", 1, CHINESE );
		}
			break;
		}

		print_ch_str( 36, 12, "流量", 0 );
		print_ch_str( USED_X, USED_Y, "已采样", 0 );    // 显示已采样字样
	}

	show_time(1);

    systems.dynamic_flow = 0;
	flow_show( (unsigned int)( systems.dynamic_flow ) );    // 动态流量显示
	percent_show( systems.percent );
    
    if ( TIMING == systems.cyls.tim_vol_status )
    {
        putchar( USED_X+66, USED_Y, ':', 0 );    // 显示已采样时间字样的分与秒之间的 ：
        used_time_show( systems.used_time, systems.start_sec );  // 已用时显示
    }
    else
    {
        putchar( USED_X+80, USED_Y, 'L', 0 );      // 显示已采样体积的体积符号 L
        used_volume_show( systems.dynamic_volume );  // 已用时显示
    }
    
	batShow(1);    //显示电池图标
}

void topCylMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
		{
			lp->status1 = 2;
			draw_button( 0, 12, "S", 0, ENGLISH );
			draw_button( 0, 48, "Set", 1, ENGLISH );
		}
			break;
		case 1:
		{
			lp->status1 = 0;
			draw_button( 0, 12, "S", 1, ENGLISH );
			draw_button( 0, 30, "View", 0, ENGLISH );
		}
			break;
		case 2:
		{
			lp->status1 = 1;
			draw_button( 0, 30, "View", 1, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
		}
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
		{
			lp->status1 = 2;
			draw_button( 0, 12, "启动", 0, CHINESE );
			draw_button( 0, 48, "设置", 1, CHINESE );
		}
			break;
		case 1:
		{
			lp->status1 = 0;
			draw_button( 0, 12, "启动", 1, CHINESE );
			draw_button( 0, 30, "查看", 0, CHINESE );
		}
			break;
		case 2:
		{
			lp->status1 = 1;
			draw_button( 0, 30, "查看", 1, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
		}
			break;
		default: break;
		}
	}
}

void topCylMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
		{
			lp->status1 = 1;
			draw_button( 0, 12, "S", 0, ENGLISH );
			draw_button( 0, 30, "View", 1, ENGLISH );
		}
			break;
		case 1:
		{
			lp->status1 = 2;
			draw_button( 0, 30, "View", 0, ENGLISH );
			draw_button( 0, 48, "Set", 1, ENGLISH );
		}
			break;
		case 2:
		{
			lp->status1 = 0;
			draw_button( 0, 12, "S", 1, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
		}
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
		{
			lp->status1 = 1;
			draw_button( 0, 12, "启动", 0, CHINESE );
			draw_button( 0, 30, "查看", 1, CHINESE );
		}
			break;
		case 1:
		{
			lp->status1 = 2;
			draw_button( 0, 30, "查看", 0, CHINESE );
			draw_button( 0, 48, "设置", 1, CHINESE );
		}
			break;
		case 2:
		{
			lp->status1 = 0;
			draw_button( 0, 12, "启动", 1, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
		}
			break;
		default: break;
		}
	}
}

void topCylMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;

	switch ( lp->status1 )
	{
	case 0:
		if ( lp->subMenu )
		{
			systems.used_time = 0;
			systems.start_sec = 0;
			systems.percent = 0;

			systems.status = SAMPLING;
			systems.presure = getPFromFlow( systems.cyls.flow );
            
            startPump( systems.cyls.flow );
            
			win->curfous = lp->subMenu;
			win->curfous->show();		// 进入启动菜单
		}
		break;

	case 1:
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu->rMenu;
			win->curfous->show();		// 进入采样时长设置菜单
		}
		break;

	case 2:
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu->rMenu->rMenu;
			win->curfous->show();		// 进入各种设置菜单
		}
		break;

	default: break;
	}
}

void topCylMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void topCylMenuExec(void)
{
	show_time(0);
    
    batShow( 0 );
}






/*
 * 启动采样菜单
 */
void manuStartMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
    win->mLevel = 2;
    
	clr_lcd();
	show_time(1);
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( STAT_X, STAT_Y, 12, 12, status_icn[systems.status], 0 );
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	print_str( USED_X+36, USED_Y, ":    ", 0 );     // 显示已采样时间min字样
	draw_rect( PERC_X, PERC_Y+1, 62, 10 );            // 画一个进度条

	print_int( 112, 36, 0, 0 );		// 打印百分比

	print_str( 100, 36, "   %", 0 );        // 显示%字样
	print_str( FLOW_X+24, FLOW_Y, ":    mL/min", 0 );  // 显示mL/min字样

	if ( ENGLISH == systems.language )
	{
		print_str( MOD_X, MOD_Y, "MANU", 0 );
		print_str( 36, 12, "FLOW", 0 );
		print_str( USED_X, USED_Y, "SMPTim", 0 );    // 显示已采样字样
		switch ( lp->status1 )
		{
		case 0:
			draw_button( 0, 12, "Stop", 1, ENGLISH );  // 描当前菜单的英文按钮
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "Time", 0, ENGLISH );
            }
            else
            {
			    draw_button( 0, 30, "V", 0, ENGLISH );
            }
			draw_button( 0, 48, "Set", 0, ENGLISH );
			break;
		case 1:
			draw_button( 0, 12, "Stop", 0, ENGLISH );  // 描当前菜单的英文按钮
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "Time", 1, ENGLISH );
            }
            else
            {
			    draw_button( 0, 30, "V", 1, ENGLISH );
            }
			draw_button( 0, 48, "Set", 0, ENGLISH );
			break;
		case 2:
			draw_button( 0, 12, "Stop", 0, ENGLISH );  // 描当前菜单的英文按钮
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "Time", 0, ENGLISH );
            }
            else
            {
			    draw_button( 0, 30, "V", 0, ENGLISH );
            }
			draw_button( 0, 48, "Set", 1, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		print_ch_str( MOD_X, MOD_Y, "手动", 0 );
		print_ch_str( 36, 12, "流量", 0 );
		print_ch_str( USED_X, USED_Y, "已采样", 0 );    // 显示已采样字样
		switch ( lp->status1 )
		{
		case 0:
			draw_button( 0, 12, "停止", 1, CHINESE );   // 描一个中文按钮
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "时长", 0, CHINESE );
            }
            else
            {
			    draw_button( 0, 30, "定容", 0, CHINESE );
            }
			draw_button( 0, 48, "设置", 0, CHINESE );
			break;
		case 1:
			draw_button( 0, 12, "停止", 0, CHINESE );   // 描一个中文按钮
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "时长", 1, CHINESE );
            }
            else
            {
			    draw_button( 0, 30, "定容", 1, CHINESE );
            }
			draw_button( 0, 48, "设置", 0, CHINESE );
			break;
		case 2:
			draw_button( 0, 12, "停止", 0, CHINESE );   // 描一个中文按钮
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "时长", 0, CHINESE );
            }
            else
            {
			    draw_button( 0, 30, "定容", 0, CHINESE );
            }
			draw_button( 0, 48, "设置", 1, CHINESE );
			break;
		default: break;
		}
	}
    
    
    print_str( 38, 50, "F:", 0 );
    draw_symbol( 50, 50, 9, 12, jian_mu, 0 );
    draw_symbol( 85, 50, 9, 12, plus_mu, 0 );
    if ( systems.manu.flow >= 1000 )
    {
        print_int( 60, 50, systems.manu.flow, 0 );
    }
    else if ( systems.manu.flow >= 100 )
    {
         print_int( 63, 50, systems.manu.flow, 0 );
    }
    else if ( systems.manu.flow > 10 )
    {
         print_int( 66, 50, systems.manu.flow, 0 );
    }

	flow_show( (unsigned int)( systems.dynamic_flow ) );    // 动态流量显示
	percent_show( systems.percent );
    
    if ( TIMING == systems.manu.tim_vol_status )
    {
        putchar( USED_X+66, USED_Y, ':', 0 );    // 显示已采样时间字样的分与秒之间的 ：
        used_time_show( systems.used_time, systems.start_sec );  // 已用时显示
    }
    else
    {
        putchar( USED_X+80, USED_Y, 'L', 0 );      // 显示已采样体积的体积符号 L
        used_volume_show( systems.dynamic_volume );  // 已用时显示
    }
    
	batShow(1);    // 显示电池图标
}


void manuStartMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 2;
			draw_button( 0, 12, "Stop", 0, ENGLISH );
			draw_button( 0, 48, "Set", 1, ENGLISH );
			break;
            
		case 1:
			lp->status1 = 0;
			draw_button( 0, 12, "Stop", 1, ENGLISH );
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "Time", 0, ENGLISH );
            }
            else
            {
			    draw_button( 0, 30, "V", 0, ENGLISH );
            }
			break;
            
		case 2:
			lp->status1 = 1;
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "Time", 1, ENGLISH );
            }
            else
            {
			    draw_button( 0, 30, "V", 1, ENGLISH );
            }
			draw_button( 0, 48, "Set", 0, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 2;
			draw_button( 0, 12, "停止", 0, CHINESE );
			draw_button( 0, 48, "设置", 1, CHINESE );
			break;
            
		case 1:
			lp->status1 = 0;
			draw_button( 0, 12, "停止", 1, CHINESE );
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "时长", 0, CHINESE );
            }
            else
            {
			    draw_button( 0, 30, "定容", 0, CHINESE );
            }
			break;
            
		case 2:
			lp->status1 = 1;
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "时长", 1, CHINESE );
            }
            else
            {
			    draw_button( 0, 30, "定容", 1, CHINESE );
            }
			draw_button( 0, 48, "设置", 0, CHINESE );
			break;
		default: break;
		}
	}
}

void manuStartMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			draw_button( 0, 12, "Stop", 0, ENGLISH );
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "Time", 1, ENGLISH );
            }
            else
            {
			    draw_button( 0, 30, "V", 1, ENGLISH );
            }
			break;
            
		case 1:
			lp->status1 = 2;
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "Time", 0, ENGLISH );
            }
            else
            {
			    draw_button( 0, 30, "V", 0, ENGLISH );
            }
			draw_button( 0, 48, "Set", 1, ENGLISH );
			break;
            
		case 2:
			lp->status1 = 0;
			draw_button( 0, 12, "Stop", 1, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			draw_button( 0, 12, "停止", 0, CHINESE );
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "时长", 1, CHINESE );
            }
            else
            {
			    draw_button( 0, 30, "定容", 1, CHINESE );
            }
			break;
		case 1:
			lp->status1 = 2;
            if ( TIMING == systems.manu.tim_vol_status )
            {
			    draw_button( 0, 30, "时长", 0, CHINESE );
            }
            else
            {
			    draw_button( 0, 30, "定容", 0, CHINESE );
            }
			draw_button( 0, 48, "设置", 1, CHINESE );
			break;
            
		case 2:
			lp->status1 = 0;
			draw_button( 0, 12, "停止", 1, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
			break;
		default: break;
		}
	}
}

void manuStartMenuOnLeft(void)
{

	if ( systems.manu.flow > MIN_FLOW )
    {
        systems.manu.flow -= MID_FLOW;
        changeFlow( systems.manu.flow );
    }
    else
    {
        systems.manu.flow = MAX_FLOW;
        changeFlow( systems.manu.flow );
    }

    clr_rect( 60, 50, 24, 12 );
    if ( systems.manu.flow >= 1000 )
    {
        print_int( 60, 50, systems.manu.flow, 0 );
    }
    else if ( systems.manu.flow >= 100 )
    {
        print_int( 63, 50, systems.manu.flow, 0 );
    }
    else if ( systems.manu.flow >= 10 )
    {
        print_int( 66, 50, systems.manu.flow, 0 );
    }
}

void manuStartMenuOnRight(void)
{
    if ( systems.manu.flow < MAX_FLOW )
    {
        systems.manu.flow += MID_FLOW;
        changeFlow( systems.manu.flow );
    }
    else
    {
        systems.manu.flow = MIN_FLOW;
        changeFlow( systems.manu.flow );
    }

    clr_rect( 60, 50, 24, 12 );
    if ( systems.manu.flow >= 1000 )
    {
        print_int( 60, 50, systems.manu.flow, 0 );
    }
    else if ( systems.manu.flow >= 100 )
    {
        print_int( 63, 50, systems.manu.flow, 0 );
    }
    else if ( systems.manu.flow >= 10 )
    {
        print_int( 66, 50, systems.manu.flow, 0 );
    }
}

void manuStartMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;

    switch ( lp->status1 )
    {
    case 0:
        if ( lp->subMenu )
        {
            win->curfous = lp->subMenu;
            win->curfous->show();
        }
        break;

    case 1:
        if ( lp->subMenu )
        {
            win->curfous = lp->subMenu->rMenu;
            win->curfous->show();
        }
        break;

    case 2:
        if ( lp->subMenu )
        {
            win->curfous = lp->subMenu->rMenu->rMenu;
            win->curfous->show();
        }
        break;

    default: break;
    }

}


void manuStartMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if ( lp->topMenu )
	{
		lp->status1 = 0;
		systems.status = STOP;
		systems.percent = 0;
		systems.used_time = 0;
		systems.dynamic_flow = 0;
		systems.start_min = 0;
		systems.start_sec = 0;

        stopPump();
        systems.dynamic_flow = 0;
        systems.dynamic_volume = 0;
        
		win->curfous = lp->topMenu;
		lp = win->curfous;
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
}

void manuStartMenuExec(void)
{
	static unsigned char old_status = 0;  // 旧的系统当前状态
	static unsigned int old_flow = 0;  // 旧的流量
	static unsigned int old_used_time = 0;  // 旧的已经采样时间
	static unsigned int old_start_sec = 0;  // 旧的开始采样时间
	static double old_percent = 0;  // 旧的采样进度条
    
	if ( systems.status == SAMPLING )    // 当前工作状态为正在采样
	{
		if ( old_flow != systems.dynamic_flow )
		{
			old_flow = (unsigned int)systems.dynamic_flow;
			flow_show( old_flow );	// 显示动态流量
		}

		if ( old_used_time != systems.used_time
				|| old_start_sec != systems.start_sec )
		{
			old_used_time = systems.used_time;
			old_start_sec = systems.start_sec;
            if ( TIMING == systems.manu.tim_vol_status )
            {
                used_time_show( systems.used_time, systems.start_sec );  // 已用时显示
            }
            else
            {
                used_volume_show( systems.dynamic_volume );  // 已用时显示
            }    
		}

		if ( old_percent != systems.percent )
		{
			old_percent = systems.percent;
			percent_show( old_percent );  // 显示旧的进度条，进度百分比
		}

		show_time(0);
	}

	if ( old_status != systems.status )
	{
		old_status = systems.status;
		status_show( old_status );
	}
    
    batShow( 0 );
}

/*
 * 手动模式停止警告菜单
 */
void MwarnStopMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
    win->mLevel = 3;
	clr_lcd();
	draw_rect( 0, 0, 128, 64 );
	draw_line( 15, 15, 112, 15 );

	if ( ENGLISH == systems.language )
	{
		print_str( 40, 3, "Warning !", 0 );
		print_str( 8, 18, "Incomplete sampling", 0 );
		print_str( 2, 32, "Do you want to Stop?", 0 );
		switch ( lp->status1 )
		{
		case 0:
			draw_button( 15, 45, "Ok", 1, ENGLISH );
			draw_button( 80, 45, "Esc", 0, ENGLISH );
			break;
		case 1:
			draw_button( 15, 45, "Ok", 0, ENGLISH );
			draw_button( 80, 45, "Esc", 1, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		print_ch_str( 40, 3, "警告", 0 );
		putchar( 70, 3, '!', 0 );
		print_ch_str( 26, 18, "还未完成采样", 0 );
		print_ch_str( 20, 32, "是否停止采样", 0 );
		switch ( lp->status1 )
		{
		case 0:
			draw_button( 15, 45, "确定", 1, CHINESE );
			draw_button( 80, 45, "取消", 0, CHINESE );
			break;
		case 1:
			draw_button( 15, 45, "确定", 0, CHINESE );
			draw_button( 80, 45, "取消", 1, CHINESE );
			break;
		default: break;
		}
	}
}

void MwarnStopMenuOnLeft(void)
{
	struct MENU *lp;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		lp->status1 = 1;
		if ( ENGLISH == systems.language )
		{
			draw_button( 15, 45, "Ok", 0, ENGLISH );
			draw_button( 80, 45, "Esc", 1, ENGLISH );
		}
		else
		{
			draw_button( 15, 45, "确定", 0, CHINESE );
			draw_button( 80, 45, "取消", 1, CHINESE );
		}
		break;
	case 1:
		lp->status1 = 0;
		if ( ENGLISH == systems.language )
		{
			draw_button( 15, 45, "Ok", 1, ENGLISH );
			draw_button( 80, 45, "Esc", 0, ENGLISH );
		}
		else
		{
			draw_button( 15, 45, "确定", 1, CHINESE );
			draw_button( 80, 45, "取消", 0, CHINESE );
		}
		break;
	default: break;
	}
}

void MwarnStopMenuOnRight(void)
{
	struct MENU *lp;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		lp->status1 = 1;
		if ( ENGLISH == systems.language )
		{
			draw_button( 15, 45, "Ok", 0, ENGLISH );
			draw_button( 80, 45, "Esc", 1, ENGLISH );
		}
		else
		{
			draw_button( 15, 45, "确定", 0, CHINESE );
			draw_button( 80, 45, "取消", 1, CHINESE );
		}
		break;
	case 1:
		lp->status1 = 0;
		if ( ENGLISH == systems.language )
		{
			draw_button( 15, 45, "Ok", 1, ENGLISH );
			draw_button( 80, 45, "Esc", 0, ENGLISH );
		}
		else
		{
			draw_button( 15, 45, "确定", 1, CHINESE );
			draw_button( 80, 45, "取消", 0, CHINESE );
		}
		break;
	default: break;
	}
}

void MwarnStopMenuOnOk(void)
{
	struct MENU *lp;
	struct MENU *top_lp;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		systems.status = STOP;        //进入停止状态
		systems.used_time = 0;
		systems.start_sec = 0;
		systems.percent = 0;
        
        stopPump();
        systems.dynamic_flow = 0;
        systems.dynamic_volume = 0;
        
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			top_lp = win->curfous;
			if ( top_lp->topMenu )
			{
				win->curfous = top_lp->topMenu;
				win->curfous->show();
			}
		}
		break;
	case 1:
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
		break;
	default: break;
	}
}

void MwarnStopMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	systems.status = STOP;        //进入停止状态
	systems.used_time = 0;
	systems.start_sec = 0;
	systems.percent = 0;
    
    stopPump();
    systems.dynamic_flow = 0;
    
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		lp = win->curfous;
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
}



/*
 * 定时模式启动采样菜单
 */
void timeStartMenuShow(void)
{
	struct MENU *lp;
	unsigned int index_group;
	unsigned int flag = 0;	// 标志是否有组已经启用,0表示没有组启用，1表示有组启用
	lp = win->curfous;
    win->mLevel = 2;
	clr_lcd();

	for ( index_group = 0; index_group < GROUP_NUM; index_group++ )
	{
		if ( 1 == systems.groups[index_group].srb )
		{
			flag = 1;	// 已有组启用
			break;
		}
	}

	if ( 0 == flag )
	{
        systems.status = STOP;
        win->twoOldCurfous = win->curfous;
        win->curfous = win->twoErrMenu;
        win->curfous->show();
        /*
		draw_rect( 0, 0, 128, 64 );
		draw_line( 15, 15, 112, 15 );
		if ( ENGLISH == systems.language )
		{
			print_str( 40, 3, "Warning !", 0 );
			print_str( 20, 18, "No Group is ON !", 0 );
			print_str( 10, 33, "Please set a Group!", 0 );
			draw_button( 93, 46, "Exit", 1, ENGLISH );
		}
		else
		{
			print_ch_str( 52, 3, "警告", 0 );
			putchar( 82, 3, '!', 0 );
			print_ch_str( 20, 18, "无定时组被启用", 0 );
			putchar( 110, 18, '!', 0 );
			print_ch_str( 22, 33, "请设置一个组", 0 );
			draw_button( 93, 46, "退出", 1, CHINESE );
		}
        */
	}
	else
	{
		show_time(1);
		print_str( 2, 0, "AMAE", 0 );
		draw_symbol( STAT_X, STAT_Y, 12, 12, status_icn[systems.status], 0 );
		draw_line( 33, 12, 33, 63 );		// 打印一条竖线
		print_str( USED_X+36, USED_Y, ":    :", 0 );     // 显示已采样时间min字样
		draw_rect( PERC_X, PERC_Y+1, 62, 10 );            // 画一个进度条

		print_int( 112, 36, 0, 0 );		// 打印百分比

		print_str( 100, 36, "   %", 0 );        // 显示%字样
		print_str( FLOW_X+24, FLOW_Y, ":    mL/min", 0 );  // 显示mL/min字样

		if ( ENGLISH == systems.language )
		{
			print_str( MOD_X, MOD_Y, "TIM", 0 );
			print_str( 36, 12, "FLOW", 0 );
			print_str( USED_X, USED_Y, "SMPTim", 0 );    // 显示已采样字样
			switch ( lp->status1 )
			{
			case 0:
				draw_button( 0, 12, "Stop", 1, ENGLISH );  // 描当前菜单的英文按钮
				draw_button( 0, 30, "View", 0, ENGLISH );
				draw_button( 0, 48, "Set", 0, ENGLISH );
				break;
			case 1:
				draw_button( 0, 12, "Stop", 0, ENGLISH );  // 描当前菜单的英文按钮
				draw_button( 0, 30, "View", 1, ENGLISH );
				draw_button( 0, 48, "Set", 0, ENGLISH );
				break;
			case 2:
				draw_button( 0, 12, "Stop", 0, ENGLISH );  // 描当前菜单的英文按钮
				draw_button( 0, 30, "View", 0, ENGLISH );
				draw_button( 0, 48, "Set", 1, ENGLISH );
				break;
			default: break;
			}
		}
		else
		{
			print_ch_str( MOD_X, MOD_Y, "定时", 0 );
			print_ch_str( 36, 12, "流量", 0 );
			print_ch_str( USED_X, USED_Y, "已采样", 0 );    // 显示已采样字样
			switch ( lp->status1 )
			{
			case 0:
				draw_button( 0, 12, "停止", 1, CHINESE );   // 描一个中文按钮
				draw_button( 0, 30, "查看", 0, CHINESE );
				draw_button( 0, 48, "设置", 0, CHINESE );
				break;
			case 1:
				draw_button( 0, 12, "停止", 0, CHINESE );   // 描一个中文按钮
				draw_button( 0, 30, "查看", 1, CHINESE );
				draw_button( 0, 48, "设置", 0, CHINESE );
				break;
			case 2:
				draw_button( 0, 12, "停止", 0, CHINESE );   // 描一个中文按钮
				draw_button( 0, 30, "查看", 0, CHINESE );
				draw_button( 0, 48, "设置", 1, CHINESE );
				break;
			default: break;
			}
		}

		flow_show( (unsigned int)( systems.dynamic_flow ) );    // 动态流量显示
		percent_show( systems.percent );
		used_time_show( systems.used_time, systems.start_sec );  // 已用时显示
		percent_show( systems.percent);
		batShow(1);    // 显示电池图标
	}
}

void timeStartMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
		{
			lp->status1 = 2;
			draw_button( 0, 12, "Stop", 0, ENGLISH );
			draw_button( 0, 48, "Set", 1, ENGLISH );
		}
			break;
		case 1:
		{
			lp->status1 = 0;
			draw_button( 0, 12, "Stop", 1, ENGLISH );
			draw_button( 0, 30, "View", 0, ENGLISH );
		}
			break;
		case 2:
		{
			lp->status1 = 1;
			draw_button( 0, 30, "View", 1, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
		}
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
		{
			lp->status1 = 2;
			draw_button( 0, 12, "停止", 0, CHINESE );
			draw_button( 0, 48, "设置", 1, CHINESE );
		}
			break;
		case 1:
		{
			lp->status1 = 0;
			draw_button( 0, 12, "停止", 1, CHINESE );
			draw_button( 0, 30, "查看", 0, CHINESE );
		}
			break;
		case 2:
		{
			lp->status1 = 1;
			draw_button( 0, 30, "查看", 1, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
		}
			break;
		default: break;
		}
	}
}

void timeStartMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
		{
			lp->status1 = 1;
			draw_button( 0, 12, "Stop", 0, ENGLISH );
			draw_button( 0, 30, "View", 1, ENGLISH );
		}
			break;
		case 1:
		{
			lp->status1 = 2;
			draw_button( 0, 30, "View", 0, ENGLISH );
			draw_button( 0, 48, "Set", 1, ENGLISH );
		}
			break;
		case 2:
		{
			lp->status1 = 0;
			draw_button( 0, 12, "Stop", 1, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
		}
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
		{
			lp->status1 = 1;
			draw_button( 0, 12, "停止", 0, CHINESE );
			draw_button( 0, 30, "查看", 1, CHINESE );
		}
			break;
		case 1:
		{
			lp->status1 = 2;
			draw_button( 0, 30, "查看", 0, CHINESE );
			draw_button( 0, 48, "设置", 1, CHINESE );
		}
			break;
		case 2:
		{
			lp->status1 = 0;
			draw_button( 0, 12, "停止", 1, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
		}
			break;
		default: break;
		}
	}
}

void timeStartMenuOnLeft(void)
{
    
}

void timeStartMenuOnRight(void)
{
}

void timeStartMenuOnOk(void)
{
	struct MENU *lp;
	unsigned int index_group;
	unsigned int flag = 0;	// 标志是否有组已经启用,0表示没有组启用，1表示有组启用
	lp = win->curfous;

    for ( index_group = 0; index_group < GROUP_NUM; index_group++ )
    {
        if ( 1 == systems.groups[index_group].srb )
        {
            flag = 1;	// 已有组启用
            break;
        }
    }
    if ( 1 == flag )	// 有组被启用
    {
        switch ( lp->status1 )
        {
        case 0:
            if ( lp->subMenu )
            {
                systems.status = WAITING;
                win->curfous = lp->subMenu;
                win->curfous->show();
            }
            break;

        case 1:
            if ( lp->subMenu )
            {
                win->curfous = lp->subMenu->rMenu;
                win->curfous->show();
            }
            break;

        case 2:
            if ( lp->subMenu )
            {
                win->curfous = lp->subMenu->rMenu->rMenu;
                win->curfous->show();
            }
            break;

        default: break;
        }
	}
}

void timeStartMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if ( lp->topMenu )
	{
		lp->status1 = 0;
		systems.status = STOP;
		systems.percent = 0;
		systems.used_time = 0;
		systems.dynamic_flow = 0;
		systems.start_min = 0;
		systems.start_sec = 0;

        stopPump();
        systems.dynamic_flow = 0;
        
		win->curfous = lp->topMenu;
		lp = win->curfous;
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
    
}

void timeStartMenuExec(void)
{
	static unsigned int old_dynamic_flow = 0;
	static unsigned int old_used_time = 0;
	static unsigned int old_sec = 0;    // 旧的秒
    static unsigned int sec = 0;
	static unsigned int old_start_sec = 0;   // 旧的已采样时间的秒
	static unsigned int old_status = 0;
	static double old_percent = 0;

	unsigned int index;

	switch( systems.status )        // 判断当前系统的工作状态
	{
	case STOP:
		for ( index=0; index<10; index++ )
		{
			if ( systems.groups[index].srb )
			{
				systems.status = WAITING;
				break;
			}
		}
		break;
    case COMPLETE:
		if ( old_sec != systems.sys_time.sec )
		{
			old_sec = systems.sys_time.sec;
		}
    	break;

	case SAMPLING:
		show_time(0);
		break;

	case WAITING:
		show_time(0);
		break;

	default: break;
	}

	if ( old_status != systems.status )
	{
		old_status = systems.status;
		status_show( old_status );	// 更新状态显示
	}

    
	if ( old_dynamic_flow != systems.dynamic_flow )
	{
		old_dynamic_flow = (unsigned int)systems.dynamic_flow;
		flow_show( old_dynamic_flow );	// 更新动态流量显示
	}

	if ( old_used_time != systems.used_time
			|| old_start_sec != systems.start_sec )
	{
		old_used_time = systems.used_time;
		old_start_sec = systems.start_sec;
		used_time_show( old_used_time, old_start_sec );	// 更新已采样时长显示
	}

	if ( old_percent != systems.percent )
	{
		old_percent = systems.percent;
		percent_show( old_percent );	// 更新进度条显示
	}
   
    if ( sec != systems.sys_time.sec )
    {
        sec = systems.sys_time.sec;
        groupMoveFont();

    }
    
    batShow( 0 );
}


/*
 * 定时模式停止警告菜单
 */
void TwarnStopMenuShow(void)
{
	struct MENU *lp;
	unsigned index, groups;
	lp = win->curfous;
    win->mLevel = 3;
	clr_lcd();
	draw_rect( 0, 0, 128, 64 );
	draw_line( 15, 15, 112, 15 );

	if ( systems.status != STOP )
	{
		switch ( systems.language )      //判断当前系统语言
		{
		case ENGLISH:
			print_str( 40, 3, "Warning !", 0 );
			groups = 0;
			for ( index = 0; index < 10; index++ )       //找出还有几组未采样
			{
				if ( systems.groups[index].srb
						&& !( systems.group_status & ( 0x00000002 << ( index*2 ))))
				{
					groups++;
				}
			}
			print_int( 2, 18, groups, 0 );
			print_str( 14, 18, "groups no Sampling", 0 );
			print_str( 2, 32, "Do you want to Stop?", 0 );
			switch ( lp->status1 )
			{
			case 0:
				draw_button( 20, 46, "Ok", 1, ENGLISH );
				draw_button( 75, 46, "Esc", 0, ENGLISH );
				break;
			case 1:
				draw_button( 20, 46, "Ok", 0, ENGLISH );
				draw_button( 75, 46, "Esc", 1, ENGLISH );
				break;
			default:break;
			}
			break;
		case CHINESE:
			print_ch_str( 52, 3, "警告", 0 );
			putchar( 82, 3, '!', 0 );
			groups = 0;
			for ( index = 0; index < 10; index++ )       //找出还有几组未采样
			{
				if ( systems.groups[index].srb
						&& !( systems.group_status & ( 0x00000002 << ( index*2 ))))
				{
					groups++;
				}
			}
			print_int( 34, 18, groups, 0 );
			print_ch_str( 22, 18, "有", 0 );
			print_ch_str( 46, 18, "组未采样", 0 );
			putchar( 100, 18, '!', 0 );
			print_ch_str( 30, 33, "是否停止采样", 0 );
			putchar( 108, 33, '?', 0 );
			switch ( lp->status1 )
			{
			case 0:
				draw_button( 20, 46, "确定", 1, CHINESE );
				draw_button( 75, 46, "取消", 0, CHINESE );
				break;
			case 1:
				draw_button( 20, 46, "确定", 0, CHINESE );
				draw_button( 75, 46, "取消", 1, CHINESE );
				break;
			default:break;
			}
			break;
		default: break;
		}
	}
}

void TwarnStopMenuOnLeft(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
            draw_button( 20, 46, "Ok", 0, ENGLISH );
            draw_button( 75, 46, "Esc", 1, ENGLISH );
			break;
		case 1:
			lp->status1 = 0;
            draw_button( 20, 46, "Ok", 1, ENGLISH );
            draw_button( 75, 46, "Esc", 0, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
            draw_button( 20, 46, "确定", 0, CHINESE );
            draw_button( 75, 46, "取消", 1, CHINESE );
			break;
		case 1:
			lp->status1 = 0;
            draw_button( 20, 46, "确定", 1, CHINESE );
            draw_button( 75, 46, "取消", 0, CHINESE );
			break;
		default: break;
		}
	}
}

void TwarnStopMenuOnRight(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
            draw_button( 20, 46, "Ok", 0, ENGLISH );
            draw_button( 75, 46, "Esc", 1, ENGLISH );
			break;
		case 1:
			lp->status1 = 0;
            draw_button( 20, 46, "Ok", 1, ENGLISH );
            draw_button( 75, 46, "Esc", 0, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
            draw_button( 20, 46, "确定", 0, CHINESE );
            draw_button( 75, 46, "取消", 1, CHINESE );
			break;
		case 1:
			lp->status1 = 0;
            draw_button( 20, 46, "确定", 1, CHINESE );
            draw_button( 75, 46, "取消", 0, CHINESE );
			break;
		default: break;
		}
	}
}

void TwarnStopMenuOnOk(void)
{
	struct MENU *lp;
	struct MENU *top_lp;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		systems.status = STOP;        //进入停止状态
		systems.used_time = 0;
		systems.start_sec = 0;
		systems.percent = 0;
        
        stopPump();
        systems.dynamic_flow = 0;
        
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			top_lp = win->curfous;
			if ( top_lp->topMenu )
			{
				win->curfous = top_lp->topMenu;
				win->curfous->show();
			}
		}
		break;
	case 1:
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
		break;
	default: break;
	}
}

void TwarnStopMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	systems.status = STOP;        //进入停止状态
	systems.used_time = 0;
	systems.start_sec = 0;
	systems.percent = 0;
    
    stopPump();
    systems.dynamic_flow = 0;
    
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		lp = win->curfous;
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
}


/*
 * 循环模式启动采样菜单
 */
void cylStartMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
    win->mLevel = 2;
	clr_lcd();

	show_time(1);
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( STAT_X, STAT_Y, 12, 12, status_icn[systems.status], 0 );
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	print_str( USED_X+36, USED_Y, ":    ", 0 );     // 显示已采样时间min字样
	draw_rect( PERC_X, PERC_Y+1, 62, 10 );            // 画一个进度条

	print_int( 112, 36, 0, 0 );		// 打印百分比
	print_str( 100, 36, "   %", 0 );        // 显示%字样

	print_str( FLOW_X+24, FLOW_Y, ":    mL/min", 0 );  // 显示mL/min字样

	if ( ENGLISH == systems.language )
	{
		print_str( MOD_X, MOD_Y, "CYL", 0 );
		print_str( 36, 12, "FLOW", 0 );
		print_str( USED_X, USED_Y, "SMPTim", 0 );    // 显示已采样字样
		switch ( lp->status1 )
		{
		case 0:
			draw_button( 0, 12, "Stop", 1, ENGLISH );  // 描当前菜单的英文按钮
			draw_button( 0, 30, "View", 0, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
			break;
		case 1:
			draw_button( 0, 12, "Stop", 0, ENGLISH );  // 描当前菜单的英文按钮
			draw_button( 0, 30, "View", 1, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
			break;
		case 2:
			draw_button( 0, 12, "Stop", 0, ENGLISH );  // 描当前菜单的英文按钮
			draw_button( 0, 30, "View", 0, ENGLISH );
			draw_button( 0, 48, "Set", 1, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		print_ch_str( MOD_X, MOD_Y, "循环", 0 );
		print_ch_str( 36, 12, "流量", 0 );
		print_ch_str( USED_X, USED_Y, "已采样", 0 );    // 显示已采样字样
		switch ( lp->status1 )
		{
		case 0:
			draw_button( 0, 12, "停止", 1, CHINESE );   // 描一个中文按钮
			draw_button( 0, 30, "查看", 0, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
			break;
		case 1:
			draw_button( 0, 12, "停止", 0, CHINESE );   // 描一个中文按钮
			draw_button( 0, 30, "查看", 1, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
			break;
		case 2:
			draw_button( 0, 12, "停止", 0, CHINESE );   // 描一个中文按钮
			draw_button( 0, 30, "查看", 0, CHINESE );
			draw_button( 0, 48, "设置", 1, CHINESE );
			break;
		default: break;
		}
	}

	flow_show( (unsigned int)( systems.dynamic_flow ) );    // 动态流量显示
	percent_show( systems.percent );
    
    if ( TIMING == systems.cyls.tim_vol_status )
    {
        putchar( USED_X+66, USED_Y, ':', 0 );    // 显示已采样时间字样的分与秒之间的 ：
        used_time_show( systems.used_time, systems.start_sec );  // 已用时显示
    }
    else
    {
        putchar( USED_X+80, USED_Y, 'L', 0 );      // 显示已采样体积的体积符号 L
        used_volume_show( systems.dynamic_volume );  // 已用时显示
    }
    
	batShow(1);    // 显示电池图标

}

void cylStartMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 2;
			draw_button( 0, 12, "Stop", 0, ENGLISH );
			draw_button( 0, 48, "Set", 1, ENGLISH );
			break;
		case 1:
			lp->status1 = 0;
			draw_button( 0, 12, "Stop", 1, ENGLISH );
			draw_button( 0, 30, "View", 0, ENGLISH );
			break;
		case 2:
			lp->status1 = 1;
			draw_button( 0, 30, "View", 1, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 2;
			draw_button( 0, 12, "停止", 0, CHINESE );
			draw_button( 0, 48, "设置", 1, CHINESE );
			break;
		case 1:
			lp->status1 = 0;
			draw_button( 0, 12, "停止", 1, CHINESE );
			draw_button( 0, 30, "查看", 0, CHINESE );
			break;
		case 2:
			lp->status1 = 1;
			draw_button( 0, 30, "查看", 1, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
			break;
		default: break;
		}
	}
}

void cylStartMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			draw_button( 0, 12, "Stop", 0, ENGLISH );
			draw_button( 0, 30, "View", 1, ENGLISH );
			break;
		case 1:
			lp->status1 = 2;
			draw_button( 0, 30, "View", 0, ENGLISH );
			draw_button( 0, 48, "Set", 1, ENGLISH );
			break;
		case 2:
			lp->status1 = 0;
			draw_button( 0, 12, "Stop", 1, ENGLISH );
			draw_button( 0, 48, "Set", 0, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
		{
			lp->status1 = 1;
			draw_button( 0, 12, "停止", 0, CHINESE );
			draw_button( 0, 30, "查看", 1, CHINESE );
		}
			break;
		case 1:
		{
			lp->status1 = 2;
			draw_button( 0, 30, "查看", 0, CHINESE );
			draw_button( 0, 48, "设置", 1, CHINESE );
		}
			break;
		case 2:
		{
			lp->status1 = 0;
			draw_button( 0, 12, "停止", 1, CHINESE );
			draw_button( 0, 48, "设置", 0, CHINESE );
		}
			break;
		default: break;
		}
	}
}

void cylStartMenuOnLeft(void)
{
}

void cylStartMenuOnRight(void)
{
}

void cylStartMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;

    switch ( lp->status1 )
    {
    case 0:		// "停止"获得焦点
        if ( lp->subMenu )
        {
            win->curfous = lp->subMenu;
            win->curfous->show();
        }
        break;
    case 1:		// "查看"获得焦点
        if ( lp->subMenu )
        {
            win->curfous = lp->subMenu->rMenu;
            win->curfous->show();
        }
        break;
    case 2:		// "设置"获得焦点
        if ( lp->subMenu )
        {
            win->curfous = lp->subMenu->rMenu->rMenu;
            win->curfous->show();
        }
        break;
    default: break;
    }

}

void cylStartMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		systems.status = STOP;
		systems.percent = 0;
		systems.used_time = 0;
		systems.start_min = 0;
		systems.start_sec = 0;
        
        stopPump();
        systems.dynamic_flow = 0;
        systems.dynamic_volume = 0;

		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void cylStartMenuExec(void)
{
	static unsigned int old_dynamic_flow = 0;
	static unsigned int old_used_time = 0;
	static unsigned int old_start_sec = 0;
	static unsigned int old_status = 0 ;
	static double old_percent = 0;
    static unsigned int old_sec = 0;

	if ( systems.status != COMPLETE )
	{
		show_time(0);
	}

    if ( old_status != systems.status )
	{
		old_status = systems.status;
		status_show( old_status );	// 更新状态显示
	}

    
	if ( old_dynamic_flow != systems.dynamic_flow )
	{
		old_dynamic_flow = (unsigned int)systems.dynamic_flow;
		flow_show( old_dynamic_flow );	// 更新动态流量显示
	}

	if ( ( old_used_time != systems.used_time )
			|| old_start_sec != systems.start_sec )
	{
		old_used_time = systems.used_time;
		old_start_sec = systems.start_sec;
        if ( TIMING == systems.cyls.tim_vol_status )
        {
            used_time_show( systems.used_time, systems.start_sec );  // 已用时显示
        }
        else
        {
            used_volume_show( systems.dynamic_volume );  // 已用时显示
        }    
	}

	if ( old_percent != systems.percent )
	{
		old_percent = systems.percent;
		percent_show( old_percent );	// 更新进度条显示
	}

    if ( old_sec != systems.sys_time.sec )
    {
        old_sec = systems.sys_time.sec;
        cylsMoveFont();
    }
    
    batShow( 0 );
}

/*
 * 循环模式停止警告菜单
 */
void CwarnStopMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
    win->mLevel = 3;
	clr_lcd();
	draw_rect( 0, 0, 128, 64 );
	draw_line( 15, 15, 112, 15 );

	if ( systems.status != STOP )
	{
		if ( ENGLISH == systems.language )    // 判断当前语言状态
		{
			print_str( 40, 3, "Warning !", 0 );

			print_str( 14, 18, "cyls are't Sampled", 0 );

			// 显示还有多少次没有采样
			print_int( 2, 18, ( systems.cyls.cyl_num - systems.cur_cyls ), 0 );
			print_str( 2, 32, "Do you want to Stop?", 0 );

			switch( lp->status1 )       // 判断焦点所在位置
			{
			case 0:
				draw_button( 15, 45, "Ok", 1, ENGLISH );
				draw_button( 80, 45, "Esc", 0, ENGLISH );
				break;
			case 1:
				draw_button( 15, 45, "Ok", 0, ENGLISH );
				draw_button( 80, 45, "Esc", 1, ENGLISH );
				break;
			default: break;
			}
		}
		else
		{
			print_ch_str( 40, 3, "警告", 0 );
			putchar( 70, 3, '!', 0 );
			print_ch_str( 2, 18, "有", 0 );
			print_ch_str( 26, 18, "次循环未采样", 0 );

			// 显示还有多少次没有采样
			print_int( 14, 18, ( systems.cyls.cyl_num - systems.cur_cyls ), 0 );
			print_ch_str( 20, 32, "是否停止采样", 0 );
			putchar( 94, 32, '?', 0 );

			switch( lp->status1 )       // 判断焦点所在位置
			{
			case 0:
				draw_button( 15, 45, "确定", 1, CHINESE );
				draw_button( 80, 45, "取消", 0, CHINESE );
				break;
			case 1:
				draw_button( 15, 45, "确定", 0, CHINESE );
				draw_button( 80, 45, "取消", 1, CHINESE );
				break;
			default: break;
			}
		}
	}
}

void CwarnStopMenuOnLeft(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch( lp->status1 )       // 判断焦点所在位置
		{
		case 0:
			lp->status1 = 1;
			draw_button( 15, 45, "Ok", 0, ENGLISH );
			draw_button( 80, 45, "Esc", 1, ENGLISH );
			break;
		case 1:
			lp->status1 = 0;
			draw_button( 15, 45, "Ok", 1, ENGLISH );
			draw_button( 80, 45, "Esc", 0, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		switch( lp->status1 )       // 判断焦点所在位置
		{
		case 0:
			lp->status1 = 1;
			draw_button( 15, 45, "确定", 0, CHINESE );
			draw_button( 80, 45, "取消", 1, CHINESE );
			break;
		case 1:
			lp->status1 = 0;
			draw_button( 15, 45, "确定", 1, CHINESE );
			draw_button( 80, 45, "取消", 0, CHINESE );
			break;
		default: break;
		}
	}
}

void CwarnStopMenuOnRight(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch( lp->status1 )       // 判断焦点所在位置
		{
		case 0:
			lp->status1 = 1;
			draw_button( 15, 45, "Ok", 0, ENGLISH );
			draw_button( 80, 45, "Esc", 1, ENGLISH );
			break;
		case 1:
			lp->status1 = 0;
			draw_button( 15, 45, "Ok", 1, ENGLISH );
			draw_button( 80, 45, "Esc", 0, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		switch( lp->status1 )       // 判断焦点所在位置
		{
		case 0:
			lp->status1 = 1;
			draw_button( 15, 45, "确定", 0, CHINESE );
			draw_button( 80, 45, "取消", 1, CHINESE );
			break;
		case 1:
			lp->status1 = 0;
			draw_button( 15, 45, "确定", 1, CHINESE );
			draw_button( 80, 45, "取消", 0, CHINESE );
			break;
		default: break;
		}
	}
}

void CwarnStopMenuOnOk(void)
{
	struct MENU *lp;
	struct MENU *top_lp;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		systems.status = STOP;        //进入停止状态
		systems.used_time = 0;
		systems.start_sec = 0;
		systems.percent = 0;
        
        stopPump();
        systems.dynamic_flow = 0;
        systems.dynamic_volume = 0;
        
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			top_lp = win->curfous;
			if ( top_lp->topMenu )
			{
				win->curfous = top_lp->topMenu;
				win->curfous->show();
			}
		}
		break;
	case 1:
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
		break;
	default: break;
	}
}

void CwarnStopMenuOnEsc(void)
{
	struct MENU *lp;
	struct MENU *top_lp;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		systems.status = STOP;        //进入停止状态
		systems.used_time = 0;
		systems.start_sec = 0;
		systems.percent = 0;
        
        stopPump();
        systems.dynamic_flow = 0;
        
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			top_lp = win->curfous;
			if ( top_lp->topMenu )
			{
				win->curfous = top_lp->topMenu;
				win->curfous->show();
			}
		}
		break;
	case 1:
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
		break;
	default: break;
	}
}



/*
 * 手动模式采样时长设置菜单
 */
void smpTimeMenuShow(void)
{
	struct MENU *lp;
    unsigned int bai, shi, ge, shifen;
	lp = win->curfous;
    win->mLevel = 3;
	// 先获取已设好的默认值
	systems.a_hour = (int)( systems.manu.smp_time / 100 );
	systems.a_min = (int)( systems.manu.smp_time % 100 / 10 );
	systems.a_sec = (int)( systems.manu.smp_time % 10 );
    
    systems.a_volume = systems.manu.smp_volume;
    bai = (unsigned int)(systems.manu.smp_volume / 100 );
    shi = (unsigned int)(systems.manu.smp_volume) % 100 / 10 ;
    ge = (unsigned int)(systems.manu.smp_volume) % 10 ;
    shifen = (unsigned int)(systems.manu.smp_volume * 10 ) % 10 ;

	clr_lcd();
	draw_rect( 0, 0, 128, 64 );		 // 画外层矩形区
	draw_line( 12, 16, 115, 16 );
	draw_symbol( 28, 25, 12, 12, left_mu, 0 );	// 画左三角
	draw_rect( 42, 24, 41, 14 );	// 画内层矩形区

    if ( TIMING == systems.manu.tim_vol_status )
    {
        switch ( lp->status1 )
        {
        case 0:
            if ( ENGLISH == systems.language )
            {
                draw_rect( 12, 3, 12, 12 );
                print_str( 24, 3, "timing", 1 );
                draw_rect( 66, 3, 12, 12 );
                print_str( 78, 3, "ration", 0 );
                draw_button( 48, 46, "Ok", 0, ENGLISH );
            }
            else
            {
                draw_rect( 12, 3, 12, 12 );
                print_ch_str( 24, 3, "定时间", 1 );
                draw_rect( 66, 3, 12, 12 );
                print_ch_str( 78, 3, "定体积", 0 );
                draw_button( 48, 46, "确定", 0, CHINESE );
            }
            print_int( 45, 25, systems.a_hour, 0 );
            print_int( 53, 25, systems.a_min, 0 );
            print_int( 61, 25, systems.a_sec, 0 );
            break;
            
        case 1:
            if ( ENGLISH == systems.language )
            {
                draw_rect( 12, 3, 12, 12 );
                print_str( 24, 3, "timing", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_str( 78, 3, "ration", 1 );
                draw_button( 48, 46, "Ok", 0, ENGLISH );
            }
            else
            {
                draw_rect( 12, 3, 12, 12 );
                print_ch_str( 24, 3, "定时间", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_ch_str( 78, 3, "定体积", 1 );
                draw_button( 48, 46, "确定", 0, CHINESE );
            }
            print_int( 45, 25, systems.a_hour, 0 );
            print_int( 53, 25, systems.a_min, 0 );
            print_int( 61, 25, systems.a_sec, 0 );
            break;
            
        case 2:
            if ( ENGLISH == systems.language )
            {
                draw_rect( 12, 3, 12, 12 );
                print_str( 24, 3, "timing", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_str( 78, 3, "ration", 0 );
                draw_button( 48, 46, "Ok", 0, ENGLISH );
            }
            else
            {
                draw_rect( 12, 3, 12, 12 );
                print_ch_str( 24, 3, "定时间", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_ch_str( 78, 3, "定体积", 0 );
                draw_button( 48, 46, "确定", 0, CHINESE );
            }
            
            fill_rect( 44, 25, 8, 12 );
            print_int( 45, 25, systems.a_hour, 1 );
            print_int( 53, 25, systems.a_min, 0 );
            print_int( 61, 25, systems.a_sec, 0 );
            break;
            
        case 3:
            if ( ENGLISH == systems.language )
            {
                draw_rect( 12, 3, 12, 12 );
                print_str( 24, 3, "timing", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_str( 78, 3, "ration", 0 );
                draw_button( 48, 46, "Ok", 0, ENGLISH );
            }
            else
            {
                draw_rect( 12, 3, 12, 12 );
                print_ch_str( 24, 3, "定时间", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_ch_str( 78, 3, "定体积", 0 );
                draw_button( 48, 46, "确定", 0, CHINESE );
            }
            print_int( 45, 25, systems.a_hour, 0 );
            fill_rect( 52, 25, 8, 12 );
            print_int( 53, 25, systems.a_min, 1 );
            print_int( 61, 25, systems.a_sec, 0 );
            break;
            
        case 4:
            if ( ENGLISH == systems.language )
            {
                draw_rect( 12, 3, 12, 12 );
                print_str( 24, 3, "timing", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_str( 78, 3, "ration", 0 );
                draw_button( 48, 46, "Ok", 0, ENGLISH );
            }
            else
            {
                draw_rect( 12, 3, 12, 12 );
                print_ch_str( 24, 3, "定时间", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_ch_str( 78, 3, "定体积", 0 );
                draw_button( 48, 46, "确定", 0, CHINESE );
            }
            print_int( 45, 25, systems.a_hour, 0 );
            print_int( 53, 25, systems.a_min, 0 );
            fill_rect( 60, 25, 8, 12 );
            print_int( 61, 25, systems.a_sec, 1 );
            break;
            
        case 5:
            if ( ENGLISH == systems.language )
            {
                draw_rect( 12, 3, 12, 12 );
                print_str( 24, 3, "timing", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_str( 78, 3, "ration", 0 );
                draw_button( 48, 46, "Ok", 1, ENGLISH );
            }
            else
            {
                draw_rect( 12, 3, 12, 12 );
                print_ch_str( 24, 3, "定时间", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_ch_str( 78, 3, "定体积", 0 );
                draw_button( 48, 46, "确定", 1, CHINESE );
            }
            print_int( 45, 25, systems.a_hour, 0 );
            print_int( 53, 25, systems.a_min, 0 );
            print_int( 61, 25, systems.a_sec, 0 );
            break;
            
        default: break;
        }

        draw_symbol( 13, 4, 10, 10, gou_mu, 0 ); // 打钩
        
        draw_line( 69, 24, 69, 36 );	// 画内层矩形区内的竖线
        draw_symbol( 70, 25, 12, 12, up_down_mu, 0 );	// 画上下三角 
	    print_str( 100, 25, "min", 0 );
    }
    else
    {
        switch ( lp->status1 )
        {
        case 0:
            if ( ENGLISH == systems.language )
            {
                draw_rect( 12, 3, 12, 12 );
                print_str( 24, 3, "timing", 1 );
                draw_rect( 66, 3, 12, 12 );
                print_str( 78, 3, "ration", 0 );
                draw_button( 48, 46, "Ok", 0, ENGLISH );
            }
            else
            {
                draw_rect( 12, 3, 12, 12 );
                print_ch_str( 24, 3, "定时间", 1 );
                draw_rect( 66, 3, 12, 12 );
                print_ch_str( 78, 3, "定体积", 0 );
                draw_button( 48, 46, "确定", 0, CHINESE );
            }
            print_int( 45, 25, bai, 0 );
            print_int( 53, 25, shi, 0 );
            print_int( 61, 25, ge, 0 );
            print_int( 72, 25, shifen, 0 );
            break;
            
        case 1:
            if ( ENGLISH == systems.language )
            {
                draw_rect( 12, 3, 12, 12 );
                print_str( 24, 3, "timing", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_str( 78, 3, "ration", 1 );
                draw_button( 48, 46, "Ok", 0, ENGLISH );
            }
            else
            {
                draw_rect( 12, 3, 12, 12 );
                print_ch_str( 24, 3, "定时间", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_ch_str( 78, 3, "定体积", 1 );
                draw_button( 48, 46, "确定", 0, CHINESE );
            }
            print_int( 45, 25, bai, 0 );
            print_int( 53, 25, shi, 0 );
            print_int( 61, 25, ge, 0 );
            print_int( 72, 25, shifen, 0 );
            break;
            
        case 2:
            if ( ENGLISH == systems.language )
            {
                draw_rect( 12, 3, 12, 12 );
                print_str( 24, 3, "timing", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_str( 78, 3, "ration", 0 );
                draw_button( 48, 46, "Ok", 0, ENGLISH );
            }
            else
            {
                draw_rect( 12, 3, 12, 12 );
                print_ch_str( 24, 3, "定时间", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_ch_str( 78, 3, "定体积", 0 );
                draw_button( 48, 46, "确定", 0, CHINESE );
            }
            
            fill_rect( 44, 25, 8, 12 );
            print_int( 45, 25, bai, 1 );
            print_int( 53, 25, shi, 0 );
            print_int( 61, 25, ge, 0 );
            print_int( 72, 25, shifen, 0 );
            break;
            
        case 3:
            if ( ENGLISH == systems.language )
            {
                draw_rect( 12, 3, 12, 12 );
                print_str( 24, 3, "timing", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_str( 78, 3, "ration", 0 );
                draw_button( 48, 46, "Ok", 0, ENGLISH );
            }
            else
            {
                draw_rect( 12, 3, 12, 12 );
                print_ch_str( 24, 3, "定时间", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_ch_str( 78, 3, "定体积", 0 );
                draw_button( 48, 46, "确定", 0, CHINESE );
            }
            
            print_int( 45, 25, bai, 0 );
            fill_rect( 52, 25, 8, 12 );
            print_int( 53, 25, shi, 1 );
            print_int( 61, 25, ge, 0 );
            print_int( 72, 25, shifen, 0 );
            break;
            
        case 4:
            if ( ENGLISH == systems.language )
            {
                draw_rect( 12, 3, 12, 12 );
                print_str( 24, 3, "timing", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_str( 78, 3, "ration", 0 );
                draw_button( 48, 46, "Ok", 0, ENGLISH );
            }
            else
            {
                draw_rect( 12, 3, 12, 12 );
                print_ch_str( 24, 3, "定时间", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_ch_str( 78, 3, "定体积", 0 );
                draw_button( 48, 46, "确定", 0, CHINESE );
            }
            
            print_int( 45, 25, bai, 0 );
            print_int( 53, 25, shi, 0 );
            fill_rect( 60, 25, 8, 12 );
            print_int( 61, 25, ge, 1 );
            print_int( 72, 25, shifen, 0 );
            break;
            
        case 5:
            if ( ENGLISH == systems.language )
            {
                draw_rect( 12, 3, 12, 12 );
                print_str( 24, 3, "timing", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_str( 78, 3, "ration", 0 );
                draw_button( 48, 46, "Ok", 0, ENGLISH );
            }
            else
            {
                draw_rect( 12, 3, 12, 12 );
                print_ch_str( 24, 3, "定时间", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_ch_str( 78, 3, "定体积", 0 );
                draw_button( 48, 46, "确定", 0, CHINESE );
            }
            
            print_int( 45, 25, bai, 0 );
            print_int( 53, 25, shi, 0 );
            print_int( 61, 25, ge, 0 );
            fill_rect( 71, 25, 8, 12 );
            print_int( 72, 25, shifen, 1 );
            break;
            
        case 6:
            if ( ENGLISH == systems.language )
            {
                draw_rect( 12, 3, 12, 12 );
                print_str( 24, 3, "timing", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_str( 78, 3, "ration", 0 );
                draw_button( 48, 46, "Ok", 1, ENGLISH );
            }
            else
            {
                draw_rect( 12, 3, 12, 12 );
                print_ch_str( 24, 3, "定时间", 0 );
                draw_rect( 66, 3, 12, 12 );
                print_ch_str( 78, 3, "定体积", 0 );
                draw_button( 48, 46, "确定", 1, CHINESE );
            }
            print_int( 45, 25, bai, 0 );
            print_int( 53, 25, shi, 0 );
            print_int( 61, 25, ge, 0 );
            print_int( 72, 25, shifen, 0 );
            break;
        }
        
        draw_symbol( 67, 4, 10, 10, gou_mu, 0 );
        draw_point( 69, 33 );       // 打印小数点
        putchar( 100, 25, 'L', 0 );
    }
    
	draw_symbol( 85, 25, 12, 12, right_mu, 0 );	// 画右三角
}

void smpTimeMenuOnUp(void)
{
	struct MENU *lp;
    unsigned int bai, shi, ge, shifen;
    
	lp = win->curfous;
    
    if ( TIMING == systems.manu.tim_vol_status )
    {
        switch ( lp->status1 )
        {
        case 2:
            systems.a_hour++;
            if ( 10 == systems.a_hour )
            {
                systems.a_hour = 0;
            }
            print_int( 45, 25, systems.a_hour, 1 );
            break;
        case 3:
            systems.a_min++;
            if ( 10 == systems.a_min )
            {
                systems.a_min = 0;
            }
            print_int( 53, 25, systems.a_min, 1 );
            break;
        case 4:
            systems.a_sec++;
            if ( 10 == systems.a_sec )
            {
                systems.a_sec = 0;
            }
            print_int( 61, 25, systems.a_sec, 1 );
            break;
        default: break;
        }
    }
    else
    {
        switch ( lp->status1 )
        {
        case 2:
            bai = (unsigned int)(systems.a_volume / 100 );
            systems.a_volume -= bai * 100;
            if ( bai == 9 )
            {
                bai = 0;
            }
            else
            {
                bai++;
            }
            systems.a_volume += bai * 100;
            print_int( 45, 25, bai, 1 );
            break;
            
        case 3:
            bai = (unsigned int)(systems.a_volume / 100 );
            shi = (unsigned int)(( systems.a_volume - bai * 100 ) / 10 );
            systems.a_volume -= shi * 10;
            if ( shi == 9 )
            {
                shi = 0;
            }
            else
            {
                shi++;
            }
            systems.a_volume += shi * 10;
            print_int( 53, 25, shi, 1 );
            break;
            
        case 4:
            ge = (unsigned int)(systems.a_volume) % 10 ;
            systems.a_volume -= ge;
            if ( ge == 9 )
            {
                ge = 0;
            }
            else
            {
                ge++;
            }
            systems.a_volume += ge;
            print_int( 61, 25, ge, 1 );
            break;
            
        case 5:
            shifen = (unsigned int)(systems.a_volume * 10 ) % 10 ;
            systems.a_volume -= shifen * 0.1;
            if ( shifen == 9 )
            {
                shifen = 0;
            }
            else
            {
                shifen++;
            }
            systems.a_volume += shifen * 0.1;
            print_int( 72, 25, shifen, 1 );
            break;
            
        default: break;
        }
    }
}

void smpTimeMenuOnDown(void)
{
	struct MENU *lp;
    unsigned int bai, shi, ge, shifen;
    
	lp = win->curfous;
    
    if ( TIMING == systems.manu.tim_vol_status )
    {
        switch ( lp->status1 )
        {
        case 2:
            if ( systems.a_hour > 0 )
            {
                systems.a_hour--;
            }
            else
            {
                systems.a_hour = 9;
            }
            print_int( 45, 25, systems.a_hour, 1 );
            break;
        case 3:
            if ( systems.a_min > 0 )
            {
                systems.a_min--;
            }
            else
            {
                systems.a_min = 9;
            }
            print_int( 53, 25, systems.a_min, 1 );
            break;
        case 4:
            if ( systems.a_sec > 0 )
            {
                systems.a_sec--;
            }
            else
            {
                systems.a_sec = 9;
            }
            print_int( 61, 25, systems.a_sec, 1 );
            break;
        default: break;
        }
    }
    else
    {
        switch ( lp->status1 )
        {
        case 2:
            bai = (unsigned int)(systems.a_volume / 100 );
            systems.a_volume -= bai * 100;
            if ( bai == 0 )
            {
                bai = 9;
            }
            else
            {
                bai--;
            }
            systems.a_volume += bai * 100;
            print_int( 45, 25, bai, 1 );
            break;
            
        case 3:
            bai = (unsigned int)(systems.a_volume / 100 );
            shi = (unsigned int)(( systems.a_volume - bai * 100 ) / 10 );
            systems.a_volume -= shi * 10;
            if ( shi == 0 )
            {
                shi = 9;
            }
            else
            {
                shi--;
            }
            systems.a_volume += shi * 10;
            print_int( 53, 25, shi, 1 );
            break;
            
        case 4:
            ge = (unsigned int)(systems.a_volume) % 10 ;
            systems.a_volume -= ge;
            if ( ge == 0 )
            {
                ge = 9;
            }
            else
            {
                ge--;
            }
            systems.a_volume += ge;
            print_int( 61, 25, ge, 1 );
            break;
            
        case 5:
            shifen = (unsigned int)(systems.a_volume * 10 ) % 10 ;
            systems.a_volume -= shifen * 0.1;
            if ( shifen == 0 )
            {
                shifen = 9;
            }
            else
            {
                shifen--;
            }
            systems.a_volume += shifen * 0.1;
            print_int( 72, 25, shifen, 1 );
            break;
            
        default: break;
        }
    }
}

void smpTimeMenuOnLeft(void)
{
	struct MENU *lp;
    unsigned int bai, shi, ge, shifen;
	lp = win->curfous;
                
    if ( TIMING == systems.manu.tim_vol_status )
    {
        switch ( lp->status1 )
        {
        case 0:
            lp->status1 = 5;
            if ( ENGLISH == systems.language )
            {
                print_str( 24, 3, "timing", 0 );
                draw_button( 48, 46, "Ok", 1, ENGLISH );
            }
            else
            {
                print_ch_str( 24, 3, "定时间", 0 );
                draw_button( 48, 46, "确定", 1, CHINESE );
            }
            break;
            
        case 1:
            lp->status1 = 0;
            if ( ENGLISH == systems.language )
            {
                print_str( 24, 3, "timing", 1 );
                print_str( 78, 3, "ration", 0 );
            }
            else
            {
                print_ch_str( 24, 3, "定时间", 1 );
                print_ch_str( 78, 3, "定体积", 0 );
            } 
            break;
            
        case 2:
            lp->status1 = 1;
            if ( ENGLISH == systems.language )
            {
                print_str( 78, 3, "ration", 1 );
            }
            else
            {
                print_ch_str( 78, 3, "定体积", 1 );
            }
            clr_rect( 44, 25, 8, 12 );
            print_int( 45, 25, systems.a_hour, 0 );
            break;
            
        case 3:
            lp->status1 = 2;
            fill_rect( 44, 25, 8, 12 );
            print_int( 45, 25, systems.a_hour, 1 );
            clr_rect( 52, 25, 8, 12 );
            print_int( 53, 25, systems.a_min, 0 );
            break;
            
        case 4:
            lp->status1 = 3;
            fill_rect( 52, 25, 8, 12 );
            print_int( 53, 25, systems.a_min, 1 );
            clr_rect( 60, 25, 8, 12 );
            print_int( 61, 25, systems.a_sec, 0 );
            break;
            
        case 5:
            lp->status1 = 4;
            fill_rect( 60, 25, 8, 12 );
            print_int( 61, 25, systems.a_sec, 1 );
            if ( ENGLISH == systems.language )
            {
                draw_button( 48, 46, "Ok", 0, ENGLISH );
            }
            else
            {
                draw_button( 48, 46, "确定", 0, CHINESE );
            }
            break;
        default: break;
        }
    }
    else
    {
        bai = (unsigned int)( systems.a_volume / 100 );
        shi = (unsigned int)( systems.a_volume) % 100 / 10;
        ge = (unsigned int)( systems.a_volume) % 10;
        shifen = (unsigned int)( systems.a_volume * 10 ) % 10;
        switch ( lp->status1 )
        {
        case 0:
            lp->status1 = 6;
            if ( ENGLISH == systems.language )
            {
                print_str( 24, 3, "timing", 0 );
                draw_button( 48, 46, "Ok", 1, ENGLISH );
            }
            else
            {
                print_ch_str( 24, 3, "定时间", 0 );
                draw_button( 48, 46, "确定", 1, CHINESE );
            }
            break;
        
        case 1:
            lp->status1 = 0;
            if ( ENGLISH == systems.language )
            {
                print_str( 24, 3, "timing", 1 );
                print_str( 78, 3, "ration", 0 );
            }
            else
            {
                print_ch_str( 24, 3, "定时间", 1 );
                print_ch_str( 78, 3, "定体积", 0 );
            }
            break;
        
        case 2:
            lp->status1 = 1;
            if ( ENGLISH == systems.language )
            {
                print_str( 78, 3, "ration", 1 );
            }
            else
            {
                print_ch_str( 78, 3, "定体积", 1 );
            }
            clr_rect( 44, 25, 8, 12 );
            print_int( 45, 25, bai, 0 );
            break;
            
        case 3:
            lp->status1 = 2;
            fill_rect( 44, 25, 8, 12 );
            print_int( 45, 25, bai, 1 );
            clr_rect( 52, 25, 8, 12 );
            print_int( 53, 25, shi, 0 );
            break;
            
        case 4:
            lp->status1 = 3;
            fill_rect( 52, 25, 8, 12 );
            print_int( 53, 25, shi, 1 );
            clr_rect( 60, 25, 8, 12 );
            print_int( 61, 25, ge, 0 );
            break;
            
        case 5:
            lp->status1 = 4;
            fill_rect( 60, 25, 8, 12 );
            print_int( 61, 25, ge, 1 );
            clr_rect( 71, 25, 8, 12 );
            print_int( 72, 25, shifen, 0 );
            break;
        
        case 6:
            lp->status1 = 5;
            fill_rect( 71, 25, 8, 12 );
            print_int( 72, 25, shifen, 1 );
            if ( ENGLISH == systems.language )
            {
                draw_button( 48, 46, "Ok", 0, ENGLISH );
            }
            else
            {
                draw_button( 48, 46, "确定", 0, CHINESE );
            }
            break;
        default: break;
        }
    }
    
}
void smpTimeMenuOnRight(void)
{
	struct MENU *lp;
    unsigned int bai, shi, ge, shifen;
	lp = win->curfous;
    
    if ( TIMING == systems.manu.tim_vol_status )
    {
        switch ( lp->status1 )
        {
        case 0:
            lp->status1 = 1;
            if ( ENGLISH == systems.language )
            {
                print_str( 24, 3, "timing", 0 );
                print_str( 78, 3, "ration", 1 );
            }
            else
            {
                print_ch_str( 24, 3, "定时间", 0 );
                print_ch_str( 78, 3, "定体积", 1 );
            }
            break;
            
        case 1:
            lp->status1 = 2;
            if ( ENGLISH == systems.language )
            {
                print_str( 78, 3, "ration", 0 );
            }
            else
            {
                print_ch_str( 78, 3, "定体积", 0 );
            }
            fill_rect( 44, 25, 8, 12 );
            print_int( 45, 25, systems.a_hour, 1 );
            
            break;
            
        case 2:
            lp->status1 = 3;
            clr_rect( 44, 25, 8, 12 );
            print_int( 45, 25, systems.a_hour, 0 );
            fill_rect( 52, 25, 8, 12 );
            print_int( 53, 25, systems.a_min, 1 );
            break;
            
        case 3:
            lp->status1 = 4;
            clr_rect( 52, 25, 8, 12 );
            print_int( 53, 25, systems.a_min, 0 );
            fill_rect( 60, 25, 8, 12 );
            print_int( 61, 25, systems.a_sec, 1 );
            break;
            
        case 4:
            lp->status1 = 5;
            clr_rect( 60, 25, 8, 12 );
            print_int( 61, 25, systems.a_sec, 0 );
            if ( ENGLISH == systems.language )
            {
                draw_button( 48, 46, "Ok", 1, ENGLISH );
            }
            else
            {
                draw_button( 48, 46, "确定", 1, CHINESE );
            }
            break;
            
        case 5:
            lp->status1 = 0;
            if ( ENGLISH == systems.language )
            {
                print_str( 24, 3, "timing", 1 );
                draw_button( 48, 46, "Ok", 0, ENGLISH );
            }
            else
            {
                print_ch_str( 24, 3, "定时间", 1 );
                draw_button( 48, 46, "确定", 0, CHINESE );
            }
            break;
        default: break;
        }
    }
    else
    {
        bai = (unsigned int)( systems.a_volume / 100 );
        shi = (unsigned int)( systems.a_volume) % 100 / 10;
        ge = (unsigned int)( systems.a_volume) % 10;
        shifen = (unsigned int)( systems.a_volume * 10 ) % 10;
        switch ( lp->status1 )
        {
        case 0:
            lp->status1 = 1;
            if ( ENGLISH == systems.language )
            {
                print_str( 24, 3, "timing", 0 );
                print_str( 78, 3, "ration", 1 );
            }
            else
            {
                print_ch_str( 24, 3, "定时间", 0 );
                print_ch_str( 78, 3, "定体积", 1 );
            }
            break;
            
        case 1:
            lp->status1 = 2;
            if ( ENGLISH == systems.language )
            {
                print_str( 78, 3, "ration", 0 );
            }
            else
            {
                print_ch_str( 78, 3, "定体积", 0 );
            }
            fill_rect( 44, 25, 8, 12 );
            print_int( 45, 25, bai, 1 );
            
            break;
            
        case 2:
            lp->status1 = 3;
            clr_rect( 44, 25, 8, 12 );
            print_int( 45, 25, bai, 0 );
            fill_rect( 52, 25, 8, 12 );
            print_int( 53, 25, shi, 1 );
            break;
            
        case 3:
            lp->status1 = 4;
            clr_rect( 52, 25, 8, 12 );
            print_int( 53, 25, shi, 0 );
            fill_rect( 60, 25, 8, 12 );
            print_int( 61, 25, ge, 1 );
            break;
            
        case 4:
            lp->status1 = 5;
            clr_rect( 60, 25, 8, 12 );
            print_int( 61, 25, ge, 0 );
            fill_rect( 71, 25, 8, 12 );
            print_int( 72, 25, shifen, 1 );
            break;
            
        case 5:
            lp->status1 = 6;
            clr_rect( 71, 25, 8, 12 );
            print_int( 72, 25, shifen, 0 );
            if ( ENGLISH == systems.language )
            {
                draw_button( 48, 46, "Ok", 1, ENGLISH );
            }
            else
            {
                draw_button( 48, 46, "确定", 1, CHINESE );
            }            
            break;
            
        case 6:
            lp->status1 = 0;
            if ( ENGLISH == systems.language )
            {
                print_str( 24, 3, "timing", 1 );
                draw_button( 48, 46, "Ok", 0, ENGLISH );
            }
            else
            {
                print_ch_str( 24, 3, "定时间", 1 );
                draw_button( 48, 46, "确定", 0, CHINESE );
            }
            break;
        default: break;
        }
    }

}

void smpTimeMenuOnOk(void)
{
	struct MENU *lp;
    unsigned int bai, shi, ge, shifen;
	lp = win->curfous;
    
    if ( 0 == lp->status1 || 1 == lp->status1 )
    {
        if ( SAMPLING == systems.status )
        {            
            win->oldCurfous = win->curfous;
            win->curfous = win->errMenu;
            win->curfous->show();
            return;
        }
        
        if ( TIMING == systems.manu.tim_vol_status )
        {
            systems.manu.tim_vol_status = VOLUME; 
        }
        else
        {
            systems.manu.tim_vol_status = TIMING;
        }
        clr_rect( 13, 4, 10, 10 );    // 擦除钩
        clr_rect( 67, 4, 10, 10 );    // 擦除钩
        clr_rect( 43, 25, 39, 12 );   // 擦除中间的数字
        clr_rect( 100, 25, 18, 12 );  // 擦除 min 或 L 字样
        
        if ( TIMING == systems.manu.tim_vol_status )
        {
            systems.a_hour = (int)( systems.manu.smp_time / 100 );
            systems.a_min = (int)( systems.manu.smp_time % 100 / 10 );
            systems.a_sec = (int)( systems.manu.smp_time % 10 );
            
            print_int( 45, 25, systems.a_hour, 0 );
            print_int( 53, 25, systems.a_min, 0 );
            print_int( 61, 25, systems.a_sec, 0 );
            
            draw_symbol( 13, 4, 10, 10, gou_mu, 0 ); // 打钩
            
            draw_line( 69, 24, 69, 36 );	// 画内层矩形区内的竖线
            draw_symbol( 70, 25, 12, 12, up_down_mu, 0 );	// 画上下三角 
            print_str( 100, 25, "min", 0 );
        }
        else
        {
            systems.a_volume = systems.manu.smp_volume;
            bai = (unsigned int)(systems.manu.smp_volume / 100 );
            shi = (unsigned int)(systems.manu.smp_volume) % 100 / 10 ;
            ge = (unsigned int)(systems.manu.smp_volume) % 10 ;
            shifen = (unsigned int)(systems.manu.smp_volume * 10 ) % 10 ;
            
            print_int( 45, 25, bai, 0 );
            print_int( 53, 25, shi, 0 );
            print_int( 61, 25, ge, 0 );
            print_int( 72, 25, shifen, 0 );
              
            draw_symbol( 67, 4, 10, 10, gou_mu, 0 );
            draw_point( 69, 33 );       // 打印小数点
            putchar( 100, 25, 'L', 0 );
        }
        return;
    }
    
    if ( systems.a_hour == 0 && systems.a_min == 0 && systems.a_sec == 0 
         || systems.a_volume < 0.1 )
    {
        if ( lp->subMenu )
        {
            win->curfous = lp->subMenu;
            win->curfous->show();            
        }
    }
    else
	if ( systems.status != STOP )	// 系统正处于工作状态
	{
        if ( systems.a_hour == 0 && systems.a_min == 0 && systems.a_sec == 0 
             || systems.a_volume < 0.1 )
        {
            if ( lp->subMenu )
            {
                win->curfous = lp->subMenu;
                win->curfous->show();            
            }
        }
        else
        {
            if ( lp->topMenu )
            {
                if ( TIMING == systems.manu.tim_vol_status )
                {
                    // 此时的“时、分、秒”分别表示“百、十、个位“，单位为min
                    systems.manu.smp_time = systems.a_hour * 100 +
                                systems.a_min * 10 + systems.a_sec;
                    systems.a_hour = 0;
                    systems.a_min = 1;
                    systems.a_sec = 0;
                }
                else
                {
                    systems.manu.smp_volume = systems.a_volume;
                    systems.a_volume = 1.0;
                }
                win->curfous = lp->topMenu;
                win->curfous->show();
            }
        }
	}
	else	// 系统正处于停止状态
	{
        if ( systems.a_hour == 0 && systems.a_min == 0 && systems.a_sec == 0 )
        {
            if ( lp->subMenu )
            {
                win->curfous = lp->subMenu;
                win->curfous->show();            
            }
        }
        else
        {
            if ( lp->topMenu )
            {
                // 此时的“时、分、秒”分别表示“百、十、个位“，单位为min
                systems.manu.smp_time = systems.a_hour * 100 +
                            systems.a_min * 10 + systems.a_sec;
                systems.a_hour = 0;
                systems.a_min = 1;
                systems.a_sec = 0;
                
                systems.manu.smp_volume = systems.a_volume;
                systems.a_volume = 1.0;
                
                win->curfous = lp->topMenu;
                lp = win->curfous;
                if ( lp->topMenu )
                {
                    win->curfous = lp->topMenu;
                    win->curfous->show();
                }
            }
        }
	}
}


void smpTimeMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
    
    if ( STOP == systems.status || COMPLETE == systems.status )
    {
        if ( lp->topMenu )
        {
            win->curfous = lp->topMenu;
            lp = win->curfous;
            if ( lp->topMenu )
            {
                win->curfous = lp->topMenu;
                win->curfous->show();
            }
        }
    }
    else
    {
        if ( lp->topMenu )
        {
            win->curfous = lp->topMenu;
            win->curfous->show();
        }
    }
}

void smpTimeMenuExec(void)
{
}

/*
 * 手动模式采样时长设置警告菜单
 */
void smpTimeWarnMenuShow(void)
{
    win->mLevel = 4;
    clr_lcd();
	draw_rect( 0, 0, 128, 64 );
	draw_line( 15, 15, 112, 15 );    

    if ( ENGLISH == systems.language )
    {
        print_str( 40, 3, "Warning !", 0 );
        if ( TIMING == systems.manu.tim_vol_status )
        {            
            print_str( 2, 20, "smpTime can't be 0!", 0 );
        }
        else
        {
            print_str( 4, 20, "Volume can't be 0!", 0 );
        }
        print_str( 2, 33, "please reset!", 0 );
        draw_button( 85, 45, "OK", 1, ENGLISH );
    }
    else
    {
        print_ch_str( 40, 3, "警告", 0 );
        putchar( 70, 3, '!', 0 );
        if ( TIMING == systems.manu.tim_vol_status )
        {
            print_ch_str( 15, 20, "采样时长不能为", 0 );
        }
        else
        {
            print_ch_str( 15, 20, "采样体积不能为", 0 );
        }
        print_str( 99, 20 , "0!", 0 );
        print_ch_str( 15, 33, "请重新设置", 0 );
        draw_button( 85, 45, "确定", 1, CHINESE );
    }    
}

void smpTimeWarnMenuOnOk(void)
{
    struct MENU *lp;
    lp = win->curfous;
    if ( lp->topMenu )
    {
        win->curfous = lp->topMenu;
        win->curfous->show();
    }
}

/*
 * 定时模式查看设置菜单
 */
void timeViewMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
    win->mLevel = 3;

	clr_lcd();
	draw_rect( 0, 0, 127, 63 );
	draw_line( 15, 15, 112, 15 );

	print_str( 15, 18, "1.", 0 );
	print_str( 15, 33, "2.", 0 );

	if ( ENGLISH == systems.language )
	{
		print_str( 20, 3, "Select the Item", 0 );
		switch ( lp->status1 )
		{
		case 0:
			fill_rect( 29, 17, 92, 14 );
			print_str( 30, 18, "Timing Settings", 1 );
			print_str( 30, 33, "Timing Status", 0 );
			print_str( 54, 48, "Exit", 0 );
			break;
		case 1:
			print_str( 30, 18, "Timing Settings", 0 );
			fill_rect( 29, 32, 80, 14 );
			print_str( 30, 33, "Timing Status", 1 );
			print_str( 54, 48, "Exit", 0 );
			break;
		case 2:
			print_str( 30, 18, "Timing Settings", 0 );
			print_str( 30, 33, "Timing Status", 0 );
			fill_rect( 53, 47, 26, 14 );
			print_str( 54, 48, "Exit", 1 );
			break;
		default : break;
		}
	}
	else
	{
		print_ch_str( 23, 3, "请选择查看选项", 0 );
		switch ( lp->status1 )
		{
		case 0:
			fill_rect( 29, 17, 74, 14 );
			print_ch_str( 30, 18, "定时模式参数", 1 );
			print_ch_str( 30, 33, "定时模式状态", 0 );
			print_ch_str( 54, 48, "退出", 0 );
			break;
		case 1:
			print_ch_str( 30, 18, "定时模式参数", 0 );
			fill_rect( 29, 32, 74, 14 );
			print_ch_str( 30, 33, "定时模式状态", 1 );
			print_ch_str( 54, 48, "退出", 0 );
			break;
		case 2:
			print_ch_str( 30, 18, "定时模式参数", 0 );
			print_ch_str( 30, 33, "定时模式状态", 0 );
			fill_rect( 53, 47, 26, 14 );
			print_ch_str( 54, 48, "退出", 1 );
			break;
		default: break;
		}
	}
}

void timeViewMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 2;
			clr_rect( 29, 17, 92, 14 );
			print_str( 30, 18, "Timing Settings", 0 );
			print_str( 30, 33, "Timing Status", 0 );
			fill_rect( 53, 47, 26, 14 );
			print_str( 54, 48, "Exit", 1 );
			break;
		case 1:
			lp->status1 = 0;
			fill_rect( 29, 17, 92, 14 );
			print_str( 30, 18, "Timing Settings", 1 );
			clr_rect( 29, 32, 80, 14 );
			print_str( 30, 33, "Timing Status", 0 );
			print_str( 54, 48, "Exit", 0 );
			break;
		case 2:
			lp->status1 = 1;
			print_str( 30, 18, "Timing Settings", 0 );
			fill_rect( 29, 32, 80, 14 );
			print_str( 30, 33, "Timing Status", 1 );
			clr_rect( 53, 47, 26, 14 );
			print_str( 54, 48, "Exit", 0 );
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 2;
			clr_rect( 29, 17, 74, 14 );
			print_ch_str( 30, 18, "定时模式参数", 0 );
			print_ch_str( 30, 33, "定时模式状态", 0 );
			fill_rect( 53, 47, 26, 14 );
			print_ch_str( 54, 48, "退出", 1 );
			break;
		case 1:
			lp->status1 = 0;
			fill_rect( 29, 17, 74, 14 );
			print_ch_str( 30, 18, "定时模式参数", 1 );
			clr_rect( 29, 32, 74, 14 );
			print_ch_str( 30, 33, "定时模式状态", 0 );
			print_ch_str( 54, 48, "退出", 0 );
			break;
		case 2:
			lp->status1 = 1;
			print_ch_str( 30, 18, "定时模式参数", 0 );
			fill_rect( 29, 32, 74, 14 );
			print_ch_str( 30, 33, "定时模式状态", 1 );
			clr_rect( 53, 47, 26, 14 );
			print_ch_str( 54, 48, "退出", 0 );
			break;
		default: break;
		}
	}
}

void timeViewMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			clr_rect( 29, 17, 92, 14 );
			print_str( 30, 18, "Timing Settings", 0 );
			fill_rect( 29, 32, 80, 14 );
			print_str( 30, 33, "Timing Status", 1 );
			print_str( 54, 48, "Exit", 0 );
			break;
		case 1:
			lp->status1 = 2;
			print_str( 30, 18, "Timing Settings", 0 );
			clr_rect( 29, 32, 80, 14 );
			print_str( 30, 33, "Timing Status", 0 );
			fill_rect( 53, 47, 26, 14 );
			print_str( 54, 48, "Exit", 1 );
			break;
		case 2:
			lp->status1 = 0;
			fill_rect( 29, 17, 92, 14 );
			print_str( 30, 18, "Timing Settings", 1 );
			print_str( 30, 33, "Timing Status", 0 );
			clr_rect( 53, 47, 26, 14 );
			print_str( 54, 48, "Exit", 0 );
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			clr_rect( 29, 17, 74, 14 );
			print_ch_str( 30, 18, "定时模式参数", 0 );
			fill_rect( 29, 32, 74, 14 );
			print_ch_str( 30, 33, "定时模式状态", 1 );
			print_ch_str( 54, 48, "退出", 0 );
			break;
		case 1:
			lp->status1 = 2;
			print_ch_str( 30, 18, "定时模式参数", 0 );
			clr_rect( 29, 32, 74, 14 );
			print_ch_str( 30, 33, "定时模式状态", 0 );
			fill_rect( 53, 47, 26, 14 );
			print_ch_str( 54, 48, "退出", 1 );
			break;
		case 2:
			lp->status1 = 0;
			fill_rect( 29, 17, 74, 14 );
			print_ch_str( 30, 18, "定时模式参数", 1 );
			print_ch_str( 30, 33, "定时模式状态", 0 );
			clr_rect( 53, 47, 26, 14 );
			print_ch_str( 54, 48, "退出", 0 );
			break;
		default: break;
		}
	}
}

void timeViewMenuOnLeft(void)
{
}

void timeViewMenuOnRight(void)
{
}

void timeViewMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;

    switch ( lp->status1 )
    {
    case 0:
        if ( lp->subMenu )
        {
            win->curfous = lp->subMenu;
            win->curfous->show();
        }
        break;
    case 1:
        if ( lp->subMenu )
        {
            win->curfous = lp->subMenu->rMenu;
            win->curfous->show();
        }
        break;
    case 2:
        if ( lp->topMenu )
        {
            if ( systems.status == STOP || systems.status == COMPLETE )
            {
                systems.dynamic_flow = 0;
                systems.status = STOP;
                win->curfous = lp->topMenu;
                lp = win->curfous;
                win->curfous = lp->topMenu;
                win->curfous->show();
            }
            else
            {
                win->curfous = lp->topMenu;
                win->curfous->show();
            }
        }
        break;
    default: break;
    }
}

void timeViewMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;

    if ( lp->topMenu )
    {
        if ( systems.status == STOP || systems.status == COMPLETE )
        {
            systems.dynamic_flow = 0;
            systems.status = STOP;
            win->curfous = lp->topMenu;
            lp = win->curfous;
            win->curfous = lp->topMenu;
            win->curfous->show();
        }
        else
        {
            win->curfous = lp->topMenu;
            win->curfous->show();
        }
    }
}

void timeViewMenuExec(void)
{

}


/*
 * 定时模式各组参数查看菜单
 */
void timeViewSetMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
    win->mLevel = 3;
	clr_lcd();
	draw_rect( 0, 0, 128, 64 );
	draw_line( 15, 13, 112, 13 );
	draw_symbol( 2, 1, 12, 12, left_mu, 0 );
	draw_symbol( 114, 1, 12, 12, right_mu, 0 );

	if ( ENGLISH == systems.language )
	{
		print_str( 14, 1, "Group    Settings", 0 );
		print_int( 50, 1, lp->status1+1, 0 );	// 打印组号

		print_str( 2, 14, "Start Time:", 0 );
		print_str( 2, 26, "SMP Time:", 0 );
		print_str( 2, 38, "Flow:", 0 );
		print_str( 2, 50, "Status:", 0 );
		if( lp->status1 <= 9 )
		{
			print_time( systems.groups[lp->status1].start_time.hour,
						systems.groups[lp->status1].start_time.min,
						68, 14, HOUR_MIN );		// 打印组的开始时间

			print_int( 56, 26, systems.groups[lp->status1].smp_time, 0 ); // 打印组的采样时长
			print_str( 74, 26, "min", 0 );

			print_int( 32, 38, systems.groups[lp->status1].flow, 0 );  // 打印组的流量
			print_str( 56, 38, "mL/min", 0 );

			if ( systems.groups[lp->status1].srb )
			{
				print_str( 44, 50, "ON", 0 );	  // 打印组的启用状态
			}
			else
			{
				print_str( 44, 50, "Off", 0 );
			}
		}
		draw_button( 93, 46, "Exit", 1, ENGLISH );
	}
	else
	{
		print_ch_str( 37, 1, "组", 0 );
		print_ch_str( 73, 1, "参数", 0 );

		print_int( 55, 1, lp->status1+1, 0 );	// 打印组号

		print_ch_str( 2, 14, "启动时间", 0 );
		putchar( 50, 14, ':', 0 );

		print_ch_str( 2, 26, "采样时长", 0 );
		putchar( 50, 26, ':', 0 );

		print_ch_str( 2, 38, "流量", 0 );
		putchar( 26, 38, ':', 0 );
		print_str( 56, 38, "mL/min", 0 );

		print_ch_str( 2, 50, "启用", 0 );
		putchar( 26, 50, ':', 0 );

		if ( lp->status1 <= 9 )
		{
			print_time( systems.groups[lp->status1].start_time.hour,
						systems.groups[lp->status1].start_time.min,
						56, 14, HOUR_MIN );

			print_int( 56, 26, systems.groups[lp->status1].smp_time, 0 );
			print_str( 74, 26, "min", 0 );

			print_int( 32, 38, systems.groups[lp->status1].flow, 0 );

			if ( systems.groups[lp->status1].srb )
			{
				print_ch_str( 32, 50, "已启用", 0 );
			}
			else
			{
				print_ch_str( 32, 50, "未启用", 0 );
			}
		}
		draw_button( 93, 46, "退出", 1, CHINESE );
	}
}

void timeViewSetMenuOnLeft(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( 0 == lp->status1 )
	{
		lp->status1 = 9;
	}
	else
	{
		lp->status1--;
	}
	clr_rect( 56, 26, 18, 12 );   // 清空采样时长显示区
	clr_rect( 32, 38, 24, 12 );   // 清空流量显示区
	clr_rect( 44, 50, 18, 12 );   // 清空启用状态显示区
	if ( ENGLISH == systems.language )
	{
		clr_rect( 50, 1, 12, 12 );   // 清空组号显示区
		print_int( 50, 1, lp->status1+1, 0 );	// 打印组号
		if( lp->status1 <= 9 )
		{
			print_time( systems.groups[lp->status1].start_time.hour,
						systems.groups[lp->status1].start_time.min,
						68, 14, HOUR_MIN );		// 打印组的开始时间

			print_int( 56, 26, systems.groups[lp->status1].smp_time, 0 ); // 打印组的采样时长

			print_int( 32, 38, systems.groups[lp->status1].flow, 0 );  // 打印组的流量

			if ( systems.groups[lp->status1].srb )
			{
				print_str( 44, 50, "ON", 0 );	  // 打印组的启用状态
			}
			else
			{
				print_str( 44, 50, "Off", 0 );
			}
		}
	}
	else
	{
		clr_rect( 55, 1, 12, 12 );   // 清空组号显示区
		print_int( 55, 1, lp->status1+1, 0 );
		if ( lp->status1 <= 9 )
		{
			print_time( systems.groups[lp->status1].start_time.hour,
						systems.groups[lp->status1].start_time.min,
						56, 14, HOUR_MIN );

			print_int( 56, 26, systems.groups[lp->status1].smp_time, 0 );

			print_int( 32, 38, systems.groups[lp->status1].flow, 0 );

			if ( systems.groups[lp->status1].srb )
			{
				print_ch_str( 32, 50, "已启用", 0 );
			}
			else
			{
				print_ch_str( 32, 50, "未启用", 0 );
			}
		}
	}
}

void timeViewSetMenuOnRight(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( 9 == lp->status1 )
	{
		lp->status1 = 0;
	}
	else
	{
		lp->status1++;
	}

	clr_rect( 56, 26, 18, 12 );   // 清空采样时长显示区
	clr_rect( 32, 38, 24, 12 );   // 清空流量显示区
	clr_rect( 44, 50, 18, 12 );   // 清空启用状态显示区
	if ( ENGLISH == systems.language )
	{
		clr_rect( 50, 1, 12, 12 );   // 清空组号显示区
		print_int( 50, 1, lp->status1+1, 0 );	// 打印组号
		if( lp->status1 <= 9 )
		{
			print_time( systems.groups[lp->status1].start_time.hour,
						systems.groups[lp->status1].start_time.min,
						68, 14, HOUR_MIN );		// 打印组的开始时间

			print_int( 56, 26, systems.groups[lp->status1].smp_time, 0 ); // 打印组的采样时长

			print_int( 32, 38, systems.groups[lp->status1].flow, 0 );  // 打印组的流量

			if ( systems.groups[lp->status1].srb )
			{
				print_str( 44, 50, "ON", 0 );	  // 打印组的启用状态
			}
			else
			{
				print_str( 44, 50, "Off", 0 );
			}
		}
	}
	else
	{
		clr_rect( 55, 1, 12, 12 );   // 清空组号显示区
		print_int( 55, 1, lp->status1+1, 0 );	// 打印组号
		if ( lp->status1 <= 9 )
		{
			print_time( systems.groups[lp->status1].start_time.hour,
						systems.groups[lp->status1].start_time.min,
						56, 14, HOUR_MIN );

			print_int( 56, 26, systems.groups[lp->status1].smp_time, 0 );

			print_int( 32, 38, systems.groups[lp->status1].flow, 0 );

			if ( systems.groups[lp->status1].srb )
			{
				print_ch_str( 32, 50, "已启用", 0 );
			}
			else
			{
				print_ch_str( 32, 50, "未启用", 0 );
			}
		}
	}
}

void timeViewSetMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( COMPLETE == systems.status )
	{
		systems.status = STOP;
    
        stopPump();
        systems.dynamic_flow = 0;
		
        win->curfous->show();
	}
	else
	{
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
}

void timeViewSetMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void timeViewSetMenuExec(void)
{

}


/*
 * 定时模式各组状态查看菜单
 */
void timeViewStatusMenuShow(void)
{
	struct MENU *lp;
	int group;
	lp = win->curfous;
    win->mLevel = 4;
	clr_lcd();
	draw_line( 0, 15, 127, 15 );

	if ( ENGLISH == systems.language )
	{
		print_str( 0, 3, "GRP", 0 );
		print_str( 30, 3, "Dyn Flow", 0 );
		print_str( 84, 3, "Percent", 0 );
		if ( STOP != systems.status )
		{
			for ( group = lp->status1; group < lp->status1+3; group++ )
			{
				if( 9 == group )
				{
					print_int( 0, 18+( group-lp->status1 )*15, group+1, 0 );
				}
				else
				{
					print_int( 6, 18+( group-lp->status1 )*15, group+1, 0 );
				}

				// 显示动态流量
				if( systems.cur_group == group
					    && ( systems.group_status & ( 0x00000001 << (group*2)) ))
				{     // group正是在采样的组
				    print_float( 36, 18+(group-lp->status1)*15,
				    		systems.dynamic_flow, 2, 0 );
				}
				else
				{
				    print_float( 36, 18+(group-lp->status1)*15, 0, 2, 0 );
				}

	            if( systems.groups[group].srb ) // 判断组的状态是否启用
	            {
					if( !( systems.group_status & ( 0x00000003 << (group*2))))
					{	// 就绪中
						print_str( 90, 18+(group-lp->status1)*15, "Ready", 0 );
					}
					else if((systems.group_status & ( 0x00000001 << (group*2))))
					{	// 正在采样，显示完成量
						print_int( 90, 18+(group-lp->status1)*15,
								(unsigned int)( systems.percent*100), 0 );
						putchar( 108, 18+(group-lp->status1)*15, '%', 0 );
					}
					else if(( systems.group_status & ( 0x00000002 << (group*2))))
					{
						print_str( 90, 18+(group-lp->status1)*15, "Comple", 0 );
					}
	            }
	            else  // 当前组没有启用
	            {
	              print_str( 90, 18+(group-lp->status1)*15, "Off", 0 );
	            }
			}
		}
		else     // 系统处于停止状态（没有启动采样）
		{
			print_str( 20, 30, "Non-Started", 0 );
			draw_button( 93, 46, "Exit", 1, ENGLISH );
		}
	}
	else
	{
		print_ch_str( 0, 3, "组", 0 );
		print_ch_str( 30, 3, "动态流量", 0 );
		print_ch_str( 90, 3, "完成量", 0 );
		if ( STOP != systems.status )
		{
			for ( group = lp->status1; group < lp->status1+3; group++ )
			{
				if( 9 == group )
				{
					print_int( 0, 18+( group-lp->status1 )*15, group+1, 0 );
				}
				else
				{
					print_int( 6, 18+( group-lp->status1 )*15, group+1, 0 );
				}

				// 显示动态流量
				if( systems.cur_group == group
					    && ( systems.group_status
						     & ( 0x00000001 << (group*2)) ))     // group正是在采样的组
				{
				    print_float( 36, 18+(group-lp->status1)*15,
				    		systems.dynamic_flow, 2, 0 );
				}
				else
				{
				    print_float( 36, 18+(group-lp->status1)*15, 0, 2, 0 );
				}

	            if( systems.groups[group].srb ) // 判断组的状态是否启用
	            {
					if( !( systems.group_status & ( 0x00000003 << (group*2))))
					{	// 就绪中
						print_ch_str( 90, 18+(group-lp->status1)*15, "就绪", 0 );
					}
					else if((systems.group_status & ( 0x00000001 << (group*2))))
					{	// 正在采样，显示完成量
						print_int( 90, 18+(group-lp->status1)*15,
								(unsigned int)( systems.percent*100), 0 );
						putchar( 108, 18+(group-lp->status1)*15, '%', 0 );
					}
					else if(( systems.group_status & ( 0x00000002 << (group*2))))
					{
						print_ch_str( 90, 18+(group-lp->status1)*15, "已完成", 0 );
					}
	            }
	            else  // 当前组没有启用
	            {
	              print_ch_str( 90, 18+(group-lp->status1)*15, "未启用", 0 );
	            }
			}
		}
		else     // 系统处于停止状态（没有启动采样）
		{
			print_ch_str( 20, 30, "未启动采样", 0 );
			draw_button( 93, 46, "退出", 1, CHINESE );
		}
	}
}

void timeViewStatusMenuOnUp(void)
{
	struct MENU *lp;
	int group;
	lp = win->curfous;

	if ( 0 == lp->status1 )
	{
		lp->status1 = 7;
	}
	else
	{
		lp->status1--;
	}
	clr_rect( 0, 18, 128, 46 );
	if ( ENGLISH == systems.language )
	{
		if ( STOP != systems.status )
		{
			for ( group = lp->status1; group < lp->status1+3; group++ )
			{
				if( 9 == group )
				{
					print_int( 0, 18+( group-lp->status1 )*15, group+1, 0 );
				}
				else
				{
					print_int( 6, 18+( group-lp->status1 )*15, group+1, 0 );
				}

				// 显示动态流量
				if( systems.cur_group == group
					    && ( systems.group_status
						     & ( 0x00000001 << (group*2)) ))     // group正是在采样的组
				{
				    print_float( 36, 18+(group-lp->status1)*15,
				    		systems.dynamic_flow, 2, 0 );
				}
				else
				{
				    print_float( 36, 18+(group-lp->status1)*15, 0, 2, 0 );
				}

	            if( systems.groups[group].srb ) // 判断组的状态是否启用
	            {
					if( !( systems.group_status & ( 0x00000003 << (group*2))))
					{	// 就绪中
						print_str( 90, 18+(group-lp->status1)*15, "Ready", 0 );
					}
					else if((systems.group_status & ( 0x00000001 << (group*2))))
					{	// 正在采样，显示完成量
						print_int( 90, 18+(group-lp->status1)*15,
								(unsigned int)( systems.percent*100), 0 );
						putchar( 108, 18+(group-lp->status1)*15, '%', 0 );
					}
					else if(( systems.group_status & ( 0x00000002 << (group*2))))
					{
						print_str( 90, 18+(group-lp->status1)*15, "Comple", 0 );
					}
	            }
	            else  // 当前组没有启用
	            {
	              print_str( 90, 18+(group-lp->status1)*15, "Off", 0 );
	            }
			}
		}
		else     // 系统处于停止状态（没有启动采样）
		{
			print_str( 20, 30, "Non-Started", 0 );
			draw_button( 93, 46, "Exit", 1, ENGLISH );
		}
	}
	else
	{
		if ( STOP != systems.status )
		{
			for ( group = lp->status1; group < lp->status1+3; group++ )
			{
				if( 9 == group )
				{
					print_int( 0, 18+( group-lp->status1 )*15, group+1, 0 );
				}
				else
				{
					print_int( 6, 18+( group-lp->status1 )*15, group+1, 0 );
				}

				// 显示动态流量
				if( systems.cur_group == group
					    && ( systems.group_status
						     & ( 0x00000001 << (group*2)) ))     // group正是在采样的组
				{
				    print_float( 36, 18+(group-lp->status1)*15,
				    		systems.dynamic_flow, 2, 0 );
				}
				else
				{
				    print_float( 36, 18+(group-lp->status1)*15, 0, 2, 0 );
				}

	            if( systems.groups[group].srb ) // 判断组的状态是否启用
	            {
					if( !( systems.group_status & ( 0x00000003 << (group*2))))
					{	// 就绪中
						print_ch_str( 90, 18+(group-lp->status1)*15, "就绪", 0 );
					}
					else if((systems.group_status & ( 0x00000001 << (group*2))))
					{	// 正在采样，显示完成量
						print_int( 90, 18+(group-lp->status1)*15,
								(unsigned int)( systems.percent*100), 0 );
						putchar( 108, 18+(group-lp->status1)*15, '%', 0 );
					}
					else if(( systems.group_status & ( 0x00000002 << (group*2))))
					{
						print_ch_str( 90, 18+(group-lp->status1)*15, "已完成", 0 );
					}
	            }
	            else  // 当前组没有启用
	            {
	              print_ch_str( 90, 18+(group-lp->status1)*15, "未启用", 0 );
	            }
			}
		}
		else     // 系统处于停止状态（没有启动采样）
		{
			print_ch_str( 20, 30, "未启动采样", 0 );
			draw_button( 93, 46, "退出", 1, CHINESE );
		}
	}
}

void timeViewStatusMenuOnDown(void)
{
	struct MENU *lp;
	int group;
	lp = win->curfous;

	if ( 7 == lp->status1 )
	{
		lp->status1 = 0;
	}
	else
	{
		lp->status1++;
	}
	clr_rect( 0, 18, 128, 46 );
	if ( ENGLISH == systems.language )
	{
		if ( STOP != systems.status )
		{
			for ( group = lp->status1; group < lp->status1+3; group++ )
			{
				if( 9 == group )
				{
					print_int( 0, 18+( group-lp->status1 )*15, group+1, 0 );
				}
				else
				{
					print_int( 6, 18+( group-lp->status1 )*15, group+1, 0 );
				}

				// 显示动态流量
				if( systems.cur_group == group
					    && ( systems.group_status
						     & ( 0x00000001 << (group*2)) ))     // group正是在采样的组
				{
				    print_float( 36, 18+(group-lp->status1)*15,
				    		systems.dynamic_flow, 2, 0 );
				}
				else
				{
				    print_float( 36, 18+(group-lp->status1)*15, 0, 2, 0 );
				}

	            if( systems.groups[group].srb ) // 判断组的状态是否启用
	            {
					if( !( systems.group_status & ( 0x00000003 << (group*2))))
					{	// 就绪中
						print_str( 90, 18+(group-lp->status1)*15, "Ready", 0 );
					}
					else if((systems.group_status & ( 0x00000001 << (group*2))))
					{	// 正在采样，显示完成量
						print_int( 90, 18+(group-lp->status1)*15,
								(unsigned int)( systems.percent*100), 0 );
						putchar( 108, 18+(group-lp->status1)*15, '%', 0 );
					}
					else if(( systems.group_status & ( 0x00000002 << (group*2))))
					{
						print_str( 90, 18+(group-lp->status1)*15, "Comple", 0 );
					}
	            }
	            else  // 当前组没有启用
	            {
	              print_str( 90, 18+(group-lp->status1)*15, "Off", 0 );
	            }
			}
		}
		else     // 系统处于停止状态（没有启动采样）
		{
			print_str( 20, 30, "Non-Started", 0 );
			draw_button( 93, 46, "Exit", 1, ENGLISH );
		}
	}
	else
	{
		if ( STOP != systems.status )
		{
			for ( group = lp->status1; group < lp->status1+3; group++ )
			{
				if( 9 == group )
				{
					print_int( 0, 18+( group-lp->status1 )*15, group+1, 0 );
				}
				else
				{
					print_int( 6, 18+( group-lp->status1 )*15, group+1, 0 );
				}

				// 显示动态流量
				if( systems.cur_group == group
					    && ( systems.group_status
						     & ( 0x00000001 << (group*2)) ))     // group正是在采样的组
				{
				    print_float( 36, 18+(group-lp->status1)*15,
				    		systems.dynamic_flow, 2, 0 );
				}
				else
				{
				    print_float( 36, 18+(group-lp->status1)*15, 0, 2, 0 );
				}

	            if( systems.groups[group].srb ) // 判断组的状态是否启用
	            {
					if( !( systems.group_status & ( 0x00000003 << (group*2))))
					{	// 就绪中
						print_ch_str( 90, 18+(group-lp->status1)*15, "就绪", 0 );
					}
					else if((systems.group_status & ( 0x00000001 << (group*2))))
					{	// 正在采样，显示完成量
						print_int( 90, 18+(group-lp->status1)*15,
								(unsigned int)( systems.percent*100), 0 );
						putchar( 108, 18+(group-lp->status1)*15, '%', 0 );
					}
					else if(( systems.group_status & ( 0x00000002 << (group*2))))
					{
						print_ch_str( 90, 18+(group-lp->status1)*15, "已完成", 0 );
					}
	            }
	            else  // 当前组没有启用
	            {
	              print_ch_str( 90, 18+(group-lp->status1)*15, "未启用", 0 );
	            }
			}
		}
		else     // 系统处于停止状态（没有启动采样）
		{
			print_ch_str( 20, 30, "未启动采样", 0 );
			draw_button( 93, 46, "退出", 1, CHINESE );
		}
	}
}

void timeViewStatusMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( COMPLETE == systems.status )
	{
		systems.status = STOP;
        
        stopPump();
        systems.dynamic_flow = 0;
    
		win->curfous->show();
	}
	else
	{
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
}

void timeViewStatusMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void timeViewStatusMenuExec(void)
{
	int group;
	static double old_dynamic_flow = 0;
	static double old_percent = 0;
	struct MENU *lp;
	lp = win->curfous;
    
//    systems.dynamic_flow = getCurFlow();

	if ( old_dynamic_flow != systems.dynamic_flow
			|| old_percent != systems.percent )
	{
		for ( group = lp->status1; group < lp->status1+3; group++ )
		{
			// 显示动态流量
			if( systems.cur_group == group
					&& ( systems.group_status & ( 0x00000001 << (group*2)) ))
			{     // group正是在采样的组
				old_dynamic_flow = systems.dynamic_flow;
				clr_rect( 36, 18+(group-lp->status1)*15, 42, 12 );
				print_float( 36, 18+(group-lp->status1)*15,
						old_dynamic_flow, 2, 0 );
			}

			if( systems.groups[group].srb // 判断组的状态是否启用
				   && (systems.group_status & ( 0x00000001 << (group*2))) )
			{
				// 正在采样，显示完成量
				old_percent = systems.percent;
				clr_rect( 90, 18+(group-lp->status1)*15, 18, 12 );
				print_int( 90, 18+(group-lp->status1)*15,
						(unsigned int)( old_percent*100), 0 );
				putchar( 108, 18+(group-lp->status1)*15, '%', 0 );
			}
		}
	}
}

/*
 * 循环模式查看设置菜单
 */
void cylViewMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
    win->mLevel = 3;
	clr_lcd();
	draw_rect( 0, 0, 127, 63 );
	draw_line( 15, 15, 112, 15 );
	print_str( 15, 18, "1.", 0 );
	print_str( 15, 33, "2.", 0 );

	if ( ENGLISH == systems.language )
	{
		print_str( 20, 3, "Select the Item", 0 );
		switch ( lp->status1 )
		{
		case 0:
			fill_rect( 29, 17, 92, 14 );
			print_str( 30, 18, "Cycles Settings", 1 );
			print_str( 30, 33, "Cycles Status", 0 );
			print_str( 54, 48, "Exit", 0 );
			break;
		case 1:
			print_str( 30, 18, "Cycles Settings", 0 );
			fill_rect( 29, 32, 80, 14 );
			print_str( 30, 33, "Cycles Status", 1 );
			print_str( 54, 48, "Exit", 0 );
			break;
		case 2:
			print_str( 30, 18, "Cycles Settings", 0 );
			print_str( 30, 33, "Cycles Status", 0 );
			fill_rect( 53, 47, 26, 14 );
			print_str( 54, 48, "Exit", 1 );
			break;
		default: break;
		}
	}
	else
	{
		print_ch_str( 23, 3, "请选择查看选项", 0 );
		switch ( lp->status1 )
		{
		case 0:
			fill_rect( 29, 17, 74, 14 );
			print_ch_str( 30, 18, "循环模式参数", 1 );
			print_ch_str( 30, 33, "循环模式状态", 0 );
			print_ch_str( 54, 48, "退出", 0 );
			break;
		case 1:
			print_ch_str( 30, 18, "循环模式参数", 0 );
			fill_rect( 29, 32, 74, 14 );
			print_ch_str( 30, 33, "循环模式状态", 1 );
			print_ch_str( 54, 48, "退出", 0 );
			break;
		case 2:
			print_ch_str( 30, 18, "循环模式参数", 0 );
			print_ch_str( 30, 33, "循环模式状态", 0 );
			fill_rect( 53, 47, 26, 14 );
			print_ch_str( 54, 48, "退出", 1 );
			break;
		default: break;
		}
	}
}

void cylViewMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 2;
			clr_rect( 29, 17, 92, 14 );
			print_str( 30, 18, "Cycles Settings", 0 );
			print_str( 30, 33, "Cycles Status", 0 );
			fill_rect( 53, 47, 26, 14 );
			print_str( 54, 48, "Exit", 1 );
			break;
		case 1:
			lp->status1 = 0;
			fill_rect( 29, 17, 92, 14 );
			print_str( 30, 18, "Cycles Settings", 1 );
			clr_rect( 29, 32, 80, 14 );
			print_str( 30, 33, "Cycles Status", 0 );
			print_str( 54, 48, "Exit", 0 );
			break;
		case 2:
			lp->status1 = 1;
			print_str( 30, 18, "Cycles Settings", 0 );
			fill_rect( 29, 32, 80, 14 );
			print_str( 30, 33, "Cycles Status", 1 );
			clr_rect( 53, 47, 26, 14 );
			print_str( 54, 48, "Exit", 0 );
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 2;
			clr_rect( 29, 17, 92, 14 );
			print_ch_str( 30, 18, "循环模式参数", 0 );
			print_ch_str( 30, 33, "循环模式状态", 0 );
			fill_rect( 53, 47, 26, 14 );
			print_ch_str( 54, 48, "退出", 1 );
			break;
		case 1:
			lp->status1 = 0;
			fill_rect( 29, 17, 74, 14 );
			print_ch_str( 30, 18, "循环模式参数", 1 );
			clr_rect( 29, 32, 80, 14 );
			print_ch_str( 30, 33, "循环模式状态", 0 );
			print_ch_str( 54, 48, "退出", 0 );
			break;
		case 2:
			lp->status1 = 1;
			print_ch_str( 30, 18, "循环模式参数", 0 );
			fill_rect( 29, 32, 74, 14 );
			print_ch_str( 30, 33, "循环模式状态", 1 );
			clr_rect( 53, 47, 26, 14 );
			print_ch_str( 54, 48, "退出", 0 );
			break;
		default: break;
		}
	}
}

void cylViewMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			clr_rect( 29, 17, 92, 14 );
			print_str( 30, 18, "Cycles Settings", 0 );
			fill_rect( 29, 32, 80, 14 );
			print_str( 30, 33, "Cycles Status", 1 );
			print_str( 54, 48, "Exit", 0 );
			break;
		case 1:
			lp->status1 = 2;
			print_str( 30, 18, "Cycles Settings", 0 );
			clr_rect( 29, 32, 80, 14 );
			print_str( 30, 33, "Cycles Status", 0 );
			fill_rect( 53, 47, 26, 14 );
			print_str( 54, 48, "Exit", 1 );
			break;
		case 2:
			lp->status1 = 0;
			fill_rect( 29, 17, 92, 14 );
			print_str( 30, 18, "Cycles Settings", 1 );
			print_str( 30, 33, "Cycles Status", 0 );
			clr_rect( 53, 47, 26, 14 );
			print_str( 54, 48, "Exit", 0 );
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			clr_rect( 29, 17, 92, 14 );
			print_ch_str( 30, 18, "循环模式参数", 0 );
			fill_rect( 29, 32, 74, 14 );
			print_ch_str( 30, 33, "循环模式状态", 1 );
			print_ch_str( 54, 48, "退出", 0 );
			break;
		case 1:
			lp->status1 = 2;
			print_ch_str( 30, 18, "循环模式参数", 0 );
			clr_rect( 29, 32, 80, 14 );
			print_ch_str( 30, 33, "循环模式状态", 0 );
			fill_rect( 53, 47, 26, 14 );
			print_ch_str( 54, 48, "退出", 1 );
			break;
		case 2:
			lp->status1 = 0;
			fill_rect( 29, 17, 74, 14 );
			print_ch_str( 30, 18, "循环模式参数", 1 );
			print_ch_str( 30, 33, "循环模式状态", 0 );
			clr_rect( 53, 47, 26, 14 );
			print_ch_str( 54, 48, "退出", 0 );
			break;
		default: break;
		}
	}
}

void cylViewMenuOnLeft(void)
{
}

void cylViewMenuOnRight(void)
{
}

void cylViewMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;

    switch ( lp->status1 )
    {
    case 0:
        if ( lp->subMenu )
        {
            win->curfous = lp->subMenu;
            win->curfous->show();
        }
        break;
    case 1:
        if ( lp->subMenu )
        {
            win->curfous = lp->subMenu->rMenu;
            win->curfous->show();
        }
        break;
    case 2:
        if ( systems.status == STOP || systems.status == COMPLETE )
        {
            systems.dynamic_flow = 0;
            systems.status = STOP;
            win->curfous = lp->topMenu;
            lp = win->curfous;
            win->curfous = lp->topMenu;
            win->curfous->show();
        }
        else
        {
            win->curfous = lp->topMenu;
            win->curfous->show();
        }
        break;
    default: break;
    }

}

void cylViewMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;

    if ( systems.status == STOP || systems.status == COMPLETE )
    {
        systems.dynamic_flow = 0;
        systems.status = STOP;
        win->curfous = lp->topMenu;
        lp = win->curfous;
        win->curfous = lp->topMenu;
        win->curfous->show();
    }
    else
    {
        win->curfous = lp->topMenu;
        win->curfous->show();
    }
}

void cylViewMenuExec(void)
{

}


/*
 * 循环模式查看参数设置菜单
 */
void cylViewSetMenuShow(void)
{
//	struct MENU *lp;
//	lp = win->curfous;
    win->mLevel = 4;
	clr_lcd();
	draw_rect( 0, 0, 127, 63 );
	draw_line( 15, 13, 112, 13 );

	if ( ENGLISH == systems.language )
	{
		print_str( 15, 1, "Cycles Parameter", 0 );
		print_str( 2, 14, "Flow:", 0 );
		print_str( 56, 14, "mL/min", 0 );
		print_int( 32, 14, systems.cyls.flow, 0 );

        if ( TIMING == systems.cyls.tim_vol_status )
        {
            print_str( 2, 26, "SMP Time:", 0 );
            print_int( 56, 26, systems.cyls.smp_time, 0 );
            print_str( 74, 26, "min", 0 );
        }
        else
        {
            print_str( 2, 26, "SMP Volume:", 0 );
            print_float( 67, 26, systems.cyls.smp_volume, 1, 0 );
            if ( systems.cyls.smp_volume > 100 )
            {
                print_str( 98, 26, "L", 0 );
            }
            else
            {
                print_str( 92, 26, "L", 0 );
            }
        }

		print_str( 2, 38, "Delay:", 0 );
		print_int( 56, 38, systems.cyls.mid_time, 0 );
		print_str( 74, 38, "min", 0 );

		print_str( 2, 50, "Cycles:", 0 );
		print_int( 50, 50, systems.cyls.cyl_num, 0 );

		draw_button( 93, 45, "Exit", 1, ENGLISH );
	}
	else
	{
		print_ch_str( 28, 1, "循环模式参数", 0 );
		print_ch_str( 2, 14, "流量", 0 );
		putchar( 26, 14, ':', 0 );
		print_str( 60, 14, "mL/min", 0 );
		print_int( 31, 14,systems.cyls.flow, 0 );

        if ( TIMING == systems.cyls.tim_vol_status )
        {
            print_ch_str( 2, 26, "采样时长", 0 );
            putchar( 50, 26, ':', 0 );
            print_int( 56, 26, systems.cyls.smp_time, 0 );
            print_str( 74, 26, "min", 0 );
        }
        else
        {
            print_ch_str( 2, 26, "采样体积", 0 );
            putchar( 50, 26, ':', 0 );
            print_float( 56, 26, systems.cyls.smp_volume, 1 , 0 );
            if ( systems.cyls.smp_volume > 100 )
            {
                print_str( 88, 26, "L", 0 );
            }
            else
            {
                print_str( 82, 26, "L", 0 );
            }
        }

		print_ch_str( 2, 38, "间隔时间", 0 );
		putchar( 50, 38, ':', 0 );
		print_int( 56, 38, systems.cyls.mid_time, 0 );
		print_str( 74, 38, "min", 0 );

		print_ch_str( 2, 50, "循环次数", 0 );
		putchar( 50, 50, ':', 0 );
		print_int( 56, 50, systems.cyls.cyl_num, 0 );

		draw_button( 93, 45, "退出", 1, CHINESE );
	}
}

void cylViewSetMenuOnUp(void)
{
}

void cylViewSetMenuOnDown(void)
{
}

void cylViewSetMenuOnLeft(void)
{
}

void cylViewSetMenuOnRight(void)
{
}

void cylViewSetMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void cylViewSetMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void cylViewSetMenuExec(void)
{

}



/*
 * 循环模式查看状态菜单
 */
void cylViewStatusMenuShow(void)
{
    double volume;
    win->mLevel = 4;
	clr_lcd();
	draw_rect( 0, 0, 127, 63 );
	draw_line( 15, 13, 112, 13 );
	if ( ENGLISH == systems.language )
	{
		print_str( 23, 1, "Cylcles Status", 0 );
		print_str( 2, 14, "Dyn Flow:", 0 );
		print_str( 92, 14, "mL/m", 0 );
		print_str( 2, 26, "Status:", 0 );
		draw_button( 93, 45, "Exit", 1, ENGLISH );

		switch( systems.status)     //判断当前系统状态
        {
        case STOP:      //停止状态
            print_float( 56, 14, 0, 1, 0 );
            print_str( 44, 26, "Non-Started", 0 );
            break;
        case SAMPLING:
            print_float( 56, 14,systems.dynamic_flow, 1, 0 );
            print_int( 44, 26, (unsigned int)(systems.percent*100), 0 );
            print_str( 62, 26, "%,", 0 );
            if ( TIMING == systems.cyls.tim_vol_status )
            {
                print_int( 74, 26, systems.used_time, 0 );
                print_str( 92, 26, "min", 0 );
            }
            else
            {
                volume = systems.dynamic_volume / 1000;
                if ( volume > 100 )
                {
                    print_float( 74, 26, volume, 2, 0 );
                }
                else if ( volume > 10 )
                {
                    print_float( 74, 26, volume, 3, 0 );
                }
                else if ( volume > 0 )
                {
                    print_float( 74, 26, volume, 4, 0 );
                }
                putchar( 112, 26, 'L', 0 );
            }
            print_str( 2, 38, "Cycles", 0 );
            print_int( 40, 38, systems.cur_cyls + 1, 0 );
            print_str( 54, 38, "is", 0 );
            print_str( 2, 50, "Sampling", 0 );
            break;
        case WAITING:
            print_float( 56, 14, 0, 1, 0 );
            print_int( 44, 26, 0, 0 );
            print_str( 62, 26, "%,", 0 );
            if ( TIMING == systems.cyls.tim_vol_status )
            {
                print_int( 74, 26, 0, 0 );
                print_str( 92, 26, "min", 0 );
            }
            else
            {
                print_int( 90, 26, 0, 0 );
                putchar( 112, 26, 'L', 0 );
            }
            print_str( 2, 38, "Cycles", 0 );
            print_int( 40, 38, systems.cur_cyls + 1, 0 );
            print_str( 54, 38, "is", 0 );
            print_str( 2, 50, "Waiting", 0 );

            if( systems.wait_time >= 100 )
            {
                print_int( 44, 50, systems.wait_time, 0 );    //打印还需等待的时间
            }
            else if( systems.wait_time >= 10 )
            {
                print_int( 50, 50, systems.wait_time, 0 );    //打印还需等待的时间
            }
            else
            {
                print_int( 56, 50, systems.wait_time, 0 );    //打印还需等待的时间
            }
            putchar( 62, 50, ':', 0 );
            if( systems.wait_sec >= 10 )
            {
                print_int( 68, 50, systems.wait_sec, 0 );
            }
            else
            {
                putchar( 68, 50, '0', 0 );
                putchar( 74, 50, systems.wait_sec+'0', 0 );
            }
            break;
        default: break;
        }
	}
	else
	{
        print_ch_str( 30, 1, "循环模式状态", 0 );
        print_ch_str( 2, 14, "动态流量", 0 );
        putchar( 50, 14, ':', 0 );
        print_str( 92, 14, "mL/m", 0 );
        print_ch_str( 2, 26, "状态", 0 );
        putchar( 26, 26, ':', 0 );
        draw_button( 93, 45, "退出", 1, CHINESE );
        switch( systems.status )     //判断当前系统状态
        {
        case STOP:        //停止
            putchar( 56, 14, '0', 0 );
            print_ch_str( 32, 26, "未启动", 0 );
            break;
        case SAMPLING:    //正在采样
            print_float( 56, 14, systems.dynamic_flow, 1, 0 );
            print_int( 32, 26, (unsigned int)( systems.percent*100), 0 );
            print_str( 50, 26, "%,", 0 );
            if ( TIMING == systems.cyls.tim_vol_status )
            {
                print_int( 62, 26, systems.used_time, 0 );
                print_str( 80, 26, "min", 0 );
            }
            else
            {
                volume = systems.dynamic_volume / 1000;
                if ( volume > 100 )
                {
                    print_float( 62, 26, volume, 2, 0 );
                }
                else if ( volume > 10 )
                {
                    print_float( 62, 26, volume, 3, 0 );
                }
                else if ( volume > 0 )
                {
                    print_float( 62, 26, volume, 4, 0 );
                }
                putchar( 100, 26, 'L', 0 );
            }

            print_ch_str( 2, 38, "第", 0 );
            print_int( 14, 38, systems.cur_cyls + 1, 0 );
            print_ch_str( 26, 38, "次循环", 0 );
            print_ch_str( 2, 50, "正采样", 0 );
            break;
        case WAITING:    //在等待下一组或者是等待下一次循环
            print_float( 56, 14, 0, 1, 0 );
            print_int( 32, 26, 0, 0 );
            print_str( 50, 26, "%,", 0 );
            if ( TIMING == systems.cyls.tim_vol_status )
            {
                print_int( 62, 26, 0, 0 );
                print_str( 80, 26, "min", 0 );
            }
            else
            {
                print_int( 85, 26, 0, 0 );
                putchar( 100, 26, 'L', 0 );
            }

            print_ch_str( 2, 38, "第", 0 );
            print_int( 14, 38, systems.cur_cyls + 1, 0 );
            print_ch_str( 26, 38, "次循环", 0 );
            print_ch_str( 2, 50, "正等待", 0 );

            if( systems.wait_time >= 100 )
            {
                print_int( 38, 50, systems.wait_time, 0 );    //打印还需等待的时间
            }
            else if( systems.wait_time >= 10 )
            {
                print_int( 44, 50, systems.wait_time, 0 );    //打印还需等待的时间
            }
            else
            {
                print_int( 50, 50, systems.wait_time, 0 );    //打印还需等待的时间
            }
            putchar( 56, 50, ':', 0 );
            if( systems.wait_sec >= 10 )
            {
                print_int( 62, 50, systems.wait_sec, 0 );
            }
            else
            {
                putchar( 62, 50, '0', 0 );
                putchar( 68, 50, systems.wait_sec+'0', 0 );
            }
            break;
        default: break;
        }
	}
}

void cylViewStatusMenuOnUp(void)
{
}

void cylViewStatusMenuOnDown(void)
{
}

void cylViewStatusMenuOnLeft(void)
{
}

void cylViewStatusMenuOnRight(void)
{
}

void cylViewStatusMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void cylViewStatusMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void cylViewStatusMenuExec(void)
{
	static double old_dynamic_flow = 0;
	static double old_percent = 0;
	static unsigned int old_used_time = 0;
	static unsigned int old_status = 0;
    double volume;

	switch ( systems.status )
	{
	case SAMPLING:
		if ( ( old_dynamic_flow != systems.dynamic_flow )
			   || ( old_percent != systems.percent )
			   || ( old_used_time != systems.used_time ) )
		{
			if ( ENGLISH == systems.language )
			{
				print_float( 56, 14,systems.dynamic_flow, 1, 0 );
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_int( 74, 26, systems.used_time, 0 );
                }
                else
                {
                    volume = systems.dynamic_volume / 1000;
                    if ( volume > 100 )
                    {
                        print_float( 74, 26, volume, 2, 0 );
                    }
                    else if ( volume > 10 )
                    {
                        print_float( 74, 26, volume, 3, 0 );
                    }
                    else if ( volume > 0 )
                    {
                        print_float( 74, 26, volume, 4, 0 );
                    }
                }
				print_int( 44, 26, (unsigned int)(systems.percent*100), 0 );
			}
			else
			{
				print_float( 56, 14, systems.dynamic_flow, 1, 0 );
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_int( 62, 26, systems.used_time, 0 );
                }
                else
                {
                    volume = systems.dynamic_volume / 1000;
                    if ( volume > 100 )
                    {
                        print_float( 62, 26, volume, 2, 0 );
                    }
                    else if ( volume > 10 )
                    {
                        print_float( 62, 26, volume, 3, 0 );
                    }
                    else if ( volume > 0 )
                    {
                        print_float( 62, 26, volume, 4, 0 );
                    }
                }
				print_int( 32, 26, (unsigned int)( systems.percent*100), 0 );
			}
		}
		break;

	case WAITING:
		if ( ENGLISH == systems.language )
		{
			if( systems.wait_time >= 100 )
			{
				print_int( 44, 50, systems.wait_time, 0 );    //打印还需等待的时间
			}
			else if( systems.wait_time >= 10 )
			{
				print_int( 50, 50, systems.wait_time, 0 );    //打印还需等待的时间
			}
			else
			{
				print_int( 56, 50, systems.wait_time, 0 );    //打印还需等待的时间
			}
			putchar( 62, 50, ':', 0 );
			if( systems.wait_sec >= 10 )
			{
				print_int( 68, 50, systems.wait_sec, 0 );
			}
			else
			{
				putchar( 68, 50, '0', 0 );
				putchar( 74, 50, systems.wait_sec+'0', 0 );
			}
		}
		else
		{
            if( systems.wait_time >= 100 )
            {
                print_int( 38, 50, systems.wait_time, 0 );    //打印还需等待的时间
            }
            else if( systems.wait_time >= 10 )
            {
                print_int( 44, 50, systems.wait_time, 0 );    //打印还需等待的时间
            }
            else
            {
                print_int( 50, 50, systems.wait_time, 0 );    //打印还需等待的时间
            }
            putchar( 56, 50, ':', 0 );
            if( systems.wait_sec >= 10 )
            {
                print_int( 62, 50, systems.wait_sec, 0 );
            }
            else
            {
                putchar( 62, 50, '0', 0 );
                putchar( 68, 50, systems.wait_sec+'0', 0 );
            }
		}
		break;
	}


	if ( old_status != systems.status )
	{
		old_status = systems.status;
		switch ( old_status )
		{
		case WAITING:
			clr_rect( 56, 14, 36, 12 );
			print_int( 56, 14, 0, 0 );  // 刷新动态流量
			if ( ENGLISH == systems.language )
			{
				clr_rect( 44, 26, 18, 12 );
				print_int( 44, 26, 0, 0 );  // 刷新百分比
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    clr_rect( 74, 26, 18, 0 );
                    print_int( 74, 26, 0, 0 ); 
                }
                else
                {
                    clr_rect( 74, 26, 36, 12 );
                    print_int( 90, 26, 0, 0 );  // 刷新已采样体积
                }
				print_int( 40, 38, systems.cur_cyls + 1, 0 );
				clr_rect( 2, 50, 54, 12 );
				print_str( 2, 50, "Waiting", 0 );
			}
			else
			{
				clr_rect( 32, 26, 18, 12 );
				print_int( 32, 26, 0, 0 );  // 刷新百分比
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    clr_rect( 62, 26, 18, 0 );
                    print_int( 62, 26, 0, 0 ); 
                }
                else
                {
                    clr_rect( 62, 26, 36, 12 );
                    print_int( 85, 26, 0, 0 );  // 刷新已采样体积
                }
				print_int( 14, 38, systems.cur_cyls + 1, 0 );
				clr_rect( 2, 50, 48, 12 );
				print_ch_str( 2, 50, "正等待", 0 );
			}
			break;
		case SAMPLING:
			clr_rect( 2, 50, 84, 12 );
			if ( ENGLISH == systems.language )
			{
				print_str( 2, 50, "Sampling", 0 );
			}
			else
			{
				print_ch_str( 2, 50, "正采样", 0 );
			}
			break;
		default: break;
		}
	}
}

/*
 * 各种设置菜单
 */
void allSetMenuShow(void)
{
	struct MENU *lp;
	int index_icn;			// 用于打印图标的索引
	lp = win->curfous;
    win->mLevel = 3;

	clr_lcd();

	batShow(1);    //显示电池图标
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( STAT_X, STAT_Y, 12, 12, status_icn[systems.status], 0 );
	draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );   // 打印一个像扳手一样的设置图标
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	draw_rect( 36, 48, 60, 16 );     // 打印中下部的围着当前菜单说明文本的矩形框

	for ( index_icn=0; index_icn<4; index_icn++ )
	{   //打印图标
		if ( index_icn != lp->status1 )
		{
			draw_symbol( 40+index_icn*20, 12, 16, 16,
					set_bar_mu[index_icn], 0 );
		}
	}
	for ( index_icn=4; index_icn<7; index_icn++ )
	{   //打印图标
		if ( index_icn != lp->status1 )
		{
			draw_symbol( 40+(index_icn-4)*20, 30, 16, 16,
					set_bar_mu[index_icn], 0 );
		}
	}

	index_icn = lp->status1;
    if( lp->status1 < 4 )
    {
    	//反白打印焦点图标
        draw_symbol( 40+index_icn*20, 12, 16, 16,
        		set_bar_mu[index_icn], 1 );
    }
    else
    {
        draw_symbol( 40+(index_icn-4)*20, 30, 16, 16,
        		set_bar_mu[index_icn], 1 );
    }

	if ( ENGLISH == systems.language )
	{
		switch ( systems.mod )
		{
		case HAND_MOVE_MODE:
			print_str( MOD_X, MOD_Y, "MANU", 0 );
			break;
		case TIMING_MODE:
			print_str( MOD_X, MOD_Y, "TIM", 0 );
			break;
		case CIRCLE_MODE:
			print_str( MOD_X, MOD_Y, "CYL", 0 );
			break;
		default: break;
		}

		// 打印当前焦点菜单的英文文本
		print_str( 40, 50, set_bar_text[index_icn], 0 );
	}
	else
	{
		switch ( systems.mod )
		{
		case HAND_MOVE_MODE:
			print_ch_str( MOD_X, MOD_Y, "手动", 0 );
			break;
		case TIMING_MODE:
			print_ch_str( MOD_X, MOD_Y, "定时", 0 );
			break;
		case CIRCLE_MODE:
			print_ch_str( MOD_X, MOD_Y, "循环", 0 );
			break;
		default: break;
		}

		// 打印当前焦点菜单的中文文本
		print_ch_str( 40, 50, set_bar_text_chn[index_icn], 0 );
	}
}

void allSetMenuOnUp(void)
{
}

void allSetMenuOnDown(void)
{
}

void allSetMenuOnLeft(void)
{
	struct MENU *lp;
	int before_index_icn;	// 当前焦点改变前位置
	int after_index_icn;	// 当前焦点改变后位置
	lp = win->curfous;

	before_index_icn = lp->status1;	// 当前焦点改变前位置

	clr_rect( 37, 49, 58, 14 );

	// 当前焦点改变前位置,需要打印
    if( before_index_icn < 4 )
    {
        draw_symbol( 40+before_index_icn*20, 12, 16, 16,
        		set_bar_mu[before_index_icn], 0 );
    }
    else
    {
        draw_symbol( 40+(before_index_icn-4)*20, 30, 16, 16,
        		set_bar_mu[before_index_icn], 0 );
    }

	if ( lp->status1 == 0 )
	{
		lp->status1 = 6;	// 使焦点维持在0――5之间
	}
	else
	{
		lp->status1--;	// 改变当前焦点
	}
	after_index_icn = lp->status1;	// 当前焦点改变后位置

    // 当前焦点改变后位置,需要打印
    if( after_index_icn < 4 )
    {
    	//反白打印焦点图标
        draw_symbol( 40+after_index_icn*20, 12, 16, 16,
        		set_bar_mu[after_index_icn], 1 );
    }
    else
    {
        draw_symbol( 40+(after_index_icn-4)*20, 30, 16, 16,
        		set_bar_mu[after_index_icn], 1 );
    }

    if ( ENGLISH == systems.language )
    {
		//打印当前焦点菜单的英文文本
		print_str( 40, 50, set_bar_text[after_index_icn], 0 );
    }
    else
    {
		//打印当前焦点菜单的中文文本
		print_ch_str( 40, 50, set_bar_text_chn[after_index_icn], 0 );
    }
}

void allSetMenuOnRight(void)
{
	struct MENU *lp;
	int before_index_icn;	// 当前焦点改变前位置
	int after_index_icn;	// 当前焦点改变后位置
	lp = win->curfous;

	before_index_icn = lp->status1;	// 当前焦点改变前位置

	clr_rect( 37, 49, 58, 14 );

	// 当前焦点改变前位置,需要打印
    if( before_index_icn < 4 )
    {
        draw_symbol( 40+before_index_icn*20, 12, 16, 16,
        		set_bar_mu[before_index_icn], 0 );
    }
    else
    {
        draw_symbol( 40+(before_index_icn-4)*20, 30, 16, 16,
        		set_bar_mu[before_index_icn], 0 );
    }

	if ( lp->status1 == 6 )
	{
		lp->status1 = 0;	// 使焦点维持在0――5之间
	}
	else
	{
		lp->status1++;	// 改变当前焦点
	}
	after_index_icn = lp->status1;	// 当前焦点改变后位置

    // 当前焦点改变后位置,需要打印
    if( after_index_icn < 4 )
    {
    	//反白打印焦点图标
        draw_symbol( 40+after_index_icn*20, 12, 16, 16,
        		set_bar_mu[after_index_icn], 1 );
    }
    else
    {
        draw_symbol( 40+(after_index_icn-4)*20, 30, 16, 16,
        		set_bar_mu[after_index_icn], 1 );
    }

    if ( ENGLISH == systems.language )
    {
		//打印当前焦点菜单的英文文本
		print_str( 40, 50, set_bar_text[after_index_icn], 0 );
    }
    else
    {
		//打印当前焦点菜单的中文文本
		print_ch_str( 40, 50, set_bar_text_chn[after_index_icn], 0 );
    }
}

void allSetMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;

	switch ( lp->status1 )
	{
	case 0:	// 获取模式设置焦点
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu;
			win->curfous->show();
		}
		break;
	case 1:	// 获取参数设置焦点
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu->rMenu;
			win->curfous->show();
		}
		break;
	case 2:	// 获取语言设置焦点
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu->rMenu->rMenu;
			win->curfous->show();
		}
		break;
	case 3:	// 获取系统时间设置焦点
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu->rMenu->rMenu->rMenu;
			win->curfous->show();
		}
		break;
	case 4:	// 获取定时关机设置焦点
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu->rMenu->rMenu->rMenu->rMenu;
			win->curfous->show();
		}
		break;
    case 5:	// 获取校准流量焦点
		if ( lp->subMenu )
		{
/*            systems.status = STOP;
            systems.dynamic_flow = 0;
            systems.used_time = 0;
            systems.start_min = 0;
            systems.start_sec = 0;
            systems.percent = 0;
            
            startPump( systems.a_flow );*/
			win->curfous = lp->subMenu->rMenu->rMenu->rMenu->rMenu->rMenu;
			win->curfous->show();
		}
		break;
	case 6:	 // 获取退出焦点
        systems.dynamic_flow = 0;
        
        if ( lp->topMenu )
        {
            lp->status1 = 0;
            win->curfous = lp->topMenu;
            lp = win->curfous;
            if ( lp->topMenu )
            {
                win->curfous = lp->topMenu;
                win->curfous->show();
                lp = win->curfous;
                if ( lp->topMenu )
                {
                    win->curfous = lp->topMenu;
                    win->curfous->show();
                }
            }
        }
		break;
	default: break;
	}
}

void allSetMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
    
    systems.dynamic_flow = 0;
    
    if ( lp->topMenu )
    {
        lp->status1 = 0;
        win->curfous = lp->topMenu;
        lp = win->curfous;
        if ( lp->topMenu )
        {
            win->curfous = lp->topMenu;
            win->curfous->show();
            lp = win->curfous;
            if ( lp->topMenu )
            {
                win->curfous = lp->topMenu;
                win->curfous->show();
            }
        }
    }
}

void allSetMenuExec(void)
{
	batShow(0);
}


/*
 * 模式设置菜单
 */
void modSetMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;

	systems.old_mod = systems.mod;

	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );		// 打印一个像扳手一样的设置图标
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	draw_dialog( 0 );          // 描绘一个矩形框

    draw_line( 55, 36, 106, 36 ); //打印一条在靠选择栏的直线
    draw_symbol( 43, 23, 12, 12, left_mu, 0 );   //左三角
    draw_symbol( 106, 23,12, 12, right_mu, 0 );  //右三角

    if ( ENGLISH == systems.language )
    {
		print_str( 44, 3, "Set the Mode", 0 );       // 打印标题栏

		switch ( lp->status1 )
		{
		case 0:
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				print_str( 68, 23, "Manu", 1 );
				break;
			case TIMING_MODE:
				print_str( 62, 23, "Timing", 1 );
				break;
			case CIRCLE_MODE:
				print_str( 66, 23, "Cycle", 1 );
				break;
			}
			draw_button( 43, 43, "Ok", 0, ENGLISH ); //打印确定按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH ); //打印取消按钮
			break;
		case 1:
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				print_str( 68, 23, "Manu", 0 );
				break;
			case TIMING_MODE:
				print_str( 62, 23, "Timing", 0 );
				break;
			case CIRCLE_MODE:
				print_str( 66, 23, "Cycle", 0 );
				break;
			}
			draw_button( 43, 43, "Ok", 1, ENGLISH ); //打印确定按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH ); //打印取消按钮
			break;
		case 2:
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				print_str( 68, 23, "Manu", 0 );
				break;
			case TIMING_MODE:
				print_str( 62, 23, "Timing", 0 );
				break;
			case CIRCLE_MODE:
				print_str( 66, 23, "Cycle", 0 );
				break;
			}
			draw_button( 43, 43, "Ok", 0, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 1, ENGLISH );  //打印取消按钮
			break;
		default : break;
		}
    }
    else
    {
		print_ch_str( 53, 3, "请设置模式", 0 );       // 打印标题栏

		switch ( lp->status1 )
		{
		case 0:
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				print_ch_str( 56, 23, "手动模式", 1 );
				break;
			case TIMING_MODE:
				print_ch_str( 56, 23, "定时模式", 1 );
				break;
			case CIRCLE_MODE:
				print_ch_str( 56, 23, "循环模式", 1 );
				break;
			}
			draw_button( 43, 43, "确定", 0, CHINESE ); //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE ); //打印取消按钮
			break;
		case 1:
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				print_ch_str( 56, 23, "手动模式", 0 );
				break;
			case TIMING_MODE:
				print_ch_str( 56, 23, "定时模式", 0 );
				break;
			case CIRCLE_MODE:
				print_ch_str( 56, 23, "循环模式", 0 );
				break;
			}
			draw_button( 43, 43, "确定", 1, CHINESE ); //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE ); //打印取消按钮
			break;
		case 2:
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				print_ch_str( 56, 23, "手动模式", 0 );
				break;
			case TIMING_MODE:
				print_ch_str( 56, 23, "定时模式", 0 );
				break;
			case CIRCLE_MODE:
				print_ch_str( 56, 23, "循环模式", 0 );
				break;
			}
			draw_button( 43, 43, "确定", 0, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 1, CHINESE );  //打印取消按钮
			break;
		default : break;
		}
    }
}

void modSetMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;

	clr_rect( 56, 23, 48, 12 );
	if ( ENGLISH == systems.language )
	{
		if ( 0 == lp->status1 )
		{
			lp->status1 = 1;
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				print_str( 68, 23, "Manu", 0 );
				break;
			case TIMING_MODE:
				print_str( 62, 23, "Timing", 0 );
				break;
			case CIRCLE_MODE:
				print_str( 66, 23, "Cycle", 0 );
				break;
			}
			draw_button( 43, 43, "Ok", 1, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );  //打印取消按钮
		}
		else
		{
			lp->status1 = 0;
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				print_str( 68, 23, "Manu", 1 );
				break;
			case TIMING_MODE:
				print_str( 62, 23, "Timing", 1 );
				break;
			case CIRCLE_MODE:
				print_str( 66, 23, "Cycle", 1 );
				break;
			}
			draw_button( 43, 43, "Ok", 0, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );  //打印取消按钮
		}
	}
	else
	{
		if ( 0 == lp->status1 )
		{
			lp->status1 = 1;
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				print_ch_str( 56, 23, "手动模式", 0 );
				break;
			case TIMING_MODE:
				print_ch_str( 56, 23, "定时模式", 0 );
				break;
			case CIRCLE_MODE:
				print_ch_str( 56, 23, "循环模式", 0 );
				break;
			}
			draw_button( 43, 43, "确定", 1, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );  //打印取消按钮
		}
		else
		{
			lp->status1 = 0;
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				print_ch_str( 56, 23, "手动模式", 1 );
				break;
			case TIMING_MODE:
				print_ch_str( 56, 23, "定时模式", 1 );
				break;
			case CIRCLE_MODE:
				print_ch_str( 56, 23, "循环模式", 1 );
				break;
			}
			draw_button( 43, 43, "确定", 0, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );  //打印取消按钮
		}
	}
}

void modSetMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;

	clr_rect( 56, 23, 48, 12 );
	if ( ENGLISH == systems.language )
	{
		if ( 0 == lp->status1 )
		{
			lp->status1 = 1;
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				print_str( 68, 23, "Manu", 0 );
				break;
			case TIMING_MODE:
				print_str( 62, 23, "Timing", 0 );
				break;
			case CIRCLE_MODE:
				print_str( 66, 23, "Cycle", 0 );
				break;
			}
			draw_button( 43, 43, "Ok", 1, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );  //打印取消按钮
		}
		else
		{
			lp->status1 = 0;
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				print_str( 68, 23, "Manu", 1 );
				break;
			case TIMING_MODE:
				print_str( 62, 23, "Timing", 1 );
				break;
			case CIRCLE_MODE:
				print_str( 66, 23, "Cycle", 1 );
				break;
			}
			draw_button( 43, 43, "Ok", 0, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );  //打印取消按钮
		}
	}
	else
	{
		if ( 0 == lp->status1 )
		{
			lp->status1 = 1;
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				print_ch_str( 56, 23, "手动模式", 0 );
				break;
			case TIMING_MODE:
				print_ch_str( 56, 23, "定时模式", 0 );
				break;
			case CIRCLE_MODE:
				print_ch_str( 56, 23, "循环模式", 0 );
				break;
			}
			draw_button( 43, 43, "确定", 1, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );  //打印取消按钮
		}
		else
		{
			lp->status1 = 0;
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				print_ch_str( 56, 23, "手动模式", 1 );
				break;
			case TIMING_MODE:
				print_ch_str( 56, 23, "定时模式", 1 );
				break;
			case CIRCLE_MODE:
				print_ch_str( 56, 23, "循环模式", 1 );
				break;
			}
			draw_button( 43, 43, "确定", 0, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );  //打印取消按钮
		}
	}
}

void modSetMenuOnLeft(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			clr_rect( 56, 23, 48, 12 );
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				systems.old_mod = CIRCLE_MODE;
				print_str( 66, 23, "Cycle", 1 );
				break;
			case TIMING_MODE:
				systems.old_mod = HAND_MOVE_MODE;
				print_str( 68, 23, "Manu", 1 );
				break;
			case CIRCLE_MODE:
				systems.old_mod = TIMING_MODE;
				print_str( 62, 23, "Timing", 1 );
				break;
			}

			break;
		case 1:
			lp->status1 = 2;
			draw_button( 43, 43, "Ok", 0, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 1, ENGLISH );  //打印取消按钮
			break;
		case 2:
			lp->status1 = 1;
			draw_button( 43, 43, "Ok", 1, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );  //打印取消按钮
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			clr_rect( 56, 23, 48, 12 );
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				systems.old_mod = CIRCLE_MODE;
				print_ch_str( 56, 23, "循环模式", 1 );
				break;
			case TIMING_MODE:
				systems.old_mod = HAND_MOVE_MODE;
				print_ch_str( 56, 23, "手动模式", 1 );
				break;
			case CIRCLE_MODE:
				systems.old_mod = TIMING_MODE;
				print_ch_str( 56, 23, "定时模式", 1 );
				break;
			}
			break;
		case 1:
			lp->status1 = 2;
			draw_button( 43, 43, "确定", 0, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 1, CHINESE );  //打印取消按钮
			break;
		case 2:
			lp->status1 = 1;
			draw_button( 43, 43, "确定", 1, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );  //打印取消按钮
			break;
		default: break;
		}
	}
}

void modSetMenuOnRight(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			clr_rect( 56, 23, 48, 12 );
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				systems.old_mod = TIMING_MODE;
				print_str( 62, 23, "Timing", 1 );
				break;
			case TIMING_MODE:
				systems.old_mod = CIRCLE_MODE;
				print_str( 66, 23, "Cycle", 1 );
				break;
			case CIRCLE_MODE:
				systems.old_mod = HAND_MOVE_MODE;
				print_str( 68, 23, "Manu", 1 );
				break;
			}
			break;

		case 1:
			lp->status1 = 2;
			draw_button( 43, 43, "Ok", 0, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 1, ENGLISH );  //打印取消按钮
			break;
		case 2:
			lp->status1 = 1;
			draw_button( 43, 43, "Ok", 1, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );  //打印取消按钮
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			clr_rect( 56, 23, 48, 12 );
			switch ( systems.old_mod )
			{
			case HAND_MOVE_MODE:
				systems.old_mod = TIMING_MODE;
				print_ch_str( 56, 23, "定时模式", 1 );
				break;
			case TIMING_MODE:
				systems.old_mod = CIRCLE_MODE;
				print_ch_str( 56, 23, "循环模式", 1 );
				break;
			case CIRCLE_MODE:
				systems.old_mod = HAND_MOVE_MODE;
				print_ch_str( 56, 23, "手动模式", 1 );
				break;
			}
			break;
		case 1:
			lp->status1 = 2;
			draw_button( 43, 43, "确定", 0, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 1, CHINESE );  //打印取消按钮
			break;
		case 2:
			lp->status1 = 1;
			draw_button( 43, 43, "确定", 1, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );  //打印取消按钮
			break;
		default: break;
		}
	}
}

void modSetMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( 1 == lp->status1 )
	{
		lp->status1 = 0;	// 默认焦点
		systems.mod = systems.old_mod;    // 确认设置模式
		systems.status = STOP;
		systems.percent = 0;
		systems.used_time = 0;
        
        stopPump();
        systems.dynamic_flow = 0;

		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
	else if ( 2 == lp->status1 )	// 取消操作
	{
		lp->status1 = 0;	// 默认焦点
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
}

void modSetMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void modSetMenuExec(void)
{
	static unsigned int old_sec = 0;    // 旧的秒

	switch ( systems.status )
	{
	case SAMPLING:
		if ( old_sec != systems.sys_time.sec )
		{
			old_sec = systems.sys_time.sec;
			systems.start_sec++;     //工作时间加一秒

			systems.percent = systems.used_time * 60;
			systems.percent += systems.start_sec;
			systems.percent = systems.percent / ( systems.cyls.smp_time * 60 );

			if ( systems.percent >= 1 )
			{
				systems.percent = 1;
			}

			if ( systems.start_sec == 60 )     //计满一分钟
			{
				systems.start_sec = 0;
				systems.used_time++;       //已采样时间加1
			}
		}
		break;

	case WAITING:

		if ( old_sec != systems.sys_time.sec )
		{
			old_sec = systems.sys_time.sec;
			if ( systems.wait_sec == 0 )
			{
				systems.wait_sec = 59;
				if ( systems.wait_time == 0 )
				{
					systems.wait_sec = 0;
					systems.status = SAMPLING;         // 进入采样状态
//					start_flu( systems.cyls.flow );   // 启动采样
				}
				else
				{
					systems.wait_time--;       //等待时间自减1
				}
			}
			else
			{
				systems.wait_sec--;
			}
        }
		break;
	}
}


/*
 * 参数设置菜单
 */
void parameterSetMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
	switch ( systems.mod )
	{
	case HAND_MOVE_MODE:
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu;
			win->curfous->show();
		}
		break;
	case TIMING_MODE:
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu->rMenu;
			win->curfous->show();
		}
		break;
	case CIRCLE_MODE:
		if ( lp->subMenu )
		{
//			win->curfous = lp->subMenu->lMenu;
			win->curfous = lp->subMenu->rMenu->rMenu;
			win->curfous->show();
		}
		break;
	default: break;
	}
}


/*
 * 手动模式流量设置菜单
 */
void manuFlowSetMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
	clr_lcd();
	systems.a_flow = systems.manu.flow;	// 设置流量 默认值

	flowSetShow( lp );	// 显示设置流量
}

void manuFlowSetMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;

	flowSetUp( lp );	// 设置流量值
}

void manuFlowSetMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;

	flowSetDown( lp );	// 设置流量值
}

void manuFlowSetMenuOnLeft(void)
{
	struct MENU *lp;
	lp = win->curfous;

	flowSetLeft( lp );	// 设置流量值
}

void manuFlowSetMenuOnRight(void)
{
	struct MENU *lp;
	lp = win->curfous;

	flowSetRight( lp );	// 设置流量值
}

void manuFlowSetMenuOnOk(void)
{
	struct MENU *lp;
	struct MENU *lp_top;
	lp = win->curfous;
	if ( 3 == lp->status1 )	// 获得确定焦点
	{
		if ( systems.a_flow < 40 || systems.a_flow > MAX_FLOW )
		{	// 判断流量是否在40――4000之间(合法流量)
			if ( lp->subMenu )
			{
				win->curfous = lp->subMenu;		// 进入错误警告菜单
				win->curfous->show();
			}
		}
		else
		{
			systems.manu.flow = systems.a_flow;	// 确认设置流量
			systems.a_flow = ORIGIN_FLOW;	// systems.a_flow 复位默认值
            changeFlow( systems.manu.flow );
            
			if ( lp->topMenu )
			{
				win->curfous = lp->topMenu;
				lp_top = win->curfous;
				if ( lp_top->topMenu )
				{
					win->curfous = lp_top->topMenu;
					win->curfous->show();
				}
			}
		}
	}

	if ( 4 == lp->status1 )	// 获得取消焦点
	{
		systems.a_flow = systems.manu.flow;	// 取消设置流量
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			lp_top = win->curfous;
			if ( lp_top->topMenu )
			{
				win->curfous = lp_top->topMenu;
				win->curfous->show();
			}
		}
	}
}

void manuFlowSetMenuOnEsc(void)
{
	struct MENU *lp;
	struct MENU *lp_top;
	lp = win->curfous;

	systems.a_flow = systems.manu.flow;	// 取消设置流量
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		lp_top = win->curfous;
		if ( lp_top->topMenu )
		{
			win->curfous = lp_top->topMenu;
			win->curfous->show();
		}
	}
}

void manuFlowSetMenuExec(void)
{

}



/*
 * 定时模式组设置菜单
 */
void groupSetMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );		// 打印一个像扳手一样的设置图标
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	draw_dialog(1);
	draw_line( 55, 36, 105, 36 ); //打印一条在靠选择栏的直线
	draw_symbol( 43, 23, 12, 12, left_mu, 0 );   //左三角
	draw_symbol( 106, 23, 12, 12, right_mu, 0 );  //右三角
	if ( ENGLISH == systems.language )
	{
		print_str( 47, 3, "Select Group", 0 );
		switch ( lp->status1 )
		{
		case 0:
			print_str( 56, 23, "Group", 1 );
			print_int( 86, 23, lp->status2+1, 1 );    // lp->status2标识被选中的组号
			draw_button( 43, 43, "OK", 0, ENGLISH );
			draw_button( 88, 43, "Exit", 0, ENGLISH );
			break;
		case 1:
			print_str( 56, 23, "Group", 0 );
			print_int( 86, 23, lp->status2+1, 0 );    // lp->status2标识被选中的组号
			draw_button( 43, 43, "OK", 1, ENGLISH );
			draw_button( 88, 43, "Exit", 0, ENGLISH );
			break;
		case 2:
			print_str( 56, 23, "Group", 0 );
			print_int( 86, 23, lp->status2+1, 0 );    // lp->status2标识被选中的组号
			draw_button( 43, 43, "OK", 0, ENGLISH );
			draw_button( 88, 43, "Exit", 1, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		print_ch_str( 40, 3, "请选择设置的组", 0 );
		switch ( lp->status1 )
		{
		case 0:
			print_ch_str( 56, 23, "定时组", 1 );
			print_int( 92, 23, lp->status2+1, 1 );    // lp->status2标识被选中的组号
			draw_button( 43, 43, "确定", 0, CHINESE );
			draw_button( 88, 43, "退出", 0, CHINESE );
			break;
		case 1:
			print_ch_str( 56, 23, "定时组", 0 );
			print_int( 92, 23, lp->status2+1, 0 );    // lp->status2标识被选中的组号
			draw_button( 43, 43, "确定", 1, CHINESE );
			draw_button( 88, 43, "退出", 0, CHINESE );
			break;
		case 2:
			print_ch_str( 56, 23, "定时组", 0 );
			print_int( 92, 23, lp->status2+1, 0 );    // lp->status2标识被选中的组号
			draw_button( 43, 43, "确定", 0, CHINESE );
			draw_button( 88, 43, "退出", 1, CHINESE );
			break;
		default: break;
		}
	}
}

void groupSetMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			print_str( 56, 23, "Group", 0 );
			print_int( 86, 23, lp->status2+1, 0 );
			draw_button( 43, 43, "OK", 1, ENGLISH );
			break;
		case 1:
			lp->status1 = 0;
			print_str( 56, 23, "Group", 1 );
			print_int( 86, 23, lp->status2+1, 1 );
			draw_button( 43, 43, "OK", 0, ENGLISH );
			break;
		case 2:
			lp->status1 = 0;
			print_str( 56, 23, "Group", 1 );
			print_int( 86, 23, lp->status2+1, 1 );
			draw_button( 88, 43, "Exit", 0, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			print_ch_str( 56, 23, "定时组", 0 );
			print_int( 92, 23, lp->status2+1, 0 );
			draw_button( 43, 43, "确定", 1, CHINESE );
			break;
		case 1:
			lp->status1 = 0;
			print_ch_str( 56, 23, "定时组", 1 );
			print_int( 92, 23, lp->status2+1, 1 );
			draw_button( 43, 43, "确定", 0, CHINESE );
			break;
		case 2:
			lp->status1 = 0;
			print_ch_str( 56, 23, "定时组", 1 );
			print_int( 92, 23, lp->status2+1, 1 );
			draw_button( 88, 43, "退出", 0, CHINESE );
			break;
		default: break;
		}
	}
}

void groupSetMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			print_str( 56, 23, "Group", 0 );
			print_int( 86, 23, lp->status2+1, 0 );
			draw_button( 43, 43, "OK", 1, ENGLISH );
			break;
		case 1:
			lp->status1 = 0;
			print_str( 56, 23, "Group", 1 );
			print_int( 86, 23, lp->status2+1, 1 );
			draw_button( 43, 43, "OK", 0, ENGLISH );
			break;
		case 2:
			lp->status1 = 0;
			print_str( 56, 23, "Group", 1 );
			print_int( 86, 23, lp->status2+1, 1 );
			draw_button( 88, 43, "Exit", 0, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			print_ch_str( 56, 23, "定时组", 0 );
			print_int( 92, 23, lp->status2+1, 0 );
			draw_button( 43, 43, "确定", 1, CHINESE );
			break;
		case 1:
			lp->status1 = 0;
			print_ch_str( 56, 23, "定时组", 1 );
			print_int( 92, 23, lp->status2+1, 1 );
			draw_button( 43, 43, "确定", 0, CHINESE );
			break;
		case 2:
			lp->status1 = 0;
			print_ch_str( 56, 23, "定时组", 1 );
			print_int( 92, 23, lp->status2+1, 1 );
			draw_button( 88, 43, "退出", 0, CHINESE );
			break;
		default: break;
		}
	}
}

void groupSetMenuOnLeft(void)
{
	struct MENU *lp;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		if ( 0 == lp->status2 )
		{
			lp->status2 = 9;
		}
		else
		{
			lp->status2--;
		}
		if ( ENGLISH == systems.language )
		{
			print_str( 56, 23, "Group", 1 );
			clr_rect( 86, 23, 12, 12 );
			print_int( 86, 23, lp->status2+1, 1 );    // lp->status2标识被选中的组号
		}
		else
		{
			print_ch_str( 56, 23, "定时组", 1 );
			clr_rect( 92, 23, 12, 12 );
			print_int( 92, 23, lp->status2+1, 1 );    // lp->status2标识被选中的组号
		}
		break;
	case 1:
		lp->status1 = 2;
		if ( ENGLISH == systems.language )
		{
			draw_button( 43, 43, "OK", 0, ENGLISH );
			draw_button( 88, 43, "Exit", 1, ENGLISH );
		}
		else
		{
			draw_button( 43, 43, "确定", 0, CHINESE );
			draw_button( 88, 43, "退出", 1, CHINESE );
		}
		break;
	case 2:
		lp->status1 = 1;
		if ( ENGLISH == systems.language )
		{
			draw_button( 43, 43, "OK", 1, ENGLISH );
			draw_button( 88, 43, "Exit", 0, ENGLISH );
		}
		else
		{
			draw_button( 43, 43, "确定", 1, CHINESE );
			draw_button( 88, 43, "退出", 0, CHINESE );
		}
		break;
	default: break;
	}
}

void groupSetMenuOnRight(void)
{
	struct MENU *lp;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		if ( 9 == lp->status2 )
		{
			lp->status2 = 0;
		}
		else
		{
			lp->status2++;
		}

		if ( ENGLISH == systems.language )
		{
			print_str( 56, 23, "Group", 1 );
			clr_rect( 86, 23, 12, 12 );
			print_int( 86, 23, lp->status2+1, 1 );    // lp->status2标识被选中的组号
		}
		else
		{
			print_ch_str( 56, 23, "定时组", 1 );
			clr_rect( 92, 23, 12, 12 );
			print_int( 92, 23, lp->status2+1, 1 );    // lp->status2标识被选中的组号
		}
		break;
	case 1:
		lp->status1 = 2;
		if ( ENGLISH == systems.language )
		{
			draw_button( 43, 43, "OK", 0, ENGLISH );
			draw_button( 88, 43, "Exit", 1, ENGLISH );
		}
		else
		{
			draw_button( 43, 43, "确定", 0, CHINESE );
			draw_button( 88, 43, "退出", 1, CHINESE );
		}
		break;
	case 2:
		lp->status1 = 1;
		if ( ENGLISH == systems.language )
		{
			draw_button( 43, 43, "OK", 1, ENGLISH );
			draw_button( 88, 43, "Exit", 0, ENGLISH );
		}
		else
		{
			draw_button( 43, 43, "确定", 1, CHINESE );
			draw_button( 88, 43, "退出", 0, CHINESE );
		}
		break;
	default: break;
	}
}

void groupSetMenuOnOk(void)
{
	struct MENU *lp;
	struct MENU *top_lp;
	lp = win->curfous;

	switch ( lp->status1 )
	{
	case 0:			// 当前焦点为“选择组”
		break;
	case 1:			// 当前焦点为“确定”
		if ( lp->subMenu )
		{
			lp->status1 = 0; 	// 恢复默认焦点
			systems.set_group = lp->status2;	// 确认设置的工作组
			win->curfous = lp->subMenu;		// 进入各个组菜单参数设置菜单
			win->curfous->show();
		}
		break;
	case 2:			// 当前焦点为“取消”
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			top_lp = win->curfous;
			if ( top_lp->topMenu )
			{
				win->curfous = top_lp->topMenu;		// 返回上层菜单
				win->curfous->show();
			}
		}
		break;
	default: break;
	}
}

void groupSetMenuOnEsc(void)
{
	struct MENU *lp;
	struct MENU *top_lp;
	lp = win->curfous;

	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		top_lp = win->curfous;
		if ( top_lp->topMenu )
		{
			win->curfous = top_lp->topMenu;
			win->curfous->show();
		}
	}
}

void groupSetMenuExec(void)
{

}



/*
 * 定时模式定时组参数设置菜单
 */
void groupParaSetMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );		// 打印一个像扳手一样的设置图标
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	draw_dialog(1);
    draw_symbol( 118, 18, 6, 3, gundong_up_mu, 0 );    //画上三角图标
    draw_symbol( 118, 59, 6, 3, gundong_down_mu, 0 );  //画下三角图标

    fill_rect( 118, 22, 6, 36 );   // 填充滚动条
    clr_rect( 119, 24+lp->status2*8, 4, 8 );       // 清空滚动条滚动粒所来位置处

    if ( ENGLISH == systems.language )
	{
		print_str( 42, 3, "Groups   Para", 0 );
		print_int( 85, 3, systems.set_group + 1, 0 );
		switch ( lp->status1 )
		{
		case 0:
			if ( 0 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_str( 38, 19, "Work Time", 1 );
				print_str( 38, 34, "Flow", 0 );
				print_str( 38, 49, "ON", 0 );
				group_status_set( 38, 49 );
			}
			else if ( 1 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_str( 38, 19, "Flow", 1 );
				print_str( 38, 34, "ON", 0 );
				group_status_set( 38, 34 );
				print_str( 38, 49, "Exit", 0 );
			}
			break;
		case 1:
			if ( 1 == lp->status2 )
			{
				print_str( 38, 19, "Work Time", 0 );
				fill_rect( 36, 33, 76, 14 );
				print_str( 38, 34, "Flow", 1 );
				print_str( 38, 49, "ON", 0 );
				group_status_set( 38, 49 );
			}
			else if ( 2 == lp->status2 )
			{
				print_str( 38, 19, "Flow", 0 );
				fill_rect( 36, 33, 76, 14 );
				print_str( 38, 34, "ON", 1 );
				group_status_set( 38, 34 );
				print_str( 38, 49, "Exit", 0 );
			}
			break;
		case 2:
			if ( 2 == lp->status2 )
			{
				print_str( 38, 19, "Work Time", 0 );
				print_str( 38, 34, "Flow", 0 );
				fill_rect( 36, 48, 76, 14 );
				print_str( 38, 49, "ON", 1 );
				group_status_set( 38, 49 );
			}
			else if ( 3 == lp->status2 )
			{
				print_str( 38, 19, "Flow", 0 );
				print_str( 38, 34, "ON", 0 );
				group_status_set( 38, 34 );
				fill_rect( 36, 48, 76, 14 );
				print_str( 38, 49, "Exit", 1 );
			}
			break;
		default: break;
		}
	}
	else
	{
		print_ch_str( 43, 3, "定时组", 0 );
		print_ch_str( 97, 3, "参数", 0 );
		print_int( 85, 3, systems.set_group + 1, 0 );
		switch ( lp->status1 )
		{
		case 0:
			if ( 0 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_ch_str( 38, 19, "工作时间", 1 );
				print_ch_str( 38, 34, "流量设置", 0 );
				print_ch_str( 38, 49, "启用", 0 );
				group_status_set( 38, 49 );
			}
			else if ( 1 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_ch_str( 38, 19, "流量设置", 1 );
				print_ch_str( 38, 34, "启用", 0 );
				group_status_set( 38, 34 );
				print_ch_str( 38, 49, "退出", 0 );
			}
			break;
		case 1:
			if ( 1 == lp->status2 )
			{
				print_ch_str( 38, 19, "工作时间", 0 );
				fill_rect( 36, 33, 76, 14 );
				print_ch_str( 38, 34, "流量设置", 1 );
				print_ch_str( 38, 49, "启用", 0 );
				group_status_set( 38, 49 );
			}
			else if ( 2 == lp->status2 )
			{
				print_ch_str( 38, 19, "流量设置", 0 );
				fill_rect( 36, 33, 76, 14 );
				print_ch_str( 38, 34, "启用", 1 );
				group_status_set( 38, 34 );
				print_ch_str( 38, 49, "退出", 0 );
			}
			break;
		case 2:
			if ( 2 == lp->status2 )
			{
				print_ch_str( 38, 19, "工作时间", 0 );
				print_ch_str( 38, 34, "流量设置", 0 );
				fill_rect( 36, 48, 76, 14 );
				print_ch_str( 38, 49, "启用", 1 );
				group_status_set( 38, 49 );
			}
			else if ( 3 == lp->status2 )
			{
				print_ch_str( 38, 19, "流量设置", 0 );
				print_ch_str( 38, 34, "启用", 0 );
				group_status_set( 38, 34 );
				fill_rect( 36, 48, 76, 14 );
				print_ch_str( 38, 49, "退出", 1 );
			}
			break;
		default: break;
		}
	}
}

void groupParaSetMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;

    fill_rect( 118, 22, 6, 36 );   // 填充滚动条
    if ( 0 == lp->status2 )
    {
    	lp->status2 = 3;
    }
    else
    {
    	lp->status2--;
    }
    clr_rect( 119, 24+lp->status2*8, 4, 8 );       // 清空滚动条滚动粒所来位置处
    clr_rect( 36, 18, 76, 44 );		// 清空显示选择区
    if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			if ( 0 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_str( 38, 19, "Work Time", 1 );
				print_str( 38, 34, "Flow", 0 );
				print_str( 38, 49, "ON", 0 );
				group_status_set( 38, 49 );
			}
			else if ( 3 == lp->status2 )
			{
				lp->status1 = 2;
				print_str( 38, 19, "Flow", 0 );
				print_str( 38, 34, "ON", 0 );
				group_status_set( 38, 34 );
				fill_rect( 36, 48, 76, 14 );
				print_str( 38, 49, "Exit", 1 );
			}
			break;
		case 1:
			lp->status1 = 0;
			if ( 0 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_str( 38, 19, "Work Time", 1 );
				print_str( 38, 34, "Flow", 0 );
				print_str( 38, 49, "ON", 0 );
				group_status_set( 38, 49 );
			}
			else if ( 1 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_str( 38, 19, "Flow", 1 );
				print_str( 38, 34, "ON", 0 );
				group_status_set( 38, 34 );
				print_str( 38, 49, "Exit", 0 );
			}
			break;
		case 2:
			lp->status1 = 1;
			if ( 1 == lp->status2 )
			{
				print_str( 38, 19, "Work Time", 0 );
				fill_rect( 36, 33, 76, 14 );
				print_str( 38, 34, "Flow", 1 );
				print_str( 38, 49, "ON", 0 );
				group_status_set( 38, 49 );
			}
			else if ( 2 == lp->status2 )
			{
				print_str( 38, 19, "Flow", 0 );
				fill_rect( 36, 33, 76, 14 );
				print_str( 38, 34, "ON", 1 );
				group_status_set( 38, 34 );
				print_str( 38, 49, "Exit", 0 );
			}
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			if ( 0 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_ch_str( 38, 19, "工作时间", 1 );
				print_ch_str( 38, 34, "流量设置", 0 );
				print_ch_str( 38, 49, "启用", 0 );
				group_status_set( 38, 49 );
			}
			else if ( 3 == lp->status2 )
			{
				lp->status1 = 2;
				print_ch_str( 38, 19, "流量设置", 0 );
				print_ch_str( 38, 34, "启用", 0 );
				group_status_set( 38, 34 );
				fill_rect( 36, 48, 76, 14 );
				print_ch_str( 38, 49, "退出", 1 );
			}
			break;
		case 1:
			lp->status1 = 0;
			if ( 0 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_ch_str( 38, 19, "工作时间", 1 );
				print_ch_str( 38, 34, "流量设置", 0 );
				print_ch_str( 38, 49, "启用", 0 );
				group_status_set( 38, 49 );
			}
			else if ( 1 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_ch_str( 38, 19, "流量设置", 1 );
				print_ch_str( 38, 34, "启用", 0 );
				group_status_set( 38, 34 );
				print_ch_str( 38, 49, "退出", 0 );
			}
			break;
		case 2:
			lp->status1 = 1;
			if ( 1 == lp->status2 )
			{
				print_ch_str( 38, 19, "工作时间", 0 );
				fill_rect( 36, 33, 76, 14 );
				print_ch_str( 38, 34, "流量设置", 1 );
				print_ch_str( 38, 49, "启用", 0 );
				//group_status_set();
			}
			else if ( 2 == lp->status2 )
			{
				print_ch_str( 38, 19, "流量设置", 0 );
				fill_rect( 36, 33, 76, 14 );
				print_ch_str( 38, 34, "启用", 1 );
				group_status_set( 38, 34 );
				print_ch_str( 38, 49, "退出", 0 );
			}
			break;
		default: break;
		}
	}
}

void groupParaSetMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;
    fill_rect( 118, 22, 6, 36 );   // 填充滚动条
    if ( 3 == lp->status2 )
    {
    	lp->status2 = 0;
    }
    else
    {
    	lp->status2++;
    }
    clr_rect( 119, 24+lp->status2*8, 4, 8 );       // 清空滚动条滚动粒所来位置处
    clr_rect( 36, 18, 76, 44 );		// 清空显示选择区

	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			if ( 1 == lp->status2 )
			{
				print_str( 38, 19, "Work Time", 0 );
				fill_rect( 36, 33, 76, 14 );
				print_str( 38, 34, "Flow", 1 );
				print_str( 38, 49, "ON", 0 );
				group_status_set( 38, 49 );
			}
			else if ( 2 == lp->status2 )
			{
				print_str( 38, 19, "Flow", 0 );
				fill_rect( 36, 33, 76, 14 );
				print_str( 38, 34, "ON", 1 );
				group_status_set( 38, 34 );
				print_str( 38, 49, "Exit", 0 );
			}
			break;
		case 1:
			lp->status1 = 2;
			if ( 2 == lp->status2 )
			{
				print_str( 38, 19, "Work Time", 0 );
				print_str( 38, 34, "Flow", 0 );
				fill_rect( 36, 48, 76, 14 );
				print_str( 38, 49, "ON", 1 );
				group_status_set( 38, 49 );
			}
			else if ( 3 == lp->status2 )
			{
				print_str( 38, 19, "Flow", 0 );
				print_str( 38, 34, "ON", 0 );
				group_status_set( 38, 34 );
				fill_rect( 36, 48, 76, 14 );
				print_str( 38, 49, "Exit", 1 );
			}
			break;
		case 2:
			if ( 3 == lp->status2 )
			{
				print_str( 38, 19, "Flow", 0 );
				print_str( 38, 34, "ON", 0 );
				group_status_set( 38, 34 );
				fill_rect( 36, 48, 76, 14 );
				print_str( 38, 49, "Exit", 1 );
			}
			if ( 0 == lp->status2 )
			{
				lp->status1 = 0;
				fill_rect( 36, 18, 76, 14 );
				print_str( 38, 19, "Work Time", 1 );
				print_str( 38, 34, "Flow", 0 );
				print_str( 38, 49, "ON", 0 );
				group_status_set( 38, 49 );
			}
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			if ( 1 == lp->status2 )
			{
				print_ch_str( 38, 19, "工作时间", 0 );
				fill_rect( 36, 33, 76, 14 );
				print_ch_str( 38, 34, "流量设置", 1 );
				print_ch_str( 38, 49, "启用", 0 );
				group_status_set( 38, 49 );
			}
			else if ( 2 == lp->status2 )
			{
				print_ch_str( 38, 19, "流量设置", 0 );
				fill_rect( 36, 33, 76, 14 );
				print_ch_str( 38, 34, "启用", 1 );
				group_status_set( 38, 34 );
				print_ch_str( 38, 49, "退出", 0 );
			}
			break;
		case 1:
			lp->status1 = 2;
			if ( 2 == lp->status2 )
			{
				print_ch_str( 38, 19, "工作时间", 0 );
				print_ch_str( 38, 34, "流量设置", 0 );
				fill_rect( 36, 48, 76, 14 );
				print_ch_str( 38, 49, "启用", 1 );
				group_status_set( 38, 49 );
			}
			else if ( 3 == lp->status2 )
			{
				print_ch_str( 38, 19, "流量设置", 0 );
				print_ch_str( 38, 34, "启用", 0 );
				group_status_set( 38, 34 );
				fill_rect( 36, 48, 76, 14 );
				print_ch_str( 38, 49, "退出", 1 );
			}
			break;
		case 2:
			if ( 3 == lp->status2 )
			{
				print_ch_str( 38, 19, "流量设置", 0 );
				print_ch_str( 38, 34, "启用", 0 );
				group_status_set( 38, 34 );
				fill_rect( 36, 48, 76, 14 );
				print_ch_str( 38, 49, "退出", 1 );
			}
			if ( 0 == lp->status2 )
			{
				lp->status1 = 0;
				fill_rect( 36, 18, 76, 14 );
				print_ch_str( 38, 19, "工作时间", 1 );
				print_ch_str( 38, 34, "流量设置", 0 );
				print_ch_str( 38, 49, "启用", 0 );
				group_status_set( 38, 49 );
			}
			break;
		default: break;
		}
	}
}

void groupParaSetMenuOnLeft(void)
{
}

void groupParaSetMenuOnRight(void)
{
}

void groupParaSetMenuOnOk(void)
{
	struct MENU *lp;
	int index;		// 索引组号
	unsigned int set_group_start_time;		// 当前组采样启动时间(min)
	unsigned int set_group_complete_time;	// 当前组采样完成时间(min)
	unsigned int index_group_start_time;	// 索引组采样启动时间(min)
	unsigned int index_group_complete_time;	// 索引组采样完成时间(min)
	unsigned char flag = 0;				// 冲突标志
	lp = win->curfous;
	switch ( lp->status2 )
	{
	case 0:					// 获得“工作时间”焦点
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu;
			win->curfous->show();
		}
		break;
	case 1:					// 获得“流量设置”焦点
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu->rMenu;
			win->curfous->show();
		}
		break;
	case 2:					// 获得“启用”焦点
		if ( 0 == systems.groups[systems.set_group].srb )	// 判断当前组是否已经启用
		{
			// 计算当前组采样开始时间(min)
			set_group_start_time = systems.groups[systems.set_group].start_time.hour * 60
								+ systems.groups[systems.set_group].start_time.min;

			// 计算当前组采样完成时间(min)
			set_group_complete_time = systems.groups[systems.set_group].start_time.hour * 60
								   + systems.groups[systems.set_group].start_time.min
								   + systems.groups[systems.set_group].smp_time;

			for ( index=0; /*systems.set_group != index
							&&*/ index < GROUP_NUM; index++ )
			{
                if ( systems.set_group == index ) continue; //不能够和自己比较
				// 计算索引组采样开始时间(min)
				index_group_start_time = systems.groups[index].start_time.hour * 60
								+ systems.groups[index].start_time.min;

				// 计算索引组采样完成时间(min)
				index_group_complete_time = systems.groups[index].start_time.hour * 60
								+ systems.groups[index].start_time.min
								+ systems.groups[index].smp_time;

				// 判断当前组于其他的组是否有冲突
				if ( (( set_group_start_time <= index_group_start_time
					      && set_group_complete_time >= index_group_start_time )
                     || ( set_group_start_time >= index_group_start_time
					      && set_group_start_time <= index_group_complete_time ) )
					 && 1 == systems.groups[index].srb )
				{	// 发生冲突
					flag = 1;
					systems.err_group_num = index;		// 保存冲突组号
					break;
				}
			}
			if ( 1 == flag )	// 发生冲突
			{
				if ( lp->subMenu )
				{
					win->curfous = lp->subMenu->rMenu->rMenu;
					win->curfous->show();
				}
			}
			else	// 没有组发生冲突
			{
				systems.groups[systems.set_group].srb = 1;	// 启用改组
				if ( 1 == lp->status1 )		// 确定打印位置
				{
					draw_symbol( 38+61, 34+1, 10, 10, gou_mu, 0 );
				}
				else if ( 2 == lp->status1 )		// 确定打印位置
				{
					draw_symbol( 38+61, 49+1, 10, 10, gou_mu, 0 );
				}
			}
		}
		else		// 当前组已经启用
		{
			systems.groups[systems.set_group].srb = 0;	// 将当前组设置为“未启用”
			if ( 1 == lp->status1 )		// 确定打印位置
			{
				clr_rect( 38+60, 34, 12, 12 );
				draw_rect( 38+60, 34, 12, 12 );
			}
			else if ( 2 == lp->status1 )		// 确定打印位置
			{
				clr_rect( 38+60, 49, 12, 12 );
				draw_rect( 38+60, 49, 12, 12 );
			}
		}
		break;
	case 3:					// 获得“退出”焦点
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
		break;
	default: break;
	}
}

void groupParaSetMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void groupParaSetMenuExec(void)
{

}




/*
 * 定时模式定时组工作时间设置菜单
 */
void groupWorkTimeSetMenuShow(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;		// 设置采样时长的百位十位个位

	lp = win->curfous;

	// 获取默认设置值
	systems.temp_hour = systems.groups[systems.set_group].start_time.hour;
	systems.temp_min = systems.groups[systems.set_group].start_time.min;
	if ( systems.groups[systems.set_group].smp_time )
	{
		systems.a_min = systems.groups[systems.set_group].smp_time;
	}
	else
	{
		systems.a_min = 10;
	}

	bai = (unsigned int)(systems.a_min / 100);
	shi = (unsigned int)(systems.a_min %100 / 10);
	ge = (unsigned int)(systems.a_min % 10);

	clr_lcd();
	draw_rect( 0, 0, 127, 63 );
	draw_line( 20, 15, 107, 15 );
	if ( ENGLISH == systems.language )
	{
		print_str( 30, 3, "Set Work Time", 0 );
		putchar( 70, 17, ':', 0 );
		putchar( 70, 31, ':', 0 );
		print_str( 100, 31, "min", 0 );
		switch ( lp->status1 )
		{
		case 0:
			print_str( 10, 17, "Start Time", 1 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR_MIN );
			print_str( 22, 31, "SMP Time", 0 );
            putchar( 76, 31, bai+'0', 0 );
            putchar( 84, 31, shi+'0', 0 );
            putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "Ok", 0, ENGLISH );     //打印"确定"按钮
			draw_button( 81, 45, "Esc", 0, ENGLISH );    //打印"取消"按钮
			break;
		case 1:
			print_str( 10, 17, "Start Time", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR );
			print_str( 22, 31, "SMP Time", 0 );
            putchar( 76, 31, bai+'0', 0 );
            putchar( 84, 31, shi+'0', 0 );
            putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "Ok", 0, ENGLISH );     //打印"确定"按钮
			draw_button( 81, 45, "Esc", 0, ENGLISH );    //打印"取消"按钮
			break;
		case 2:
			print_str( 10, 17, "Start Time", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, MIN );
			print_str( 22, 31, "SMP Time", 0 );
            putchar( 76, 31, bai+'0', 1 );
            putchar( 84, 31, shi+'0', 0 );
            putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "Ok", 0, ENGLISH );     //打印"确定"按钮
			draw_button( 81, 45, "Esc", 0, ENGLISH );    //打印"取消"按钮
			break;
		case 3:
			print_str( 10, 17, "Start Time", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR_MIN );
			print_str( 22, 31, "SMP Time", 1 );
            putchar( 76, 31, bai+'0', 0 );
            putchar( 84, 31, shi+'0', 0 );
            putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "Ok", 0, ENGLISH );     //打印"确定"按钮
			draw_button( 81, 45, "Esc", 0, ENGLISH );    //打印"取消"按钮
			break;
		case 4:
			print_str( 10, 17, "Start Time", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR_MIN );
			print_str( 22, 31, "SMP Time", 0 );
            putchar( 76, 31, bai+'0', 1 );
            putchar( 84, 31, shi+'0', 0 );
            putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "Ok", 0, ENGLISH );     //打印"确定"按钮
			draw_button( 81, 45, "Esc", 0, ENGLISH );    //打印"取消"按钮
			break;
		case 5:
			print_str( 10, 17, "Start Time", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR_MIN );
			print_str( 22, 31, "SMP Time", 0 );
            putchar( 76, 31, bai+'0', 0 );
            putchar( 84, 31, shi+'0', 1 );
            putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "Ok", 0, ENGLISH );     //打印"确定"按钮
			draw_button( 81, 45, "Esc", 0, ENGLISH );    //打印"取消"按钮
			break;
		case 6:
			print_str( 10, 17, "Start Time", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR_MIN );
			print_str( 22, 31, "SMP Time", 0 );
            putchar( 76, 31, bai+'0', 0 );
            putchar( 84, 31, shi+'0', 0 );
            putchar( 92, 31, ge+'0', 1 );
			draw_button( 15, 45, "Ok", 0, ENGLISH );     //打印"确定"按钮
			draw_button( 81, 45, "Esc", 0, ENGLISH );    //打印"取消"按钮
			break;
		case 7:
			print_str( 10, 17, "Start Time", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR_MIN );
			print_str( 22, 31, "SMP Time", 0 );
            putchar( 76, 31, bai+'0', 0 );
            putchar( 84, 31, shi+'0', 0 );
            putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "Ok", 1, ENGLISH );     //打印"确定"按钮
			draw_button( 81, 45, "Esc", 0, ENGLISH );    //打印"取消"按钮
			break;
		case 8:
			print_str( 10, 17, "Start Time", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR_MIN );
			print_str( 22, 31, "SMP Time", 0 );
            putchar( 76, 31, bai+'0', 0 );
            putchar( 84, 31, shi+'0', 0 );
            putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "Ok", 0, ENGLISH );     //打印"确定"按钮
			draw_button( 81, 45, "Esc", 1, ENGLISH );    //打印"取消"按钮
			break;
		default: break;
		}
	}
	else
	{
		print_ch_str( 28, 3, "工作时间设置", 0 );
		putchar( 68, 31, ':', 0 );
		putchar( 68, 17, ':', 0 );
		print_str( 100, 31, "min", 0 );
		switch ( lp->status1 )
		{
		case 0:		// 启动时间文本获得焦点
			print_ch_str( 20, 17, "启动时间", 1 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR_MIN );
			print_ch_str( 20, 31, "采样时长", 0 );
			putchar( 76, 31, bai+'0', 0 );
			putchar( 84, 31, shi+'0', 0 );
			putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "确定", 0, CHINESE );
			draw_button( 81, 45, "取消", 0, CHINESE );
			break;
		case 1:		// 启动时间的时获得焦点
			print_ch_str( 20, 17, "启动时间", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR );
			print_ch_str( 20, 31, "采样时长", 0 );
			putchar( 76, 31, bai+'0', 0 );
			putchar( 84, 31, shi+'0', 0 );
			putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "确定", 0, CHINESE );
			draw_button( 81, 45, "取消", 0, CHINESE );
			break;
		case 2:		// 启动时间的分获得焦点
			print_ch_str( 20, 17, "启动时间", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, MIN );
			print_ch_str( 20, 31, "采样时长", 0 );
			putchar( 76, 31, bai+'0', 0 );
			putchar( 84, 31, shi+'0', 0 );
			putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "确定", 0, CHINESE );
			draw_button( 81, 45, "取消", 0, CHINESE );
			break;
		case 3:		// 采样时长文本获得焦点
			print_ch_str( 20, 17, "启动时间", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR_MIN );
			print_ch_str( 20, 31, "采样时长", 1 );
			putchar( 76, 31, bai+'0', 0 );
			putchar( 84, 31, shi+'0', 0 );
			putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "确定", 0, CHINESE );
			draw_button( 81, 45, "取消", 0, CHINESE );
			break;
		case 4:		// 采样时长百位获得焦点
			print_ch_str( 20, 17, "启动时间", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR_MIN );
			print_ch_str( 20, 31, "采样时长", 0 );
			putchar( 76, 31, bai+'0', 1 );
			putchar( 84, 31, shi+'0', 0 );
			putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "确定", 0, CHINESE );
			draw_button( 81, 45, "取消", 0, CHINESE );
			break;
		case 5:		// 采样时长十位获得焦点
			print_ch_str( 20, 17, "启动时间", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR_MIN );
			print_ch_str( 20, 31, "采样时长", 0 );
			putchar( 76, 31, bai+'0', 0 );
			putchar( 84, 31, shi+'0', 1 );
			putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "确定", 0, CHINESE );
			draw_button( 81, 45, "取消", 0, CHINESE );
			break;
		case 6:		// 采样时长个位获得焦点
			print_ch_str( 20, 17, "启动时间", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR_MIN );
			print_ch_str( 20, 31, "采样时长", 0 );
			putchar( 76, 31, bai+'0', 0 );
			putchar( 84, 31, shi+'0', 0 );
			putchar( 92, 31, ge+'0', 1 );
			draw_button( 15, 45, "确定", 0, CHINESE );
			draw_button( 81, 45, "取消", 0, CHINESE );
			break;
		case 7:		// 确定按钮获得焦点
			print_ch_str( 20, 17, "启动时间", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR_MIN );
			print_ch_str( 20, 31, "采样时长", 0 );
			putchar( 76, 31, bai+'0', 0 );
			putchar( 84, 31, shi+'0', 0 );
			putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "确定", 1, CHINESE );
			draw_button( 81, 45, "取消", 0, CHINESE );
			break;
		case 8:		// 取消按钮获得焦点
			print_ch_str( 20, 17, "启动时间", 0 );
			print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR_MIN );
			print_ch_str( 20, 31, "采样时长", 0 );
			putchar( 76, 31, bai+'0', 0 );
			putchar( 84, 31, shi+'0', 0 );
			putchar( 92, 31, ge+'0', 0 );
			draw_button( 15, 45, "确定", 0, CHINESE );
			draw_button( 81, 45, "取消", 1, CHINESE );
			break;
		default: break;
		}
	}
}

void groupWorkTimeSetMenuOnUp(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;		// 设置采样时长的百位十位个位

	lp = win->curfous;

	switch ( lp->status1 )
	{
	case 0:		// 启动时间文本获得焦点
		lp->status1 = 7;
		if ( ENGLISH == systems.language )
		{
			print_str( 10, 17, "Start Time", 0 );
			draw_button( 15, 45, "Ok", 1, ENGLISH );
		}
		else
		{
			print_ch_str( 20, 17, "启动时间", 0 );
			draw_button( 15, 45, "确定", 1, CHINESE );
		}
		break;
	case 1:		// 启动时间的时获得焦点
		if ( systems.temp_hour >= 23 )
		{
			systems.temp_hour = 0;
		}
		else
		{
			systems.temp_hour++;
		}
		print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR );
		break;
	case 2:		// 启动时间的分获得焦点
		if ( 59 == systems.temp_min )
		{
			systems.temp_min = 0;
		}
		else
		{
			systems.temp_min++;
		}
		print_time( systems.temp_hour, systems.temp_min, 76, 17, MIN );
		break;
	case 3:		// 采样时长文本获得焦点
		lp->status1 = 0;
		if ( ENGLISH == systems.language )
		{
			print_str( 10, 17, "Start Time", 1 );
			print_str( 22, 31, "SMP Time", 0 );
		}
		else
		{
			print_ch_str( 20, 17, "启动时间", 1 );
			print_ch_str( 20, 31, "采样时长", 0 );
		}
		break;
	case 4:		// 采样时长百位获得焦点
		bai = (unsigned int)( systems.a_min / 100 );
		systems.a_min -= bai * 100;
		if ( bai == 9 )
		{
			bai = 0;
		}
		else
		{
			bai++;
		}
		systems.a_min += bai * 100;
		putchar( 76, 31, bai+'0', 1 );    // 刷新百位上的值
		break;
	case 5:		// 采样时长十位获得焦点
		shi = (unsigned int)( systems.a_min % 100 / 10 );
		systems.a_min -= shi * 10;
		if ( shi == 9 )
		{
			shi = 0;
		}
		else
		{
			shi++;
		}
		systems.a_min += shi * 10;
		putchar( 84, 31, shi+'0', 1 );
		break;
	case 6:		// 采样时长个位获得焦点
		ge = (unsigned int)( systems.a_min % 10 );
		systems.a_min -= ge;
		if ( ge == 9 )
		{
			ge = 0;
		}
		else
		{
			ge++;
		}
		systems.a_min += ge;
		putchar( 92, 31, ge+'0', 1 );
		break;
	case 7:		// 确定按钮获得焦点
		lp->status1 = 3;
		if ( ENGLISH == systems.language )
		{
			print_str( 22, 31, "SMP Time", 1 );
			draw_button( 15, 45, "Ok", 0, ENGLISH );
		}
		else
		{
			print_ch_str( 20, 31, "采样时长", 1 );
			draw_button( 15, 45, "确定", 0, CHINESE );
		}
		break;
	case 8:		// 取消按钮获得焦点
		break;
	default: break;
	}
}

void groupWorkTimeSetMenuOnDown(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;		// 设置采样时长的百位十位个位

	lp = win->curfous;

	switch ( lp->status1 )
	{
	case 0:		// 启动时间文本获得焦点
		lp->status1 = 3;
		if ( ENGLISH == systems.language )
		{
			print_str( 10, 17, "Start Time", 0 );
			print_str( 22, 31, "SMP Time", 1 );
		}
		else
		{
			print_ch_str( 20, 17, "启动时间", 0 );
			print_ch_str( 20, 31, "采样时长", 1 );
		}
		break;
	case 1:		// 启动时间的时获得焦点
		if ( 0 == systems.temp_hour )
		{
			systems.temp_hour = 23;
		}
		else
		{
			systems.temp_hour--;
		}
		print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR );
		break;
	case 2:		// 启动时间的分获得焦点
		if ( 0 == systems.temp_min )
		{
			systems.temp_min = 59;
		}
		else
		{
			systems.temp_min--;
		}
		print_time( systems.temp_hour, systems.temp_min, 76, 17, MIN );
		break;
	case 3:		// 采样时长文本获得焦点
		lp->status1 = 7;
		if ( ENGLISH == systems.language )
		{
			print_str( 22, 31, "SMP Time", 0 );
			draw_button( 15, 45, "Ok", 1, ENGLISH );
		}
		else
		{
			print_ch_str( 20, 31, "采样时长", 0 );
			draw_button( 15, 45, "确定", 1, CHINESE );
		}
		break;
	case 4:		// 采样时长百位获得焦点
		bai = (unsigned int)( systems.a_min / 100 );
		systems.a_min -= bai * 100;
		if ( bai == 0 )
		{
			bai = 9;
		}
		else
		{
			bai--;
		}
		systems.a_min += bai * 100;
		putchar( 76, 31, bai+'0', 1 );    // 刷新百位上的值
		break;
	case 5:		// 采样时长十位获得焦点
		shi = (unsigned int)( systems.a_min % 100 / 10 );
		systems.a_min -= shi * 10;
		if ( shi == 0 )
		{
			shi = 9;
		}
		else
		{
			shi--;
		}
		systems.a_min += shi * 10;
		putchar( 84, 31, shi+'0', 1 );
		break;
	case 6:		// 采样时长个位获得焦点
		ge = (unsigned int)( systems.a_min % 10 );
		systems.a_min -= ge;
		if ( ge == 0 )
		{
			ge = 9;
		}
		else
		{
			ge--;
		}
		systems.a_min += ge;
		putchar( 92, 31, ge+'0', 1 );
		break;
	case 7:		// 确定按钮获得焦点
		lp->status1 = 0;
		if ( ENGLISH == systems.language )
		{
			print_str( 10, 17, "Start Time", 1 );
			draw_button( 15, 45, "Ok", 0, ENGLISH );
		}
		else
		{
			print_ch_str( 20, 17, "启动时间", 1 );
			draw_button( 15, 45, "确定", 0, CHINESE );
		}
		break;
	case 8:		// 取消按钮获得焦点
		break;
	default: break;
	}
}

void groupWorkTimeSetMenuOnLeft(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;

	lp = win->curfous;

	switch ( lp->status1 )
	{
	case 1:
		lp->status1 = 0;
		print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR_MIN );
		if ( ENGLISH == systems.language )
		{
			print_str( 10, 17, "Start Time", 1 );
		}
		else
		{
			print_ch_str( 20, 17, "启动时间", 1 );
		}
		break;
	case 2:
		lp->status1 = 1;
		print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR );
		break;
	case 4:
		lp->status1 = 3;
		bai = (unsigned int)( systems.a_min / 100 );
		clr_rect( 75, 31, 8, 12 );
		putchar( 76, 31, bai+'0', 0 );
		if ( ENGLISH == systems.language )
		{
			print_str( 22, 31, "SMP Time", 1 );
		}
		else
		{
			print_ch_str( 20, 31, "采样时长", 1 );
		}
		break;
	case 5:
		lp->status1 = 4;
		bai = (unsigned int)( systems.a_min / 100 );
		shi = (unsigned int)( systems.a_min % 100 / 10 );
		fill_rect( 75, 31, 8, 12 );
		putchar( 76, 31, bai+'0', 1 );
		clr_rect( 83, 31, 8, 12 );
		putchar( 84, 31, shi+'0', 0 );
		break;
	case 6:
		lp->status1 = 5;
		shi = (unsigned int)( systems.a_min % 100 / 10 );
		ge = (unsigned int)( systems.a_min % 10 );
		fill_rect( 83, 31, 8, 12 );
		putchar( 84, 31, shi+'0', 1 );
		clr_rect( 91, 31, 8, 12 );
		putchar( 92, 31, ge+'0', 0 );
		break;
	case 7:
		lp->status1 = 8;
		if ( ENGLISH == systems.language )
		{
			draw_button( 15, 45, "Ok", 0, ENGLISH );     //打印"确定"按钮
			draw_button( 81, 45, "Esc", 1, ENGLISH );    //打印"取消"按钮
		}
		else
		{
			draw_button( 15, 45, "确定", 0, CHINESE );
			draw_button( 81, 45, "取消", 1, CHINESE );
		}
		break;
	case 8:
		lp->status1 = 7;
		if ( ENGLISH == systems.language )
		{
			draw_button( 15, 45, "Ok", 1, ENGLISH );     //打印"确定"按钮
			draw_button( 81, 45, "Esc", 0, ENGLISH );    //打印"取消"按钮
		}
		else
		{
			draw_button( 15, 45, "确定", 1, CHINESE );
			draw_button( 81, 45, "取消", 0, CHINESE );
		}
		break;
	default: break;
	}
}

void groupWorkTimeSetMenuOnRight(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;

	lp = win->curfous;

	switch ( lp->status1 )
	{
	case 0:
		lp->status1 = 1;
		print_time( systems.temp_hour, systems.temp_min, 76, 17, HOUR );
		if ( ENGLISH == systems.language )
		{
			print_str( 10, 17, "Start Time", 0 );
		}
		else
		{
			print_ch_str( 20, 17, "启动时间", 0 );
		}
		break;
	case 1:
		lp->status1 = 2;
		print_time( systems.temp_hour, systems.temp_min, 76, 17, MIN );
		break;
	case 3:
		lp->status1 = 4;
		bai = (unsigned int)( systems.a_min / 100 );
		fill_rect( 75, 31, 8, 12 );
		putchar( 76, 31, bai+'0', 1 );
		if ( ENGLISH == systems.language )
		{
			print_str( 22, 31, "SMP Time", 0 );
		}
		else
		{
			print_ch_str( 20, 31, "采样时长", 0 );
		}
		break;
	case 4:
		lp->status1 = 5;
		bai = (unsigned int)( systems.a_min / 100 );
		shi = (unsigned int)( systems.a_min % 100 / 10 );
		clr_rect( 75, 31, 8, 12 );
		putchar( 76, 31, bai+'0', 0 );
		fill_rect( 83, 31, 8, 12 );
		putchar( 84, 31, shi+'0', 1 );
		break;
	case 5:
		lp->status1 = 6;
		shi = (unsigned int)( systems.a_min % 100 / 10 );
		ge = (unsigned int)( systems.a_min % 10 );
		clr_rect( 83, 31, 8, 12 );
		putchar( 84, 31, shi+'0', 0 );
		fill_rect( 91, 31, 8, 12 );
		putchar( 92, 31, ge+'0', 1 );
		break;
	case 7:
		lp->status1 = 8;
		if ( ENGLISH == systems.language )
		{
			draw_button( 15, 45, "Ok", 0, ENGLISH );     //打印"确定"按钮
			draw_button( 81, 45, "Esc", 1, ENGLISH );    //打印"取消"按钮
		}
		else
		{
			draw_button( 15, 45, "确定", 0, CHINESE );
			draw_button( 81, 45, "取消", 1, CHINESE );
		}
		break;
	case 8:
		lp->status1 = 7;
		if ( ENGLISH == systems.language )
		{
			draw_button( 15, 45, "Ok", 1, ENGLISH );     //打印"确定"按钮
			draw_button( 81, 45, "Esc", 0, ENGLISH );    //打印"取消"按钮
		}
		else
		{
			draw_button( 15, 45, "确定", 1, CHINESE );
			draw_button( 81, 45, "取消", 0, CHINESE );
		}
		break;
	default: break;
	}
}

void groupWorkTimeSetMenuOnOk(void)
{
	struct MENU *lp;
	int index;		// 索引组号
	unsigned int set_group_start_time;		// 当前组采样开始时间(min)
	unsigned int set_group_complete_time;	// 当前组采样完成时间(min)
	unsigned int index_group_start_time;	// 索引组采样启动时间(min)
	unsigned int index_group_complete_time;	// 索引组采样结束时间(min)
	unsigned char flag = 0;				// 冲突标志

	lp = win->curfous;

	if ( 7 == lp->status1 )
	{
		if ( 0 == systems.a_min )	// 流量为空
		{
			if ( lp->subMenu )
			{
				win->curfous = lp->subMenu;
				win->curfous->show();
			}
		}
		else
		{
			if ( 1 == systems.groups[systems.set_group].srb )	// 当前组已设置为启用组
			{
				// 计算当前组采样启动时间(min)
				set_group_start_time = systems.temp_hour * 60 + systems.temp_min;

				// 计算当前组采样完成时间(min)
				set_group_complete_time = systems.temp_hour * 60
										+ systems.temp_min + systems.a_min;

				for ( index=0; /*index != systems.set_group &&*/ index < GROUP_NUM; index++ )
				{
                    if ( systems.set_group == index ) continue;  //不能和自己进行比较
					// 计算索引组采样启动时间(min)
					index_group_start_time = systems.groups[index].start_time.hour * 60
									+ systems.groups[index].start_time.min;

					// 计算索引组采样完成时间(min)
					index_group_complete_time = systems.groups[index].start_time.hour * 60
									+ systems.groups[index].start_time.min
									+ systems.groups[index].smp_time;

					if (( set_group_start_time <= index_group_start_time
							&& set_group_complete_time >= index_group_start_time )
                        || ( set_group_start_time >= index_group_start_time
							&& set_group_start_time <= index_group_complete_time )
                        && 1 == systems.groups[index].srb )
					{
						flag = 1;		// 发生冲突
						systems.err_group_num = index;	// 保存发生冲突的组号
						break;
					}
				}
				if ( 1 == flag )		// 已发生冲突
				{
					if ( lp->subMenu )
					{
						win->curfous = lp->subMenu;
						win->curfous->show();
					}
				}
				else
				{
					systems.groups[systems.set_group].start_time.hour = systems.temp_hour;  // 确认启动采样时间
					systems.groups[systems.set_group].start_time.min = systems.temp_min;
					systems.groups[systems.set_group].smp_time = systems.a_min;   // 确认采样时长
					if ( lp->topMenu )
					{
						systems.temp_hour = 0;		// 恢复默认设置值
						systems.temp_min = 0;		// 恢复默认设置值
						systems.a_min = 1;			// 恢复默认设置值

						win->curfous = lp->topMenu;
						win->curfous->show();
					}
				}
			}
			else	// 当前组没有设置为启用组
			{
				systems.groups[systems.set_group].start_time.hour = systems.temp_hour;  // 确认启动采样时间
				systems.groups[systems.set_group].start_time.min = systems.temp_min;
				systems.groups[systems.set_group].smp_time = systems.a_min;   // 确认采样时长
				if ( lp->topMenu )
				{
					systems.temp_hour = 0;		// 恢复默认设置值
					systems.temp_min = 0;		// 恢复默认设置值
					systems.a_min = 1;			// 恢复默认设置值

					win->curfous = lp->topMenu;
					win->curfous->show();
				}
			}
		}
	}
	else if ( 8 == lp->status1 )
	{
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
}

void groupWorkTimeSetMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		systems.temp_hour = 0;		// 恢复默认设置值
		systems.temp_min = 0;		// 恢复默认设置值
		systems.a_min = 1;			// 恢复默认设置值

		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void groupWorkTimeSetMenuExec(void)
{

}

/*
 * 组冲突
 */
void groupWarnMenuShow(void)
{
//	struct MENU *lp;
	unsigned int tmp_hour, tmp_min;
	unsigned int smp_time;
//	lp = win->curfous;
	clr_lcd();
	draw_rect( 0, 0, 127, 63 );
	draw_line( 20, 15, 107, 15 );
	if ( 0 == systems.a_min )
	{
		if ( ENGLISH == systems.language )
		{
			print_str( 45, 3, "Warning !", 0 );
			print_str(2,25,"SMP Time can't be 0",0);
			draw_button( 90, 45, "Ok", 1, ENGLISH );
			print_str( 2, 48, "Please reset!", 0 );
		}
		else
		{
			print_ch_str( 53, 3, "警告", 0 );
			print_str( 83, 3, "!", 0 );
			print_ch_str( 20, 25, "采样时长不能为", 0 );
			putchar( 106, 25, '0', 0 );
			draw_button( 90, 45, "确定", 1, CHINESE );
			print_ch_str( 2, 48, "请重新设置", 0 );
		}
	}
	else
	{
		tmp_hour = systems.groups[systems.err_group_num].start_time.hour;  // 冲突的组时间
		tmp_min = systems.groups[systems.err_group_num].start_time.min;
		smp_time = systems.groups[systems.err_group_num].smp_time;	// 冲突组的采样时长

		if ( ENGLISH == systems.language )
		{
			print_str( 45, 3, "Warning !", 0 );
			print_str( 2, 17, "Conflicts with Grp", 0 );
			print_int( 110, 17, systems.err_group_num + 1, 0 );

			print_str(2,30,"Group",0);
			print_int( 32, 30, systems.err_group_num + 1, 0 );
			print_time( tmp_hour, tmp_min, 44, 30, HOUR_MIN );
			putchar( 84, 30, ',', 0 );

			print_int( 90, 30, smp_time, 0 );
			print_str( 2, 48, "Please Reset!", 0 );
			draw_button( 92, 44, "Ok", 1, ENGLISH );
		}
		else
		{
			print_ch_str( 53, 3, "警告", 0 );
			print_str( 83, 3, "!", 0 );
			print_ch_str( 22, 17, "时间与组", 0 );
			print_int( 72, 17, systems.err_group_num + 1, 0 );
			print_ch_str( 85, 17, "冲突", 0 );
			print_ch_str( 2, 30, "组", 0 );
			print_int( 18, 30, systems.err_group_num + 1, 0 );
			print_ch_str( 30, 30, "时间", 0 );
			print_time( tmp_hour, tmp_min, 54, 30, HOUR_MIN );
			putchar( 94, 30, ',', 0 );
			print_int( 100, 30, smp_time, 0 );
			print_ch_str( 2, 48, "请重新设置", 0 );
			draw_button( 92, 44, "确定", 1, CHINESE );
		}
	}

}

void groupWarnMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

/*
 * 定时模式定时组流量设置菜单
 */
void groupFlowSetMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( systems.groups[systems.set_group].flow )
	{
		systems.a_flow = systems.groups[systems.set_group].flow;
	}

	flowSetShow( lp );
}

void groupFlowSetMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;
	flowSetUp( lp );
}

void groupFlowSetMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;
	flowSetDown( lp );
}

void groupFlowSetMenuOnLeft(void)
{
	struct MENU *lp;
	lp = win->curfous;
	flowSetLeft( lp );
}

void groupFlowSetMenuOnRight(void)
{
	struct MENU *lp;
	lp = win->curfous;
	flowSetRight( lp );
}

void groupFlowSetMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( 3 == lp->status1 )		// 确定获得焦点
	{
		if ( systems.a_flow < 40 || systems.a_flow > MAX_FLOW )
		{
			if ( lp->subMenu )
			{
				win->curfous = lp->subMenu;		// 进入错误警告菜单
				win->curfous->show();
			}
		}
		else
		{
			systems.groups[systems.set_group].flow = systems.a_flow;	// 确认当前组的流量设置            
			systems.a_flow = ORIGIN_FLOW;
            changeFlow( systems.groups[systems.set_group].flow );
            
			if ( lp->topMenu )
			{
				win->curfous = lp->topMenu;
				win->curfous->show();
			}
		}
	}
	else if ( 4 == lp->status1 )		// 取消获得焦点
	{
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
}

void groupFlowSetMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void groupFlowSetMenuExec(void)
{

}

/*
 * 循环模式参数设置菜单
 */
void cylParaSetMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );		// 打印一个像扳手一样的设置图标
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	draw_dialog(1);
    fill_rect( 118, 22, 6, 36 );   //填充滚动条
    draw_symbol( 118, 18, 6, 3, gundong_up_mu, 0 );    // 画上三角图标
    draw_symbol( 118, 59, 6, 3, gundong_down_mu, 0 );  //画下三角图标

    //清空滚动条滚动粒所来位置处
    clr_rect( 119, 24+lp->status2*6, 4, 8 );
    if ( ENGLISH == systems.language )
	{
		print_str( 40, 3, "Cycle Mod Para", 0 );
		switch ( lp->status1 )
		{
		case 0:  //焦点在第一行处
            fill_rect( 36, 18, 76, 14 );
            if ( 0 == lp->status2 )
            {
                print_str( 38, 19, "Flow", 1 );   // 打印第一行菜单标题
                print_str( 38, 34, "Delay", 0 );  // 打印第二行菜单的标题
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_str( 38, 49, "SMP Time", 0 );  // 打印第三行菜单的标题
                }
                else 
                {
                    print_str( 38, 49, "SMP Volume", 0 );  // 打印第三行菜单的标题
                }
            }
            else if ( 1 == lp->status2 )
            {
                print_str( 38, 19, "Delay", 1 );   // 打印第一行菜单标题
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_str( 38, 34, "SMP Time", 0 );  // 打印第二行菜单的标题
                }
                else
                {
                    print_str( 38, 34, "SMP Volume", 0 );  // 打印第二行菜单的标题
                }
                print_str( 38, 49, "Cycles", 0 );  // 打印第三行菜单的标题
            }
            else if ( 2 == lp->status2 )
            {
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_str( 38, 19, "SMP Time", 1 );   // 打印第一行菜单标题
                }
                else
                {
                    print_str( 38, 19, "SMP Volume", 1 );   // 打印第一行菜单标题
                }
                print_str( 38, 34, "Cycles", 0 );  // 打印第二行菜单的标题
                print_str( 38, 49, "Exit", 0 );  // 打印第三行菜单的标题
            }
			break;
		case 1:  //焦点在第二行处
            fill_rect( 36, 33, 76, 14 );
            if ( 1 == lp->status2 )
            {
                print_str( 38, 19, "Flow", 0 );   // 打印第一行菜单标题
                print_str( 38, 34, "Delay", 1 );  // 打印第二行菜单的标题
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_str( 38, 49, "SMP Time", 0 );  // 打印第三行菜单的标题
                }
                else
                {
                    print_str( 38, 49, "SMP Volume", 0 );  // 打印第三行菜单的标题
                }
            }
            else if ( 2 == lp->status2 )
            {
                print_str( 38, 19, "Delay", 0 );   // 打印第一行菜单标题
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_str( 38, 34, "SMP Time", 1 );  // 打印第二行菜单的标题
                }
                else
                {
                    print_str( 38, 34, "SMP Volume", 1 );  // 打印第二行菜单的标题
                }
                print_str( 38, 49, "Cycles", 0 );  // 打印第三行菜单的标题
            }
            else if ( 3 == lp->status2 )
            {
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_str( 38, 19, "SMP Time", 0 );   // 打印第一行菜单标题
                }
                else
                {
                    print_str( 38, 19, "SMP Volume", 0 );   // 打印第一行菜单标题
                }
                print_str( 38, 34, "Cycles", 1 );  // 打印第二行菜单的标题
                print_str( 38, 49, "Exit", 0 );  // 打印第三行菜单的标题
            }
			break;
		case 2:  //焦点在第三行处
            fill_rect( 36, 48, 76, 14 );
            if ( 2 == lp->status2 )
            {
                print_str( 38, 19, "Flow", 0 );   // 打印第一行菜单标题
                print_str( 38, 34, "Delay", 0 );  // 打印第二行菜单的标题
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_str( 38, 49, "SMP Time", 1 );  // 打印第三行菜单的标题
                }
                else
                {
                    print_str( 38, 49, "SMP Volume", 1 );  // 打印第三行菜单的标题
                }
            }
            else if ( 3 == lp->status2 )
            {
                print_str( 38, 19, "Delay", 0 );   // 打印第一行菜单标题
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_str( 38, 34, "SMP Time", 0 );  // 打印第二行菜单的标题
                }
                else
                {
                    print_str( 38, 34, "SMP Volume", 0 );  // 打印第二行菜单的标题
                }                
                print_str( 38, 49, "Cycles", 1 );  // 打印第三行菜单的标题
            }
            else if ( 4 == lp->status2 )
            {
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_str( 38, 19, "SMP Time", 0 );   // 打印第一行菜单标题
                }
                else
                {
                    print_str( 38, 19, "SMP Volume", 0 );   // 打印第一行菜单标题
                }
                print_str( 38, 34, "Cycles", 0 );  // 打印第二行菜单的标题
                print_str( 38, 49, "Exit", 1 );  // 打印第三行菜单的标题
            }
			break;
		default: break;
		}
	}
	else
	{
    	print_ch_str( 45, 3, "循环模式参数", 0 );
		switch ( lp->status1 )
		{
		case 0:  //焦点在第一行处
            fill_rect( 36, 18, 76, 14 );
            if ( 0 == lp->status2 )
            {
                print_ch_str( 38, 19, "流量设置", 1 );   // 打印第一行菜单标题
                print_ch_str( 38, 34, "间隔时间", 0 );  // 打印第二行菜单的标题
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_ch_str( 38, 49, "采样时长", 0 );  // 打印第三行菜单的标题
                }
                else
                {
                    print_ch_str( 38, 49, "定容设置", 0 );  // 打印第三行菜单的标题
                }
            }
            else if ( 1 == lp->status2 )
            {
                print_ch_str( 38, 19, "间隔时间", 1 );   // 打印第一行菜单标题
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_ch_str( 38, 34, "采样时长", 0 );  // 打印第二行菜单的标题
                }
                else
                {
                    print_ch_str( 38, 34, "定容设置", 0 );  // 打印第二行菜单的标题
                }
                print_ch_str( 38, 49, "循环次数", 0 );  // 打印第三行菜单的标题
            }
            else if ( 2 == lp->status2 )
            {
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_ch_str( 38, 19, "采样时长", 1 );   // 打印第一行菜单标题
                }
                else
                {
                    print_ch_str( 38, 19, "定容设置", 1 );   // 打印第一行菜单标题
                }
                print_ch_str( 38, 34, "循环次数", 0 );  // 打印第二行菜单的标题
                print_ch_str( 38, 49, "退出", 0 );  // 打印第三行菜单的标题
            }
			break;
		case 1:  //焦点在第二行处
            fill_rect( 36, 33, 76, 14 );
            if ( 1 == lp->status2 )
            {
                print_ch_str( 38, 19, "流量设置", 0 );   // 打印第一行菜单标题
                print_ch_str( 38, 34, "间隔时间", 1 );  // 打印第二行菜单的标题
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_ch_str( 38, 49, "采样时长", 0 );  // 打印第三行菜单的标题
                }
                else
                {
                    print_ch_str( 38, 49, "定容设置", 0 );  // 打印第三行菜单的标题
                }
            }
            else if ( 2 == lp->status2 )
            {
                print_ch_str( 38, 19, "间隔时间", 0 );   // 打印第一行菜单标题
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_ch_str( 38, 34, "采样时长", 1 );  // 打印第二行菜单的标题
                }
                else
                {
                    print_ch_str( 38, 34, "定容设置", 1 );  // 打印第二行菜单的标题
                }
                print_ch_str( 38, 49, "循环次数", 0 );  // 打印第三行菜单的标题
            }
            else if ( 3 == lp->status2 )
            {
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_ch_str( 38, 19, "采样时长", 0 );   // 打印第一行菜单标题
                }
                else
                {
                    print_ch_str( 38, 19, "定容设置", 0 );   // 打印第一行菜单标题
                }
                print_ch_str( 38, 34, "循环次数", 1 );  // 打印第二行菜单的标题
                print_ch_str( 38, 49, "退出", 0 );  // 打印第三行菜单的标题
            }
			break;
		case 2:  //焦点在第三行处
            fill_rect( 36, 48, 76, 14 );
            if ( 2 == lp->status2 )
            {
                print_ch_str( 38, 19, "流量设置", 0 );   // 打印第一行菜单标题
                print_ch_str( 38, 34, "间隔时间", 0 );  // 打印第二行菜单的标题
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_ch_str( 38, 49, "采样时长", 1 );  // 打印第三行菜单的标题
                }
                else
                {
                    print_ch_str( 38, 49, "定容设置", 1 );  // 打印第三行菜单的标题
                }
            }
            else if ( 3 == lp->status2 )
            {
                print_ch_str( 38, 19, "间隔时间", 0 );   // 打印第一行菜单标题
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_ch_str( 38, 34, "采样时长", 0 );  // 打印第二行菜单的标题
                }
                else
                {
                    print_ch_str( 38, 34, "定容设置", 0 );  // 打印第二行菜单的标题
                }
                print_ch_str( 38, 49, "循环次数", 1 );  // 打印第三行菜单的标题
            }
            else if ( 4 == lp->status2 )
            {
                if ( TIMING == systems.cyls.tim_vol_status )
                {
                    print_ch_str( 38, 19, "采样时长", 0 );   // 打印第一行菜单标题
                }
                else
                {
                    print_ch_str( 38, 19, "定容设置", 0 );   // 打印第一行菜单标题
                }
                print_ch_str( 38, 34, "循环次数", 0 );  // 打印第二行菜单的标题
                print_ch_str( 38, 49, "退出", 1 );  // 打印第三行菜单的标题
            }
			break;
		default: break;
		}
	}
}

void cylParaSetMenuOnUp(void)
{
	struct MENU *lp;
	const char* text1;
	const char* text2;
	const char* text3;
	const char* text4;
	const char* text5;

	lp = win->curfous;
	if ( 0 == lp->status2 )
	{
		lp->status2 = 4;
	}
	else
	{
		lp->status2--;
	}

	fill_rect( 118, 22, 6, 36 );   //填充滚动条

    //清空滚动条滚动粒所来位置处
    clr_rect( 119, 24+lp->status2*6, 4, 8 );
    clr_rect( 36, 18, 76, 44 );		// 清空显示区

	if ( ENGLISH == systems.language )
	{
		text1 = "Flow";
		text2 = "Delay";
        if ( TIMING == systems.cyls.tim_vol_status )
        {
		    text3 = "SMP Time";
        }
        else
        {
		    text3 = "SMP Volume";
        }
		text4 = "Cycles";
		text5 = "Exit";
		switch ( lp->status1 )
		{
		case 0:
			if ( 4 == lp->status2 )
			{
				lp->status1 = 2;
	            fill_rect( 36, 48, 76, 14 );
	            print_str( 38, 19, text3, 0 );   // 打印第一行菜单标题
	            print_str( 38, 34, text4, 0 );  // 打印第二行菜单的标题
	            print_str( 38, 49, text5, 1 );  // 打印第三行菜单的标题
			}
			else if ( 1 == lp->status2 )
			{
	            fill_rect( 36, 18, 76, 14 );
	            print_str( 38, 19, text2, 1 );   // 打印第一行菜单标题
	            print_str( 38, 34, text3, 0 );  // 打印第二行菜单的标题
	            print_str( 38, 49, text4, 0 );  // 打印第三行菜单的标题
			}
			else if ( 0 == lp->status2 )
			{
	            fill_rect( 36, 18, 76, 14 );
	            print_str( 38, 19, text1, 1 );   // 打印第一行菜单标题
	            print_str( 38, 34, text2, 0 );  // 打印第二行菜单的标题
	            print_str( 38, 49, text3, 0 );  // 打印第三行菜单的标题
			}
			break;
		case 1:
			lp->status1 = 0;
			if ( 0 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_str( 38, 19, text1, 1 );   // 打印第一行菜单标题
				print_str( 38, 34, text2, 0 );  // 打印第二行菜单的标题
				print_str( 38, 49, text3, 0 );  // 打印第三行菜单的标题
			}
			else if ( 1 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_str( 38, 19, text2, 1 );   // 打印第一行菜单标题
				print_str( 38, 34, text3, 0 );  // 打印第二行菜单的标题
				print_str( 38, 49, text4, 0 );  // 打印第三行菜单的标题
			}
			else if ( 2 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_str( 38, 19, text3, 1 );   // 打印第一行菜单标题
				print_str( 38, 34, text4, 0 );  // 打印第二行菜单的标题
				print_str( 38, 49, text5, 0 );  // 打印第三行菜单的标题
			}
			break;
		case 2:
			lp->status1 = 1;
			if ( 1 == lp->status2 )
			{
				fill_rect( 36, 33, 76, 14 );
				print_str( 38, 19, text1, 0 );   // 打印第一行菜单标题
				print_str( 38, 34, text2, 1 );  // 打印第二行菜单的标题
				print_str( 38, 49, text3, 0 );  // 打印第三行菜单的标题
			}
			else if ( 2 == lp->status2 )
			{
				fill_rect( 36, 33, 76, 14 );
				print_str( 38, 19, text2, 0 );   // 打印第一行菜单标题
				print_str( 38, 34, text3, 1 );  // 打印第二行菜单的标题
				print_str( 38, 49, text4, 0 );  // 打印第三行菜单的标题
			}
			else if ( 3 == lp->status2 )
			{
				fill_rect( 36, 33, 76, 14 );
				print_str( 38, 19, text3, 0 );   // 打印第一行菜单标题
				print_str( 38, 34, text4, 1 );  // 打印第二行菜单的标题
				print_str( 38, 49, text5, 0 );  // 打印第三行菜单的标题
			}
			break;
		default: break;
		}
	}
	else
	{
		text1 = "流量设置";
		text2 = "间隔时间";
        if ( TIMING == systems.cyls.tim_vol_status )
        {
		    text3 = "采样时长";
        }
        else
        {
		    text3 = "定容设置";
        }
		text4 = "循环次数";
		text5 = "退出";
    	switch ( lp->status1 )
    	{
		case 0:
			if ( 4 == lp->status2 )
			{
				lp->status1 = 2;
	            fill_rect( 36, 48, 76, 14 );
	            print_ch_str( 38, 19, text3, 0 );   // 打印第一行菜单标题
	            print_ch_str( 38, 34, text4, 0 );  // 打印第二行菜单的标题
	            print_ch_str( 38, 49, text5, 1 );  // 打印第三行菜单的标题
			}
			else if ( 1 == lp->status2 )
			{
	            fill_rect( 36, 18, 76, 14 );
	            print_ch_str( 38, 19, text2, 1 );   // 打印第一行菜单标题
	            print_ch_str( 38, 34, text3, 0 );  // 打印第二行菜单的标题
	            print_ch_str( 38, 49, text4, 0 );  // 打印第三行菜单的标题
			}
			else if ( 0 == lp->status2 )
			{
	            fill_rect( 36, 18, 76, 14 );
	            print_ch_str( 38, 19, text1, 1 );   // 打印第一行菜单标题
	            print_ch_str( 38, 34, text2, 0 );  // 打印第二行菜单的标题
	            print_ch_str( 38, 49, text3, 0 );  // 打印第三行菜单的标题
			}
			break;
		case 1:
			lp->status1 = 0;
			if ( 0 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_ch_str( 38, 19, text1, 1 );   // 打印第一行菜单标题
				print_ch_str( 38, 34, text2, 0 );  // 打印第二行菜单的标题
				print_ch_str( 38, 49, text3, 0 );  // 打印第三行菜单的标题
			}
			else if ( 1 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_ch_str( 38, 19, text2, 1 );   // 打印第一行菜单标题
				print_ch_str( 38, 34, text3, 0 );  // 打印第二行菜单的标题
				print_ch_str( 38, 49, text4, 0 );  // 打印第三行菜单的标题
			}
			else if ( 2 == lp->status2 )
			{
				fill_rect( 36, 18, 76, 14 );
				print_ch_str( 38, 19, text3, 1 );   // 打印第一行菜单标题
				print_ch_str( 38, 34, text4, 0 );  // 打印第二行菜单的标题
				print_ch_str( 38, 49, text5, 0 );  // 打印第三行菜单的标题
			}
			break;
		case 2:
			lp->status1 = 1;
			if ( 1 == lp->status2 )
			{
				fill_rect( 36, 33, 76, 14 );
				print_ch_str( 38, 19, text1, 0 );   // 打印第一行菜单标题
				print_ch_str( 38, 34, text2, 1 );  // 打印第二行菜单的标题
				print_ch_str( 38, 49, text3, 0 );  // 打印第三行菜单的标题
			}
			else if ( 2 == lp->status2 )
			{
				fill_rect( 36, 33, 76, 14 );
				print_ch_str( 38, 19, text2, 0 );   // 打印第一行菜单标题
				print_ch_str( 38, 34, text3, 1 );  // 打印第二行菜单的标题
				print_ch_str( 38, 49, text4, 0 );  // 打印第三行菜单的标题
			}
			else if ( 3 == lp->status2 )
			{
				fill_rect( 36, 33, 76, 14 );
				print_ch_str( 38, 19, text3, 0 );   // 打印第一行菜单标题
				print_ch_str( 38, 34, text4, 1 );  // 打印第二行菜单的标题
				print_ch_str( 38, 49, text5, 0 );  // 打印第三行菜单的标题
			}
			break;
		default: break;
		}
	}

}

void cylParaSetMenuOnDown(void)
{
	struct MENU *lp;
	const char* text1;
	const char* text2;
	const char* text3;
	const char* text4;
	const char* text5;

	lp = win->curfous;

	if ( 4 == lp->status2 )
	{
		lp->status2 = 0;
	}
	else
	{
		lp->status2++;
	}
    fill_rect( 118, 22, 6, 36 );   //填充滚动条
    clr_rect( 36, 18, 76, 44 );		// 清空显示区

    //清空滚动条滚动粒所来位置处
    clr_rect( 119, 24+lp->status2*6, 4, 8 );

	if ( ENGLISH == systems.language )
	{
		text1 = "Flow";
		text2 = "Delay";
        if ( TIMING == systems.cyls.tim_vol_status )
        {
		    text3 = "SMP Time";
        }
        else
        {
		    text3 = "SMP Volume";
        }
		text4 = "Cycles";
		text5 = "Exit";
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			if ( 1 == lp->status2 )
			{
				fill_rect( 36, 33, 76, 14 );
				print_str( 38, 19, text1, 0 );   // 打印第一行菜单标题
				print_str( 38, 34, text2, 1 );  // 打印第二行菜单的标题
				print_str( 38, 49, text3, 0 );  // 打印第三行菜单的标题
			}
			else if ( 2 == lp->status2 )
			{
				fill_rect( 36, 33, 76, 14 );
				print_str( 38, 19, text2, 0 );   // 打印第一行菜单标题
				print_str( 38, 34, text3, 1 );  // 打印第二行菜单的标题
				print_str( 38, 49, text4, 0 );  // 打印第三行菜单的标题
			}
			else if ( 3 == lp->status2 )
			{
				fill_rect( 36, 33, 76, 14 );
				print_str( 38, 19, text3, 0 );   // 打印第一行菜单标题
				print_str( 38, 34, text4, 1 );  // 打印第二行菜单的标题
				print_str( 38, 49, text5, 0 );  // 打印第三行菜单的标题
			}
			break;
		case 1:
			lp->status1 = 2;
			if ( 2 == lp->status2 )
			{
				fill_rect( 36, 48, 76, 14 );
				print_str( 38, 19, text1, 0 );   // 打印第一行菜单标题
				print_str( 38, 34, text2, 0 );  // 打印第二行菜单的标题
				print_str( 38, 49, text3, 1 );  // 打印第三行菜单的标题
			}
			else if ( 3 == lp->status2 )
			{
				fill_rect( 36, 48, 76, 14 );
				print_str( 38, 19, text2, 0 );   // 打印第一行菜单标题
				print_str( 38, 34, text3, 0 );  // 打印第二行菜单的标题
				print_str( 38, 49, text4, 1 );  // 打印第三行菜单的标题
			}
			else if ( 4 == lp->status2 )
			{
				fill_rect( 36, 48, 76, 14 );
				print_str( 38, 19, text3, 0 );   // 打印第一行菜单标题
				print_str( 38, 34, text4, 0 );  // 打印第二行菜单的标题
				print_str( 38, 49, text5, 1 );  // 打印第三行菜单的标题
			}
			break;
		case 2:
			if ( 3 == lp->status2 )
			{
				fill_rect( 36, 48, 76, 14 );
				print_str( 38, 19, text2, 0 );   // 打印第一行菜单标题
				print_str( 38, 34, text3, 0 );  // 打印第二行菜单的标题
				print_str( 38, 49, text4, 1 );  // 打印第三行菜单的标题
			}
			else if ( 4 == lp->status2 )
			{
				fill_rect( 36, 48, 76, 14 );
				print_str( 38, 19, text3, 0 );   // 打印第一行菜单标题
				print_str( 38, 34, text4, 0 );  // 打印第二行菜单的标题
				print_str( 38, 49, text5, 1 );  // 打印第三行菜单的标题
			}
			else if ( 0 == lp->status2 )
			{
				lp->status1 = 0;
				fill_rect( 36, 18, 76, 14 );
				print_str( 38, 19, text1, 1 );   // 打印第一行菜单标题
				print_str( 38, 34, text2, 0 );  // 打印第二行菜单的标题
				print_str( 38, 49, text3, 0 );  // 打印第三行菜单的标题
			}
			break;
		default: break;
		}
	}
	else
	{
		text1 = "流量设置";
		text2 = "间隔时间";
        if ( TIMING == systems.cyls.tim_vol_status )
        {
		    text3 = "采样时长";
        }
        else
        {
		    text3 = "定容设置";
        }
		text4 = "循环次数";
		text5 = "退出";
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			if ( 1 == lp->status2 )
			{
				fill_rect( 36, 33, 76, 14 );
				print_ch_str( 38, 19, text1, 0 );   // 打印第一行菜单标题
				print_ch_str( 38, 34, text2, 1 );  // 打印第二行菜单的标题
				print_ch_str( 38, 49, text3, 0 );  // 打印第三行菜单的标题
			}
			else if ( 2 == lp->status2 )
			{
				fill_rect( 36, 33, 76, 14 );
				print_ch_str( 38, 19, text2, 0 );   // 打印第一行菜单标题
				print_ch_str( 38, 34, text3, 1 );  // 打印第二行菜单的标题
				print_ch_str( 38, 49, text4, 0 );  // 打印第三行菜单的标题
			}
			else if ( 3 == lp->status2 )
			{
				fill_rect( 36, 33, 76, 14 );
				print_ch_str( 38, 19, text3, 0 );   // 打印第一行菜单标题
				print_ch_str( 38, 34, text4, 1 );  // 打印第二行菜单的标题
				print_ch_str( 38, 49, text5, 0 );  // 打印第三行菜单的标题
			}
			break;
		case 1:
			lp->status1 = 2;
			if ( 2 == lp->status2 )
			{
				fill_rect( 36, 48, 76, 14 );
				print_ch_str( 38, 19, text1, 0 );   // 打印第一行菜单标题
				print_ch_str( 38, 34, text2, 0 );  // 打印第二行菜单的标题
				print_ch_str( 38, 49, text3, 1 );  // 打印第三行菜单的标题
			}
			else if ( 3 == lp->status2 )
			{
				fill_rect( 36, 48, 76, 14 );
				print_ch_str( 38, 19, text2, 0 );   // 打印第一行菜单标题
				print_ch_str( 38, 34, text3, 0 );  // 打印第二行菜单的标题
				print_ch_str( 38, 49, text4, 1 );  // 打印第三行菜单的标题
			}
			else if ( 4 == lp->status2 )
			{
				fill_rect( 36, 48, 76, 14 );
				print_ch_str( 38, 19, text3, 0 );   // 打印第一行菜单标题
				print_ch_str( 38, 34, text4, 0 );  // 打印第二行菜单的标题
				print_ch_str( 38, 49, text5, 1 );  // 打印第三行菜单的标题
			}
			break;
		case 2:
			if ( 3 == lp->status2 )
			{
				fill_rect( 36, 48, 76, 14 );
				print_ch_str( 38, 19, text2, 0 );   // 打印第一行菜单标题
				print_ch_str( 38, 34, text3, 0 );  // 打印第二行菜单的标题
				print_ch_str( 38, 49, text4, 1 );  // 打印第三行菜单的标题
			}
			else if ( 4 == lp->status2 )
			{
				fill_rect( 36, 48, 76, 14 );
				print_ch_str( 38, 19, text3, 0 );   // 打印第一行菜单标题
				print_ch_str( 38, 34, text4, 0 );  // 打印第二行菜单的标题
				print_ch_str( 38, 49, text5, 1 );  // 打印第三行菜单的标题
			}
			else if ( 0 == lp->status2 )
			{
				lp->status1 = 0;
				fill_rect( 36, 18, 76, 14 );
				print_ch_str( 38, 19, text1, 1 );   // 打印第一行菜单标题
				print_ch_str( 38, 34, text2, 0 );  // 打印第二行菜单的标题
				print_ch_str( 38, 49, text3, 0 );  // 打印第三行菜单的标题
			}
			break;
		default: break;
		}
	}
}

void cylParaSetMenuOnLeft(void)
{
}

void cylParaSetMenuOnRight(void)
{
}

void cylParaSetMenuOnOk(void)
{
	struct MENU *lp;
	struct MENU *top_lp;
	lp = win->curfous;
	switch ( lp->status2 )
	{
	case 0:			// “设置流量”获得焦点
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu;
			win->curfous->show();
		}
		break;
	case 1:			// “间隔时间”获得焦点
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu->rMenu;
			win->curfous->show();
		}
		break;
	case 2:			// “采样时长”获得焦点
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu->rMenu->rMenu;
			win->curfous->show();
		}
		break;
	case 3:			// “循环次数”获得焦点
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu->rMenu->rMenu->rMenu;
			win->curfous->show();
		}
		break;
	case 4:			// ”退出“获得焦点
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			top_lp = win->curfous;
			if ( top_lp->topMenu )
			{
				win->curfous = top_lp->topMenu;
				win->curfous->show();
			}
		}
		break;
	default: break;
	}
}

void cylParaSetMenuOnEsc(void)
{
	struct MENU *lp;
	struct MENU *top_lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		top_lp = win->curfous;
		if ( top_lp->topMenu )
		{
			win->curfous = top_lp->topMenu;
			win->curfous->show();
		}
	}
}

void cylParaSetMenuExec(void)
{

}


/*
 * 循环模式流量设置菜单
 */
void cylFlowSetMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
	systems.a_flow = systems.cyls.flow;		// 获取默认设置值

	flowSetShow(lp);
}

void cylFlowSetMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;
	flowSetUp( lp );
}

void cylFlowSetMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;
	flowSetDown( lp );
}

void cylFlowSetMenuOnLeft(void)
{
	struct MENU *lp;
	lp = win->curfous;
	flowSetLeft( lp );
}

void cylFlowSetMenuOnRight(void)
{
	struct MENU *lp;
	lp = win->curfous;
	flowSetRight( lp );
}

void cylFlowSetMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( 3 == lp->status1 )
	{
		if ( systems.a_flow < 40 || systems.a_flow > MAX_FLOW )
		{
			if ( lp->subMenu )
			{
				win->curfous = lp->subMenu;		// 进入错误警告菜单
				win->curfous->show();
			}
		}
		else
		{
			systems.cyls.flow = systems.a_flow;		// 确认设置流量
			systems.a_flow = ORIGIN_FLOW;			// 还原默认值
            changeFlow( systems.cyls.flow );
                        
			if ( lp->topMenu )
			{
				win->curfous = lp->topMenu;
				win->curfous->show();
			}
		}
	}
	else if ( 4 == lp->status1 )
	{
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
}

void cylFlowSetMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void cylFlowSetMenuExec(void)
{

}


/*
 * 循环模式间隔时间设置菜单
 */
void cylDelaySetMenuShow(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;
	systems.a_min = systems.cyls.mid_time;
	lp = win->curfous;

	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );		// 打印一个像扳手一样的设置图标
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	draw_dialog( 0 );          // 描绘一个矩形框

    draw_rect( 57, 22, 42, 14 );
    draw_line( 85, 23, 85, 35 );
    draw_symbol( 86, 23, 12, 12, up_down_mu, 0 );
    print_str( 101, 23, "min", 0 );

    bai = (unsigned int)(systems.a_min / 100);
    shi = (unsigned int)(systems.a_min % 100 /10 );
    ge  = (unsigned int)(systems.a_min % 10);

    if ( ENGLISH == systems.language )
    {
    	print_str( 39, 3, "CYL Delay Time", 0 );
    	switch ( lp->status1 )
    	{
    	case 0:
			fill_rect( 59, 23, 8, 12 );
			putchar( 60, 23, bai+'0', 1 );
			putchar( 68, 23, shi+'0', 0 );
			putchar( 76, 23, ge+'0', 0 );
			draw_button( 44, 43, "Ok", 0, ENGLISH );
			draw_button( 87, 43, "Esc", 0, ENGLISH );
    		break;
    	case 1:
			putchar( 60, 23, bai+'0', 0 );
			fill_rect( 67, 23, 8, 12 );
			putchar( 68, 23, shi+'0', 1 );
			putchar( 76, 23, ge+'0', 0 );
			draw_button( 44, 43, "Ok", 0, ENGLISH );
			draw_button( 87, 43, "Esc", 0, ENGLISH );
    		break;
    	case 2:
			putchar( 60, 23, bai+'0', 0 );
			putchar( 68, 23, shi+'0', 0 );
			fill_rect( 75, 23, 8, 12 );
			putchar( 76, 23, ge+'0', 1 );
			draw_button( 44, 43, "Ok", 0, ENGLISH );
			draw_button( 87, 43, "Esc", 0, ENGLISH );
    		break;
    	case 3:
			putchar( 60, 23, bai+'0', 0 );
			putchar( 68, 23, shi+'0', 0 );
			putchar( 76, 23, ge+'0', 0 );
			draw_button( 44, 43, "Ok", 1, ENGLISH );
			draw_button( 87, 43, "Esc", 0, ENGLISH );
    		break;
    	case 4:
			putchar( 60, 23, bai+'0', 0 );
			putchar( 68, 23, shi+'0', 0 );
			putchar( 76, 23, ge+'0', 0 );
			draw_button( 44, 43, "Ok", 0, ENGLISH );
			draw_button( 87, 43, "Esc", 1, ENGLISH );
    		break;
    	default: break;
    	}
    }
    else
    {
    	print_ch_str( 45, 3, "循环间隔时间", 0 );
    	switch ( lp->status1 )
    	{
    	case 0:
			fill_rect( 59, 23, 8, 12 );
			putchar( 60, 23, bai+'0', 1 );
			putchar( 68, 23, shi+'0', 0 );
			putchar( 76, 23, ge+'0', 0 );
			draw_button( 44, 43, "确定", 0, CHINESE );
			draw_button( 87, 43, "取消", 0, CHINESE );
    		break;
    	case 1:
			putchar( 60, 23, bai+'0', 0 );
			fill_rect( 67, 23, 8, 12 );
			putchar( 68, 23, shi+'0', 1 );
			putchar( 76, 23, ge+'0', 0 );
			draw_button( 44, 43, "确定", 0, CHINESE );
			draw_button( 87, 43, "取消", 0, CHINESE );
    		break;
    	case 2:
			putchar( 60, 23, bai+'0', 0 );
			putchar( 68, 23, shi+'0', 0 );
			fill_rect( 75, 23, 8, 12 );
			putchar( 76, 23, ge+'0', 1 );
			draw_button( 44, 43, "确定", 0, CHINESE );
			draw_button( 87, 43, "取消", 0, CHINESE );
    		break;
    	case 3:
			putchar( 60, 23, bai+'0', 0 );
			putchar( 68, 23, shi+'0', 0 );
			putchar( 76, 23, ge+'0', 0 );
			draw_button( 44, 43, "确定", 1, CHINESE );
			draw_button( 87, 43, "取消", 0, CHINESE );
    		break;
    	case 4:
			putchar( 60, 23, bai+'0', 0 );
			putchar( 68, 23, shi+'0', 0 );
			putchar( 76, 23, ge+'0', 0 );
			draw_button( 44, 43, "确定", 0, CHINESE );
			draw_button( 87, 43, "取消", 1, CHINESE );
    		break;
    	default: break;
    	}
    }
}

void cylDelaySetMenuOnUp(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		bai = (unsigned int)(systems.a_min / 100);
        systems.a_min -= bai * 100;     // 间隔时间减去百位上的值
        if( bai == 9 )
        {
          bai = 0;
        }
        else
        {
          bai++;
        }
        systems.a_min += bai * 100;    // 百位回位
        putchar( 60, 23, bai+'0', 1 );	// 重新打印百位上的值，也即是刷新
		break;
	case 1:
		shi = (unsigned int)(systems.a_min % 100 /10 );
        systems.a_min -= shi * 10;     // 间隔时间减去十位上的值
        if( shi == 9 )
        {
          shi = 0;
        }
        else
        {
          shi++;
        }
        systems.a_min += shi * 10;    // 十位回位
        putchar( 68, 23, shi+'0', 1 );	// 重新打印十位上的值，也即是刷新
		break;
	case 2:
	    ge = (unsigned int)(systems.a_min % 10);
        systems.a_min -= ge;     // 间隔时间减去个位上的值
        if( ge == 9 )
        {
          ge = 0;
        }
        else
        {
          ge++;
        }
        systems.a_min += ge;    // 个位回位
        putchar( 76, 23, ge+'0', 1 );	// 重新打印个位上的值，也即是刷新
		break;
	default: break;
	}
}

void cylDelaySetMenuOnDown(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		bai = (unsigned int)(systems.a_min / 100);
        systems.a_min -= bai * 100;     // 间隔时间减去百位上的值
        if( bai == 0 )
        {
          bai = 9;
        }
        else
        {
          bai--;
        }
        systems.a_min += bai * 100;    // 百位回位
        putchar( 60, 23, bai+'0', 1 );	// 重新打印百位上的值，也即是刷新
		break;
	case 1:
		shi = (unsigned int)(systems.a_min % 100 /10 );
        systems.a_min -= shi * 10;     // 间隔时间减去十位上的值
        if( shi == 0 )
        {
          shi = 9;
        }
        else
        {
          shi--;
        }
        systems.a_min += shi * 10;    // 十位回位
        putchar( 68, 23, shi+'0', 1 );	// 重新打印十位上的值，也即是刷新
		break;
	case 2:
	    ge = (unsigned int)(systems.a_min % 10);
        systems.a_min -= ge;     // 间隔时间减去个位上的值
        if( ge == 0 )
        {
          ge = 9;
        }
        else
        {
          ge--;
        }
        systems.a_min += ge;    // 个位回位
        putchar( 76, 23, ge+'0', 1 );	// 重新打印个位上的值，也即是刷新
		break;
	default: break;
	}
}

void cylDelaySetMenuOnLeft(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		lp->status1 = 4;
		bai = (unsigned int)(systems.a_min / 100);
		clr_rect( 59, 23, 8, 12 );
		putchar( 60, 23, bai+'0', 0 );
		if ( ENGLISH == systems.language )
		{
			draw_button( 87, 43, "Esc", 1, ENGLISH );
		}
		else
		{
			draw_button( 87, 43, "取消", 1, CHINESE );
		}
		break;
	case 1:
		lp->status1 = 0;
		bai = (unsigned int)(systems.a_min / 100);
		shi = (unsigned int)(systems.a_min % 100 /10 );
		fill_rect( 59, 23, 8, 12 );
		clr_rect( 67, 23, 8, 12 );
		putchar( 60, 23, bai+'0', 1 );
		putchar( 68, 23, shi+'0', 0 );
		break;
	case 2:
		lp->status1 = 1;
		shi = (unsigned int)(systems.a_min % 100 /10 );
		ge = (unsigned int)(systems.a_min % 10);
		clr_rect( 75, 23, 8, 12 );
		fill_rect( 67, 23, 8, 12 );
		putchar( 68, 23, shi+'0', 1 );
		putchar( 76, 23, ge+'0', 0 );
		break;
	case 3:
		lp->status1 = 2;
		ge = (unsigned int)(systems.a_min % 10);
		fill_rect( 75, 23, 8, 12 );
		putchar( 76, 23, ge+'0', 1 );
		if ( ENGLISH == systems.language )
		{
			draw_button( 44, 43, "Ok", 0, ENGLISH );
		}
		else
		{
			draw_button( 44, 43, "确定", 0, CHINESE );
		}
		break;
	case 4:
		lp->status1 = 3;
		if ( ENGLISH == systems.language )
		{
			draw_button( 44, 43, "Ok", 1, ENGLISH );
			draw_button( 87, 43, "Esc", 0, ENGLISH );
		}
		else
		{
			draw_button( 44, 43, "确定", 1, CHINESE );
			draw_button( 87, 43, "取消", 0, CHINESE );
		}
		break;
	default: break;
	}
}

void cylDelaySetMenuOnRight(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		lp->status1 = 1;
		bai = (unsigned int)(systems.a_min / 100);
		shi = (unsigned int)(systems.a_min % 100 /10 );
		clr_rect( 59, 23, 8, 12 );
		fill_rect( 67, 23, 8, 12 );
		putchar( 60, 23, bai+'0', 0 );
		putchar( 68, 23, shi+'0', 1 );
		break;
	case 1:
		lp->status1 = 2;
		shi = (unsigned int)(systems.a_min % 100 /10 );
		ge = (unsigned int)(systems.a_min % 10);
		fill_rect( 75, 23, 8, 12 );
		clr_rect( 67, 23, 8, 12 );
		putchar( 68, 23, shi+'0', 0 );
		putchar( 76, 23, ge+'0', 1 );
		break;
	case 2:
		lp->status1 = 3;
		ge = (unsigned int)(systems.a_min % 10);
		clr_rect( 75, 23, 8, 12 );
		putchar( 76, 23, ge+'0', 0 );
		if ( ENGLISH == systems.language )
		{
			draw_button( 44, 43, "Ok", 1, ENGLISH );
		}
		else
		{
			draw_button( 44, 43, "确定", 1, CHINESE );
		}
		break;
	case 3:
		lp->status1 = 4;
		if ( ENGLISH == systems.language )
		{
			draw_button( 44, 43, "Ok", 0, ENGLISH );
			draw_button( 87, 43, "Esc", 1, ENGLISH );
		}
		else
		{
			draw_button( 44, 43, "确定", 0, CHINESE );
			draw_button( 87, 43, "取消", 1, CHINESE );
		}
		break;
	case 4:
		lp->status1 = 0;
		bai = (unsigned int)(systems.a_min / 100);
		fill_rect( 59, 23, 8, 12 );
		putchar( 60, 23, bai+'0', 1 );
		if ( ENGLISH == systems.language )
		{
			draw_button( 87, 43, "Esc", 0, ENGLISH );
		}
		else
		{
			draw_button( 87, 43, "取消", 0, CHINESE );
		}
		break;
	default: break;
	}
}

void cylDelaySetMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( 3 == lp->status1 )
	{
		systems.cyls.mid_time = systems.a_min;	// 确认设置间隔时间
		if ( lp->topMenu )
		{
			systems.a_min = 1;
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
	else if ( 4 == lp->status1 )
	{
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
}

void cylDelaySetMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		systems.a_min = 1;
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void cylDelaySetMenuExec(void)
{

}





/*
 * 循环模式采样时长设置菜单
 */
void cylSmpTimeSetMenuShow(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;     // 调整采样时长的个十百位值
    unsigned int Vbai, Vshi, Vge, Vshifen;    // 调整采样体积的个十百位值
    
	systems.a_min = systems.cyls.smp_time;
    systems.a_volume = systems.cyls.smp_volume;
	lp = win->curfous;

	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );		// 打印一个像扳手一样的设置图标
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	draw_dialog( 0 );          // 描绘一个矩形框

    draw_rect( 57, 22, 42, 14 );   // 描绘内部一个显示数值的小矩形框

    bai = (unsigned int)(systems.a_min / 100);
    shi = (unsigned int)(systems.a_min % 100 /10 );
    ge  = (unsigned int)(systems.a_min % 10);
    
    Vbai = (unsigned int)(systems.cyls.smp_volume / 100 );
    Vshi = (unsigned int)(systems.cyls.smp_volume) % 100 / 10 ;
    Vge = (unsigned int)(systems.cyls.smp_volume) % 10 ;
    Vshifen = (unsigned int)(systems.cyls.smp_volume * 10 ) % 10 ;

    draw_rect( 39, 3, 12, 12 );     // 打印单选选择框
    draw_rect( 86, 3, 12, 12 );
        
    if ( ENGLISH == systems.language )
    {
        if ( TIMING == systems.cyls.tim_vol_status )
        {
            draw_symbol( 40, 4, 10, 10, gou_mu, 0 );     // 在采样时长选择框打钩
            draw_line( 85, 23, 85, 35 );       // 描绘内部一个显示数值的小矩形框的竖直线
            draw_symbol( 86, 23, 12, 12, up_down_mu, 0 );
            print_str( 101, 23, "min", 0 );
            
            switch ( lp->status1 )
            {
            case 0:
                print_str( 52, 3, "TIM", 1 );
                print_str( 100, 3, "VOL", 0 );
                putchar( 60, 23, bai+'0', 0 );
                putchar( 68, 23, shi+'0', 0 );
                putchar( 76, 23, ge+'0', 0 );
                draw_button( 44, 43, "Ok", 0, ENGLISH );
                draw_button( 87, 43, "Esc", 0, ENGLISH );
                break;
            case 1:
                print_str( 52, 3, "TIM", 0 );
                print_str( 100, 3, "VOL", 1 );
                putchar( 60, 23, bai+'0', 0 );
                putchar( 68, 23, shi+'0', 0 );
                putchar( 76, 23, ge+'0', 0 );
                draw_button( 44, 43, "Ok", 0, ENGLISH );
                draw_button( 87, 43, "Esc", 0, ENGLISH );
                break;
            case 2:
                print_str( 52, 3, "TIM", 0 );
                print_str( 100, 3, "VOL", 0 );
                fill_rect( 59, 23, 8, 12 );
                putchar( 60, 23, bai+'0', 1 );
                putchar( 68, 23, shi+'0', 0 );
                putchar( 76, 23, ge+'0', 0 );
                draw_button( 44, 43, "Ok", 0, ENGLISH );
                draw_button( 87, 43, "Esc", 0, ENGLISH );
                break;
            case 3:
                print_str( 52, 3, "TIM", 0 );
                print_str( 100, 3, "VOL", 0 );
                putchar( 60, 23, bai+'0', 0 );
                fill_rect( 67, 23, 8, 12 );
                putchar( 68, 23, shi+'0', 1 );
                putchar( 76, 23, ge+'0', 0 );
                draw_button( 44, 43, "Ok", 0, ENGLISH );
                draw_button( 87, 43, "Esc", 0, ENGLISH );
                break;
            case 4:
                print_str( 52, 3, "TIM", 0 );
                print_str( 100, 3, "VOL", 0 );
                putchar( 60, 23, bai+'0', 0 );
                putchar( 68, 23, shi+'0', 0 );
                fill_rect( 75, 23, 8, 12 );
                putchar( 76, 23, ge+'0', 1 );
                draw_button( 44, 43, "Ok", 0, ENGLISH );
                draw_button( 87, 43, "Esc", 0, ENGLISH );
                break;
            case 5:
                print_str( 52, 3, "TIM", 0 );
                print_str( 100, 3, "VOL", 0 );
                putchar( 60, 23, bai+'0', 0 );
                putchar( 68, 23, shi+'0', 0 );
                putchar( 76, 23, ge+'0', 0 );
                draw_button( 44, 43, "Ok", 1, ENGLISH );
                draw_button( 87, 43, "Esc", 0, ENGLISH );
                break;
            case 6:
                print_str( 52, 3, "TIM", 0 );
                print_str( 100, 3, "VOL", 0 );
                putchar( 60, 23, bai+'0', 0 );
                putchar( 68, 23, shi+'0', 0 );
                putchar( 76, 23, ge+'0', 0 );
                draw_button( 44, 43, "Ok", 0, ENGLISH );
                draw_button( 87, 43, "Esc", 1, ENGLISH );
                break;
            default: break;
            }
        }
        else
        {
            draw_symbol( 87, 4, 10, 10, gou_mu, 0 );     // 在采样定容选择框打钩
            draw_point( 84, 32 );         // 画小数点
            print_str( 101, 23, "L", 0 );
            
            switch ( lp->status1 )
            {
            case 0:
                print_str( 52, 3, "TIM", 1 );
                print_str( 100, 3, "VOL", 0 );
                putchar( 60, 23, Vbai+'0', 0 );
                putchar( 68, 23, Vshi+'0', 0 );
                putchar( 76, 23, Vge+'0', 0 );
                putchar( 88, 23, Vshifen+'0', 0 ); 
                draw_button( 44, 43, "Ok", 0, ENGLISH );
                draw_button( 87, 43, "Esc", 0, ENGLISH );
                break;
            case 1:
                print_str( 52, 3, "TIM", 0 );
                print_str( 100, 3, "VOL", 1 );
                putchar( 60, 23, Vbai+'0', 0 );
                putchar( 68, 23, Vshi+'0', 0 );
                putchar( 76, 23, Vge+'0', 0 );
                putchar( 88, 23, Vshifen+'0', 0 ); 
                draw_button( 44, 43, "Ok", 0, ENGLISH );
                draw_button( 87, 43, "Esc", 0, ENGLISH );
                break;
            case 2:
                print_str( 52, 3, "TIM", 0 );
                print_str( 100, 3, "VOL", 0 );
                fill_rect( 59, 23, 8, 12 );
                putchar( 60, 23, Vbai+'0', 1 );
                putchar( 68, 23, Vshi+'0', 0 );
                putchar( 76, 23, Vge+'0', 0 );
                putchar( 88, 23, Vshifen+'0', 0 ); 
                draw_button( 44, 43, "Ok", 0, ENGLISH );
                draw_button( 87, 43, "Esc", 0, ENGLISH );
                break;
            case 3:
                print_str( 52, 3, "TIM", 0 );
                print_str( 100, 3, "VOL", 0 );
                putchar( 60, 23, Vbai+'0', 0 );
                fill_rect( 67, 23, 8, 12 );
                putchar( 68, 23, Vshi+'0', 1 );
                putchar( 76, 23, Vge+'0', 0 );
                putchar( 88, 23, Vshifen+'0', 0 ); 
                draw_button( 44, 43, "Ok", 0, ENGLISH );
                draw_button( 87, 43, "Esc", 0, ENGLISH );
                break;
            case 4:
                print_str( 52, 3, "TIM", 0 );
                print_str( 100, 3, "VOL", 0 );
                putchar( 60, 23, Vbai+'0', 0 );
                putchar( 68, 23, Vshi+'0', 0 );
                fill_rect( 75, 23, 8, 12 );
                putchar( 76, 23, Vge+'0', 1 );
                putchar( 88, 23, Vshifen+'0', 0 ); 
                draw_button( 44, 43, "Ok", 0, ENGLISH );
                draw_button( 87, 43, "Esc", 0, ENGLISH );
                break;
            case 5:
                print_str( 52, 3, "TIM", 0 );
                print_str( 100, 3, "VOL", 0 );
                putchar( 60, 23, Vbai+'0', 0 );
                putchar( 68, 23, Vshi+'0', 0 );
                putchar( 76, 23, Vge+'0', 0 );
                fill_rect( 87, 23, 8, 12 );
                putchar( 88, 23, Vshifen+'0', 1 ); 
                draw_button( 44, 43, "Ok", 0, ENGLISH );
                draw_button( 87, 43, "Esc", 0, ENGLISH );
                break;
            case 6:
                print_str( 52, 3, "TIM", 0 );
                print_str( 100, 3, "VOL", 0 );
                putchar( 60, 23, Vbai+'0', 0 );
                putchar( 68, 23, Vshi+'0', 0 );
                putchar( 76, 23, Vge+'0', 0 );
                putchar( 88, 23, Vshifen+'0', 0 ); 
                draw_button( 44, 43, "Ok", 1, ENGLISH );
                draw_button( 87, 43, "Esc", 0, ENGLISH );
                break;
            case 7:
                print_str( 52, 3, "TIM", 0 );
                print_str( 100, 3, "VOL", 0 );
                putchar( 60, 23, Vbai+'0', 0 );
                putchar( 68, 23, Vshi+'0', 0 );
                putchar( 76, 23, Vge+'0', 0 );
                putchar( 88, 23, Vshifen+'0', 0 ); 
                draw_button( 44, 43, "Ok", 0, ENGLISH );
                draw_button( 87, 43, "Esc", 1, ENGLISH );
                break;
            default: break;
            }
        }
    }
    else
    {
        if ( TIMING == systems.cyls.tim_vol_status )
        {
            draw_symbol( 40, 4, 10, 10, gou_mu, 0 );     // 在采样定容选择框打钩
            draw_line( 85, 23, 85, 35 );   // 描绘内部一个显示数值的小矩形框的竖直线
            draw_symbol( 86, 23, 12, 12, up_down_mu, 0 );
            print_str( 101, 23, "min", 0 );
            
            switch ( lp->status1 )
            {
            case 0:
                print_ch_str( 52, 3, "时长", 1 );
                print_ch_str( 100, 3, "定容", 0 );
                putchar( 60, 23, bai+'0', 0 );
                putchar( 68, 23, shi+'0', 0 );
                putchar( 76, 23, ge+'0', 0 );
                draw_button( 44, 43, "确定", 0, CHINESE );
                draw_button( 87, 43, "取消", 0, CHINESE );
                break;
            case 1:
                print_ch_str( 52, 3, "时长", 0 );
                print_ch_str( 100, 3, "定容", 1 );
                putchar( 60, 23, bai+'0', 0 );
                putchar( 68, 23, shi+'0', 0 );
                putchar( 76, 23, ge+'0', 0 );
                draw_button( 44, 43, "确定", 0, CHINESE );
                draw_button( 87, 43, "取消", 0, CHINESE );
                break;
            case 2:
                print_ch_str( 52, 3, "时长", 0 );
                print_ch_str( 100, 3, "定容", 0 );
                fill_rect( 59, 23, 8, 12 );
                putchar( 60, 23, bai+'0', 1 );
                putchar( 68, 23, shi+'0', 0 );
                putchar( 76, 23, ge+'0', 0 );
                draw_button( 44, 43, "确定", 0, CHINESE );
                draw_button( 87, 43, "取消", 0, CHINESE );
                break;
            case 3:
                print_ch_str( 52, 3, "时长", 0 );
                print_ch_str( 100, 3, "定容", 0 );
                putchar( 60, 23, bai+'0', 0 );
                fill_rect( 67, 23, 8, 12 );
                putchar( 68, 23, shi+'0', 1 );
                putchar( 76, 23, ge+'0', 0 );
                draw_button( 44, 43, "确定", 0, CHINESE );
                draw_button( 87, 43, "取消", 0, CHINESE );
                break;
            case 4:
                print_ch_str( 52, 3, "时长", 0 );
                print_ch_str( 100, 3, "定容", 0 );
                putchar( 60, 23, bai+'0', 0 );
                putchar( 68, 23, shi+'0', 0 );
                fill_rect( 75, 23, 8, 12 );
                putchar( 76, 23, ge+'0', 1 );
                draw_button( 44, 43, "确定", 0, CHINESE );
                draw_button( 87, 43, "取消", 0, CHINESE );
                break;
            case 5:
                print_ch_str( 52, 3, "时长", 0 );
                print_ch_str( 100, 3, "定容", 0 );
                putchar( 60, 23, bai+'0', 0 );
                putchar( 68, 23, shi+'0', 0 );
                putchar( 76, 23, ge+'0', 0 );
                draw_button( 44, 43, "确定", 1, CHINESE );
                draw_button( 87, 43, "取消", 0, CHINESE );
                break;
            case 6:
                print_ch_str( 52, 3, "时长", 0 );
                print_ch_str( 100, 3, "定容", 0 );
                putchar( 60, 23, bai+'0', 0 );
                putchar( 68, 23, shi+'0', 0 );
                putchar( 76, 23, ge+'0', 0 );
                draw_button( 44, 43, "确定", 0, CHINESE );
                draw_button( 87, 43, "取消", 1, CHINESE );
                break;
            default: break;
            }
        }
        else
        {            
            draw_symbol( 87, 4, 10, 10, gou_mu, 0 );     // 在采样定容选择框打钩
            draw_point( 85, 32 );         // 画小数点
            print_str( 101, 23, "L", 0 );
            
            switch ( lp->status1 )
            {
            case 0:
                print_ch_str( 52, 3, "时长", 1 );
                print_ch_str( 100, 3, "定容", 0 );
                putchar( 60, 23, Vbai+'0', 0 );
                putchar( 68, 23, Vshi+'0', 0 );
                putchar( 76, 23, Vge+'0', 0 );
                putchar( 88, 23, Vshifen+'0', 0 ); 
                draw_button( 44, 43, "确定", 0, CHINESE );
                draw_button( 87, 43, "取消", 0, CHINESE );
                break;
            case 1:
                print_ch_str( 52, 3, "时长", 0 );
                print_ch_str( 100, 3, "定容", 1 );
                putchar( 60, 23, Vbai+'0', 0 );
                putchar( 68, 23, Vshi+'0', 0 );
                putchar( 76, 23, Vge+'0', 0 );
                putchar( 88, 23, Vshifen+'0', 0 ); 
                draw_button( 44, 43, "确定", 0, CHINESE );
                draw_button( 87, 43, "取消", 0, CHINESE );
                break;
            case 2:
                print_ch_str( 52, 3, "时长", 0 );
                print_ch_str( 100, 3, "定容", 0 );
                fill_rect( 59, 23, 8, 12 );
                putchar( 60, 23, Vbai+'0', 1 );
                putchar( 68, 23, Vshi+'0', 0 );
                putchar( 76, 23, Vge+'0', 0 );
                putchar( 88, 23, Vshifen+'0', 0 ); 
                draw_button( 44, 43, "确定", 0, CHINESE );
                draw_button( 87, 43, "取消", 0, CHINESE );
                break;
            case 3:
                print_ch_str( 52, 3, "时长", 0 );
                print_ch_str( 100, 3, "定容", 0 );
                putchar( 60, 23, Vbai+'0', 0 );
                fill_rect( 67, 23, 8, 12 );
                putchar( 68, 23, Vshi+'0', 1 );
                putchar( 76, 23, Vge+'0', 0 );
                putchar( 88, 23, Vshifen+'0', 0 ); 
                draw_button( 44, 43, "确定", 0, CHINESE );
                draw_button( 87, 43, "取消", 0, CHINESE );
                break;
            case 4:
                print_ch_str( 52, 3, "时长", 0 );
                print_ch_str( 100, 3, "定容", 0 );
                putchar( 60, 23, Vbai+'0', 0 );
                putchar( 68, 23, Vshi+'0', 0 );
                fill_rect( 75, 23, 8, 12 );
                putchar( 76, 23, Vge+'0', 1 );
                putchar( 88, 23, Vshifen+'0', 0 ); 
                draw_button( 44, 43, "确定", 0, CHINESE );
                draw_button( 87, 43, "取消", 0, CHINESE );
                break;
            case 5:
                print_ch_str( 52, 3, "时长", 0 );
                print_ch_str( 100, 3, "定容", 0 );
                putchar( 60, 23, Vbai+'0', 0 );
                putchar( 68, 23, Vshi+'0', 0 );
                putchar( 76, 23, Vge+'0', 0 );
                fill_rect( 87, 23, 8, 12 );
                putchar( 88, 23, Vshifen+'0', 1 ); 
                draw_button( 44, 43, "确定", 0, CHINESE );
                draw_button( 87, 43, "取消", 0, CHINESE );
                break;
            case 6:
                print_ch_str( 52, 3, "时长", 0 );
                print_ch_str( 100, 3, "定容", 0 );
                putchar( 60, 23, Vbai+'0', 0 );
                putchar( 68, 23, Vshi+'0', 0 );
                putchar( 76, 23, Vge+'0', 0 );
                putchar( 88, 23, Vshifen+'0', 0 ); 
                draw_button( 44, 43, "确定", 1, CHINESE );
                draw_button( 87, 43, "取消", 0, CHINESE );
                break;
            case 7:
                print_ch_str( 52, 3, "时长", 0 );
                print_ch_str( 100, 3, "定容", 0 );
                putchar( 60, 23, Vbai+'0', 0 );
                putchar( 68, 23, Vshi+'0', 0 );
                putchar( 76, 23, Vge+'0', 0 );
                putchar( 88, 23, Vshifen+'0', 0 ); 
                draw_button( 44, 43, "确定", 0, CHINESE );
                draw_button( 87, 43, "取消", 1, CHINESE );
                break;
            default: break;
            }
        }
    }
}

void cylSmpTimeSetMenuOnUp(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;
	unsigned int Vbai, Vshi, Vge, Vshifen;
        
	lp = win->curfous;
    
    if ( TIMING == systems.cyls.tim_vol_status )
    {
        switch ( lp->status1 )
        {
        case 2:
            bai = (unsigned int)(systems.a_min / 100);
            systems.a_min -= bai * 100;     // 间隔时间减去百位上的值
            if( bai == 9 )
            {
                bai = 0;
            }
            else
            {
                bai++;
            }
            systems.a_min += bai * 100;    // 百位回位
            putchar( 60, 23, bai+'0', 1 );	// 重新打印百位上的值，也即是刷新
            break;
        case 3:
            shi = (unsigned int)(systems.a_min % 100 /10 );
            systems.a_min -= shi * 10;     // 间隔时间减去十位上的值
            if( shi == 9 )
            {
                shi = 0;
            }
            else
            {
                shi++;
            }
            systems.a_min += shi * 10;    // 十位回位
            putchar( 68, 23, shi+'0', 1 );	// 重新打印十位上的值，也即是刷新
            break;
        case 4:
            ge = (unsigned int)(systems.a_min % 10);
            systems.a_min -= ge;     // 间隔时间减去个位上的值
            if( ge == 9 )
            {
                ge = 0;
            }
            else
            {
                ge++;
            }
            systems.a_min += ge;    // 个位回位
            putchar( 76, 23, ge+'0', 1 );	// 重新打印个位上的值，也即是刷新
            break;
        default: break;
        }
    }
    else
    {
        switch ( lp->status1 )
        {
        case 2:
            Vbai = (unsigned int)(systems.a_volume / 100);
            systems.a_volume -= Vbai * 100;     // 间隔时间减去百位上的值
            if( Vbai == 9 )
            {
                Vbai = 0;
            }
            else
            {
                Vbai++;
            }
            systems.a_volume += Vbai * 100;    // 百位回位
            putchar( 60, 23, Vbai+'0', 1 );	// 重新打印百位上的值，也即是刷新
            break;
        case 3:
            Vshi = (unsigned int)(systems.a_volume) % 100 / 10 ;
            systems.a_volume -= Vshi * 10;     // 间隔时间减去十位上的值
            if( Vshi == 9 )
            {
                Vshi = 0;
            }
            else
            {
                Vshi++;
            }
            systems.a_volume += Vshi * 10;    // 十位回位
            putchar( 68, 23, Vshi+'0', 1 );	// 重新打印十位上的值，也即是刷新
            break;
        case 4:
            Vge = (unsigned int)(systems.a_volume) % 10;
            systems.a_volume -= Vge;     // 间隔时间减去个位上的值
            if( Vge == 9 )
            {
                Vge = 0;
            }
            else
            {
                Vge++;
            }
            systems.a_volume += Vge;    // 个位回位
            putchar( 76, 23, Vge+'0', 1 );	// 重新打印个位上的值，也即是刷新
            break;
        case 5:
            Vshifen = (unsigned int)(systems.a_volume * 10 ) % 10;
            systems.a_volume -= Vshifen * 0.1;     // 间隔时间减去十分位上的值
            if( Vshifen == 9 )
            {
                Vshifen = 0;
            }
            else
            {
                Vshifen++;
            }
            systems.a_volume += Vshifen * 0.1;    // 十分位回位
            putchar( 88, 23, Vshifen+'0', 1 );	// 重新打印十分位上的值，也即是刷新
            break;
        default: break;
        }
    }
}

void cylSmpTimeSetMenuOnDown(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;
	unsigned int Vbai, Vshi, Vge, Vshifen;
    
	lp = win->curfous;
	
    if ( TIMING == systems.cyls.tim_vol_status )
    {
        switch ( lp->status1 )
        {
        case 2:
            bai = (unsigned int)(systems.a_min / 100);
            systems.a_min -= bai * 100;     // 间隔时间减去百位上的值
            if( bai == 0 )
            {
              bai = 9;
            }
            else
            {
              bai--;
            }
            systems.a_min += bai * 100;    // 百位回位
            putchar( 60, 23, bai+'0', 1 );	// 重新打印百位上的值，也即是刷新
            break;
        case 3:
            shi = (unsigned int)(systems.a_min % 100 /10 );
            systems.a_min -= shi * 10;     // 间隔时间减去十位上的值
            if( shi == 0 )
            {
              shi = 9;
            }
            else
            {
              shi--;
            }
            systems.a_min += shi * 10;    // 十位回位
            putchar( 68, 23, shi+'0', 1 );	// 重新打印十位上的值，也即是刷新
            break;
        case 4:
            ge = (unsigned int)(systems.a_min % 10);
            systems.a_min -= ge;     // 间隔时间减去个位上的值
            if( ge == 0 )
            {
              ge = 9;
            }
            else
            {
              ge--;
            }
            systems.a_min += ge;    // 个位回位
            putchar( 76, 23, ge+'0', 1 );	// 重新打印个位上的值，也即是刷新
            break;
        default: break;
        }
    }
    else
    {        
        switch ( lp->status1 )
        {
        case 2:
            Vbai = (unsigned int)(systems.a_volume / 100);
            systems.a_volume -= Vbai * 100;     // 间隔时间减去百位上的值
            if( Vbai == 0 )
            {
                Vbai = 9;
            }
            else
            {
                Vbai--;
            }
            systems.a_volume += Vbai * 100;    // 百位回位
            putchar( 60, 23, Vbai+'0', 1 );	// 重新打印百位上的值，也即是刷新
            break;
        case 3:
            Vshi = (unsigned int)(systems.a_volume) % 100 / 10 ;
            systems.a_volume -= Vshi * 10;     // 间隔时间减去十位上的值
            if( Vshi == 0 )
            {
                Vshi = 9;
            }
            else
            {
                Vshi--;
            }
            systems.a_volume += Vshi * 10;    // 十位回位
            putchar( 68, 23, Vshi+'0', 1 );	// 重新打印十位上的值，也即是刷新
            break;
        case 4:
            Vge = (unsigned int)(systems.a_volume) % 10;
            systems.a_volume -= Vge;     // 间隔时间减去个位上的值
            if( Vge == 0 )
            {
                Vge = 9;
            }
            else
            {
                Vge--;
            }
            systems.a_volume += Vge;    // 个位回位
            putchar( 76, 23, Vge+'0', 1 );	// 重新打印个位上的值，也即是刷新
            break;
        case 5:
            Vshifen = (unsigned int)(systems.a_volume * 10 ) % 10;
            systems.a_volume -= Vshifen * 0.1;     // 间隔时间减去十分位上的值
            if( Vshifen == 0 )
            {
                Vshifen = 9;
            }
            else
            {
                Vshifen--;
            }
            systems.a_volume += Vshifen * 0.1;    // 十分位回位
            putchar( 88, 23, Vshifen+'0', 1 );	// 重新打印十分位上的值，也即是刷新
            break;
        default: break;
        }
    }
}

void cylSmpTimeSetMenuOnLeft(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;
	unsigned int Vbai, Vshi, Vge, Vshifen;
    
	lp = win->curfous;
	
    if ( TIMING == systems.cyls.tim_vol_status )
    {
        switch ( lp->status1 )
        {
        case 0:
            lp->status1 = 6;
            if ( ENGLISH == systems.language )
            {
                print_str( 52, 3, "TIM", 0 );
                draw_button( 87, 43, "Esc", 1, ENGLISH );
            }
            else
            {
                print_ch_str( 52, 3, "时长", 0 );
                draw_button( 87, 43, "取消", 1, CHINESE );
            }
            break;
        case 1:
            lp->status1 = 0;
            if ( ENGLISH == systems.language )
            {
                print_str( 52, 3, "TIM", 1 );
                print_str( 100, 3, "VOL", 0 );
            }
            else
            {
                print_ch_str( 52, 3, "时长", 1 );
                print_ch_str( 100, 3, "定容", 0 );
            }
            break;
        case 2:
            lp->status1 = 1;
            if ( ENGLISH == systems.language )
            {
                print_str( 100, 3, "VOL", 1 );
            }
            else
            {
                print_ch_str( 100, 3, "定容", 1 );
            }
            bai = (unsigned int)(systems.a_min / 100);
            clr_rect( 59, 23, 8, 12 );
            putchar( 60, 23, bai+'0', 0 );
            break;
        case 3:
            lp->status1 = 2;
            bai = (unsigned int)(systems.a_min / 100);
            shi = (unsigned int)(systems.a_min % 100 /10 );
            fill_rect( 59, 23, 8, 12 );
            clr_rect( 67, 23, 8, 12 );
            putchar( 60, 23, bai+'0', 1 );
            putchar( 68, 23, shi+'0', 0 );
            break;
        case 4:
            lp->status1 = 3;
            shi = (unsigned int)(systems.a_min % 100 /10 );
            ge = (unsigned int)(systems.a_min % 10);
            clr_rect( 75, 23, 8, 12 );
            fill_rect( 67, 23, 8, 12 );
            putchar( 68, 23, shi+'0', 1 );
            putchar( 76, 23, ge+'0', 0 );
            break;
        case 5:
            lp->status1 = 4;
            ge = (unsigned int)(systems.a_min % 10);
            fill_rect( 75, 23, 8, 12 );
            putchar( 76, 23, ge+'0', 1 );
            if ( ENGLISH == systems.language )
            {
                draw_button( 44, 43, "Ok", 0, ENGLISH );
            }
            else
            {
                draw_button( 44, 43, "确定", 0, CHINESE );
            }
            break;
        case 6:
            lp->status1 = 5;
            if ( ENGLISH == systems.language )
            {
                draw_button( 44, 43, "Ok", 1, ENGLISH );
                draw_button( 87, 43, "Esc", 0, ENGLISH );
            }
            else
            {
                draw_button( 44, 43, "确定", 1, CHINESE );
                draw_button( 87, 43, "取消", 0, CHINESE );
            }
            break;
        default: break;
        }
    }
    else
    {
        switch ( lp->status1 )
        {
        case 0:
            lp->status1 = 7;
            if ( ENGLISH == systems.language )
            {
                print_str( 52, 3, "TIM", 0 );
                draw_button( 87, 43, "Esc", 1, ENGLISH );
            }
            else
            {
                print_ch_str( 52, 3, "时长", 0 );
                draw_button( 87, 43, "取消", 1, CHINESE );
            }
            break;
        case 1:
            lp->status1 = 0;
            if ( ENGLISH == systems.language )
            {
                print_str( 52, 3, "TIM", 1 );
                print_str( 100, 3, "VOL", 0 );
            }
            else
            {
                print_ch_str( 52, 3, "时长", 1 );
                print_ch_str( 100, 3, "定容", 0 );
            }
            break;
        case 2:
            lp->status1 = 1;
            if ( ENGLISH == systems.language )
            {
                print_str( 100, 3, "VOL", 1 );
            }
            else
            {
                print_ch_str( 100, 3, "定容", 1 );
            }
            Vbai = (unsigned int)(systems.a_volume / 100);
            clr_rect( 59, 23, 8, 12 );
            putchar( 60, 23, Vbai+'0', 0 );
            break;
        case 3:
            lp->status1 = 2;
            Vbai = (unsigned int)(systems.a_volume / 100);
            Vshi = (unsigned int)(systems.a_volume) % 100 / 10;
            fill_rect( 59, 23, 8, 12 );
            putchar( 60, 23, Vbai+'0', 1 );
            clr_rect( 67, 23, 8, 12 );
            putchar( 68, 23, Vshi+'0', 0 );
            break;
        case 4:
            lp->status1 = 3;
            Vshi = (unsigned int)(systems.a_volume) % 100 / 10;
            Vge = (unsigned int)(systems.a_volume) % 10;
            fill_rect( 67, 23, 8, 12 );
            putchar( 68, 23, Vshi+'0', 1 );
            clr_rect( 75, 23, 8, 12 );
            putchar( 76, 23, Vge+'0', 0 );
            break;
        case 5:
            lp->status1 = 4;
            Vge = (unsigned int)(systems.a_volume) % 10;
            Vshifen = (unsigned int)(systems.a_volume * 10 ) % 10; 
            fill_rect( 75, 23, 8, 12 );
            putchar( 76, 23, Vge+'0', 1 );
            clr_rect( 87, 23, 8, 12 );
            putchar( 88, 23, Vshifen+'0', 0 ); 
            break;
        case 6:
            lp->status1 = 5; 
            Vshifen = (unsigned int)(systems.a_volume * 10 ) % 10; 
            fill_rect( 87, 23, 8, 12 );
            putchar( 88, 23, Vshifen+'0', 1 );  
            if ( ENGLISH == systems.language )
            {
                draw_button( 44, 43, "Ok", 0, ENGLISH );
            }
            else
            {
                draw_button( 44, 43, "确定", 0, CHINESE );
            }
            break;
        case 7:
            lp->status1 = 6;
            if ( ENGLISH == systems.language )
            {
                draw_button( 44, 43, "Ok", 1, ENGLISH );
                draw_button( 87, 43, "Esc", 0, ENGLISH );
            }
            else
            {
                draw_button( 44, 43, "确定", 1, CHINESE );
                draw_button( 87, 43, "取消", 0, CHINESE );
            }
            break;
        default: break;
        }
    }
}

void cylSmpTimeSetMenuOnRight(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;
	unsigned int Vbai, Vshi, Vge, Vshifen;
    
	lp = win->curfous;
    
    if ( TIMING == systems.cyls.tim_vol_status )
    {
        switch ( lp->status1 )
        {
        case 0:
            lp->status1 = 1;
            if ( ENGLISH == systems.language )
            {
                print_str( 52, 3, "TIM", 0 );
                print_str( 100, 3, "VOL", 1 );
            }
            else
            {
                print_ch_str( 52, 3, "时长", 0 );
                print_ch_str( 100, 3, "定容", 1 );
            }
            break;
        case 1:
            lp->status1 = 2;
            bai = (unsigned int)(systems.a_min / 100);
            if ( ENGLISH == systems.language )
            {
                print_str( 100, 3, "VOL", 0 );
            }
            else
            {
                print_ch_str( 100, 3, "定容", 0 );
            }
            fill_rect( 59, 23, 8, 12 );
            putchar( 60, 23, bai+'0', 1 );
            break;
        case 2:
            lp->status1 = 3;
            bai = (unsigned int)(systems.a_min / 100);
            shi = (unsigned int)(systems.a_min % 100 /10 );
            clr_rect( 59, 23, 8, 12 );
            putchar( 60, 23, bai+'0', 0 );
            fill_rect( 67, 23, 8, 12 );
            putchar( 68, 23, shi+'0', 1 );
            break;
        case 3:
            lp->status1 = 4;
            shi = (unsigned int)(systems.a_min % 100 /10 );
            ge = (unsigned int)(systems.a_min % 10);
            clr_rect( 67, 23, 8, 12 );
            putchar( 68, 23, shi+'0', 0 );
            fill_rect( 75, 23, 8, 12 );
            putchar( 76, 23, ge+'0', 1 );
            break;
        case 4:
            lp->status1 = 5;
            ge = (unsigned int)(systems.a_min % 10);
            clr_rect( 75, 23, 8, 12 );
            putchar( 76, 23, ge+'0', 0 );
            if ( ENGLISH == systems.language )
            {
                draw_button( 44, 43, "Ok", 1, ENGLISH );
            }
            else
            {
                draw_button( 44, 43, "确定", 1, CHINESE );
            }
            break;
        case 5:
            lp->status1 = 6;
            if ( ENGLISH == systems.language )
            {
                draw_button( 44, 43, "Ok", 0, ENGLISH );
                draw_button( 87, 43, "Esc", 1, ENGLISH );
            }
            else
            {
                draw_button( 44, 43, "确定", 0, CHINESE );
                draw_button( 87, 43, "取消", 1, CHINESE );
            }
            break;
        case 6:
            lp->status1 = 0;
            if ( ENGLISH == systems.language )
            {
                draw_button( 87, 43, "Esc", 0, ENGLISH );
                print_str( 52, 3, "TIM", 1 );
            }
            else
            {
                draw_button( 87, 43, "取消", 0, CHINESE );
                print_ch_str( 52, 3, "时长", 1 );
            }
            break;
        default: break;
        }
    }
    else
    {
        switch ( lp->status1 )
        {
        case 0:
            lp->status1 = 1;
            if ( ENGLISH == systems.language )
            {
                print_str( 52, 3, "TIM", 0 );
                print_str( 100, 3, "VOL", 1 );
            }
            else
            {
                print_ch_str( 52, 3, "时长", 0 );
                print_ch_str( 100, 3, "定容", 1 );
            }
            break;
        case 1:
            lp->status1 = 2;
            Vbai = (unsigned int)(systems.a_volume / 100);
            if ( ENGLISH == systems.language )
            {
                print_str( 100, 3, "VOL", 0 );
            }
            else
            {
                print_ch_str( 100, 3, "定容", 0 );
            }
            fill_rect( 59, 23, 8, 12 );
            putchar( 60, 23, Vbai+'0', 1 );
            break;
        case 2:
            lp->status1 = 3;
            Vbai = (unsigned int)(systems.a_volume / 100);
            Vshi = (unsigned int)(systems.a_volume) % 100 / 10;
            clr_rect( 59, 23, 8, 12 );
            putchar( 60, 23, Vbai+'0', 0 );
            fill_rect( 67, 23, 8, 12 );
            putchar( 68, 23, Vshi+'0', 1 );
            break;
        case 3:
            lp->status1 = 4;
            Vshi = (unsigned int)(systems.a_volume) % 100 / 10;
            Vge = (unsigned int)(systems.a_volume) % 10;
            clr_rect( 67, 23, 8, 12 );
            putchar( 68, 23, Vshi+'0', 0 );
            fill_rect( 75, 23, 8, 12 );
            putchar( 76, 23, Vge+'0', 1 );
            break;
        case 4:
            lp->status1 = 5;
            Vge = (unsigned int)(systems.a_volume) % 10;
            Vshifen = (unsigned int)(systems.a_volume * 10 ) % 10;
            clr_rect( 75, 23, 8, 12 );
            putchar( 76, 23, Vge+'0', 0 );
            fill_rect( 87, 23, 8, 12 );
            putchar( 88, 23, Vshifen+'0', 1 ); 
            break;
        case 5:
            lp->status1 = 6;
            Vshifen = (unsigned int)(systems.a_volume * 10 ) % 10;
            clr_rect( 87, 23, 8, 12 );
            putchar( 88, 23, Vshifen+'0', 0 ); 
            if ( ENGLISH == systems.language )
            {
                draw_button( 44, 43, "Ok", 1, ENGLISH );
            }
            else
            {
                draw_button( 44, 43, "确定", 1, CHINESE );
            }
            break;
        case 6:
            lp->status1 = 7;
            if ( ENGLISH == systems.language )
            {
                draw_button( 44, 43, "Ok", 0, ENGLISH );
                draw_button( 87, 43, "Esc", 1, ENGLISH );
            }
            else
            {
                draw_button( 44, 43, "确定", 0, CHINESE );
                draw_button( 87, 43, "取消", 1, CHINESE );
            }
            break;
        case 7:
            lp->status1 = 0;
            if ( ENGLISH == systems.language )
            {
                draw_button( 87, 43, "Esc", 0, ENGLISH );
                print_str( 52, 3, "TIM", 1 );
            }
            else
            {
                draw_button( 87, 43, "取消", 0, CHINESE );
                print_ch_str( 52, 3, "时长", 1 );
            }
            break;
        default: break;
        }
    }
}

void cylSmpTimeSetMenuOnOk(void)
{
	struct MENU *lp;
	unsigned int bai, shi, ge;     // 调整采样时长的个十百位值
    unsigned int Vbai, Vshi, Vge, Vshifen;    // 调整采样体积的个十百位值
    
	lp = win->curfous;
    
    if ( 0 == lp->status1 || 1 == lp->status1 )
    {
        if ( SAMPLING == systems.status )
        {            
            win->oldCurfous = win->curfous;
            win->curfous = win->errMenu;
            win->curfous->show();
            return;
        }
        
        clr_rect( 40, 4, 10, 10 );    // 擦除钩
        clr_rect( 87, 4, 10, 10 );    // 擦除钩
        clr_rect( 58, 23, 40, 12 );   // 擦除中间的数字
        clr_rect( 101, 25, 18, 12 );  // 擦除 min 或 L 字样
        
        if ( TIMING == systems.cyls.tim_vol_status )
        {
            systems.cyls.tim_vol_status = VOLUME;  
            systems.a_volume = systems.cyls.smp_volume;
            Vbai = (unsigned int)(systems.cyls.smp_volume / 100 );
            Vshi = (unsigned int)(systems.cyls.smp_volume) % 100 / 10 ;
            Vge = (unsigned int)(systems.cyls.smp_volume) % 10 ;
            Vshifen = (unsigned int)(systems.cyls.smp_volume * 10 ) % 10 ;
            
            draw_symbol( 87, 4, 10, 10, gou_mu, 0 );     // 在采样定容选择框打钩
            draw_point( 84, 32 );         // 画小数点
            print_str( 101, 23, "L", 0 );
            putchar( 60, 23, Vbai+'0', 0 );
            putchar( 68, 23, Vshi+'0', 0 );
            putchar( 76, 23, Vge+'0', 0 );
            putchar( 88, 23, Vshifen+'0', 0 );
        }
        else
        {
            systems.cyls.tim_vol_status = TIMING;
            bai = (unsigned int)(systems.a_min / 100);
            shi = (unsigned int)(systems.a_min % 100 /10 );
            ge  = (unsigned int)(systems.a_min % 10);
            
            draw_symbol( 40, 4, 10, 10, gou_mu, 0 );     // 在采样时长选择框打钩                        
            draw_line( 85, 23, 85, 35 );       // 描绘内部一个显示数值的小矩形框的竖直线
            draw_symbol( 86, 23, 12, 12, up_down_mu, 0 );
            print_str( 101, 23, "min", 0 );
            
            putchar( 60, 23, bai+'0', 0 );
            putchar( 68, 23, shi+'0', 0 );
            putchar( 76, 23, ge+'0', 0 );
        }
    }
    else
    {
        if ( TIMING == systems.cyls.tim_vol_status )
        {
            if ( 5 == lp->status1 )		// 获取“确定”焦点
            {
                systems.cyls.smp_time = systems.a_min;		// 确认设置循环模式采样时长
                if ( lp->topMenu )
                {
                    systems.a_min = 1;
                    win->curfous = lp->topMenu;
                    win->curfous->show();
                }
            }
            else if ( 6 == lp->status1 )		// 获取”取消“焦点
            {
                if ( lp->topMenu )
                {
                    win->curfous = lp->topMenu;
                    win->curfous->show();
                }
            }
        }
        else
        {
            if ( 6 == lp->status1 )		// 获取“确定”焦点
            {
                systems.cyls.smp_volume = systems.a_volume;		// 确认设置循环模式采样时长
                if ( lp->topMenu )
                {
                    systems.a_volume = 1.0;
                    win->curfous = lp->topMenu;
                    win->curfous->show();
                }
            }
            else if ( 7 == lp->status1 )		// 获取”取消“焦点
            {
                if ( lp->topMenu )
                {
                    win->curfous = lp->topMenu;
                    win->curfous->show();
                }
            }
        }
    }
}

void cylSmpTimeSetMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		systems.a_min = 1;		// 取消设置循环模式采样时长
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void cylSmpTimeSetMenuExec(void)
{

}


/*
 * 循环模式循环次数设置菜单
 */
void cylCyclesSetMenuShow(void)
{
	struct MENU *lp;
	unsigned int shi, ge;
	lp = win->curfous;
	systems.a_min = systems.cyls.cyl_num;

	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );		// 打印一个像扳手一样的设置图标
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	draw_dialog( 0 );          // 描绘一个矩形框
	draw_rect( 51, 22, 35, 14 );
	draw_line( 71, 23, 71, 35 );
	draw_symbol( 72, 23, 12, 12, up_down_mu, 0 );

	shi = (unsigned int)(systems.a_min / 10);
	ge  = (unsigned int)(systems.a_min % 10);

	if ( ENGLISH == systems.language )
	{
		print_str( 40, 3, "Set CYL Cycles", 0 );
		print_str( 87, 23, "cycles", 0 );
		switch ( lp->status1 )
		{
		case 0:
			fill_rect( 53, 23, 16, 12 );
			putchar( 54, 23, shi+'0', 1 );  // 打印十位值
			putchar( 62, 23, ge+'0', 1 );  //打印个位值
			draw_button( 44, 43, "Ok", 0, ENGLISH );
			draw_button( 87, 43, "Esc", 0, ENGLISH );
			break;
		case 1:
			putchar( 54, 23, shi+'0', 0 );  // 打印十位值
			putchar( 62, 23, ge+'0', 0 );  //打印个位值
			draw_button( 44, 43, "Ok", 1, ENGLISH );
			draw_button( 87, 43, "Esc", 0, ENGLISH );
			break;
		case 2:
			putchar( 54, 23, shi+'0', 0 );  // 打印十位值
			putchar( 62, 23, ge+'0', 0 );  //打印个位值
			draw_button( 44, 43, "Ok", 0, ENGLISH );
			draw_button( 87, 43, "Esc", 1, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		print_ch_str( 45, 3, "设置循环次数", 0 );
		print_ch_str( 87, 23, "次", 0 );
		switch ( lp->status1 )
		{
		case 0:
			fill_rect( 53, 23, 16, 12 );
			putchar( 54, 23, shi+'0', 1 );  // 打印十位值
			putchar( 62, 23, ge+'0', 1 );  //打印个位值
			draw_button( 44, 43, "确定", 0, CHINESE );
			draw_button( 87, 43, "取消", 0, CHINESE );
			break;
		case 1:
			putchar( 54, 23, shi+'0', 0 );  // 打印十位值
			putchar( 62, 23, ge+'0', 0 );  //打印个位值
			draw_button( 44, 43, "确定", 1, CHINESE );
			draw_button( 87, 43, "取消", 0, CHINESE );
			break;
		case 2:
			putchar( 54, 23, shi+'0', 0 );  // 打印十位值
			putchar( 62, 23, ge+'0', 0 );  //打印个位值
			draw_button( 44, 43, "确定", 0, CHINESE );
			draw_button( 87, 43, "取消", 1, CHINESE );
			break;
		default: break;
		}
	}
}

void cylCyclesSetMenuOnUp(void)
{
	struct MENU *lp;
	unsigned int shi, ge;
	lp = win->curfous;
	if ( 0 == lp->status1 )
	{
		if ( 10 == systems.a_min )
		{
			systems.a_min = 1;
		}
		else
		{
			systems.a_min++;
		}
		shi = (unsigned int)(systems.a_min / 10);
		ge  = (unsigned int)(systems.a_min % 10);
		putchar( 54, 23, shi+'0', 1 );  // 打印十位值
		putchar( 62, 23, ge+'0', 1 );  //打印个位值
	}
}

void cylCyclesSetMenuOnDown(void)
{
	struct MENU *lp;
	unsigned int shi, ge;
	lp = win->curfous;
	if ( 0 == lp->status1 )
	{
		if ( 1 == systems.a_min )
		{
			systems.a_min = 10;
		}
		else
		{
			systems.a_min--;
		}
		shi = (unsigned int)(systems.a_min / 10);
		ge  = (unsigned int)(systems.a_min % 10);
		putchar( 54, 23, shi+'0', 1 );  // 打印十位值
		putchar( 62, 23, ge+'0', 1 );  //打印个位值
	}
}

void cylCyclesSetMenuOnLeft(void)
{
	struct MENU *lp;
	unsigned int shi, ge;
	shi = (unsigned int)(systems.a_min / 10);
	ge  = (unsigned int)(systems.a_min % 10);
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		lp->status1 = 2;
		clr_rect( 53, 23, 16, 12 );
		putchar( 54, 23, shi+'0', 0 );  // 打印十位值
		putchar( 62, 23, ge+'0', 0 );  //打印个位值
		if ( ENGLISH == systems.language )
		{
			draw_button( 87, 43, "Esc", 1, ENGLISH );
		}
		else
		{
			draw_button( 87, 43, "取消", 1, CHINESE );
		}
		break;
	case 1:
		lp->status1 = 0;
		fill_rect( 53, 23, 16, 12 );
		putchar( 54, 23, shi+'0', 1 );  // 打印十位值
		putchar( 62, 23, ge+'0', 1 );  //打印个位值
		if ( ENGLISH == systems.language )
		{
			draw_button( 44, 43, "Ok", 0, ENGLISH );
		}
		else
		{
			draw_button( 44, 43, "确定", 0, CHINESE );
		}
		break;
	case 2:
		lp->status1 = 1;
		if ( ENGLISH == systems.language )
		{
			draw_button( 44, 43, "Ok", 1, ENGLISH );
			draw_button( 87, 43, "Esc", 0, ENGLISH );
		}
		else
		{
			draw_button( 44, 43, "确定", 1, CHINESE );
			draw_button( 87, 43, "取消", 0, CHINESE );
		}
		break;
	default: break;
	}
}

void cylCyclesSetMenuOnRight(void)
{
	struct MENU *lp;
	unsigned int shi, ge;
	shi = (unsigned int)(systems.a_min / 10);
	ge  = (unsigned int)(systems.a_min % 10);
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		lp->status1 = 1;
		clr_rect( 53, 23, 16, 12 );
		putchar( 54, 23, shi+'0', 0 );  // 打印十位值
		putchar( 62, 23, ge+'0', 0 );  //打印个位值
		if ( ENGLISH == systems.language )
		{
			draw_button( 44, 43, "Ok", 1, ENGLISH );
		}
		else
		{
			draw_button( 44, 43, "确定", 1, CHINESE );
		}
		break;
	case 1:
		lp->status1 = 2;
		if ( ENGLISH == systems.language )
		{
			draw_button( 44, 43, "Ok", 0, ENGLISH );
			draw_button( 87, 43, "Esc", 1, ENGLISH );
		}
		else
		{
			draw_button( 44, 43, "确定", 0, CHINESE );
			draw_button( 87, 43, "取消", 1, CHINESE );
		}
		break;
	case 2:
		lp->status1 = 0;
		fill_rect( 53, 23, 16, 12 );
		putchar( 54, 23, shi+'0', 1 );  // 打印十位值
		putchar( 62, 23, ge+'0', 1 );  //打印个位值
		if ( ENGLISH == systems.language )
		{
			draw_button( 87, 43, "Esc", 0, ENGLISH );
		}
		else
		{
			draw_button( 87, 43, "取消", 0, CHINESE );
		}
		break;
	default: break;
	}
}

void cylCyclesSetMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( 1 == lp->status1 )
	{
		systems.cyls.cyl_num = systems.a_min;	// 确定设置循环次数
		if ( lp->topMenu )
		{
			systems.a_min = 1;
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
	else if ( 2 == lp->status1 )
	{
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
}

void cylCyclesSetMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	systems.a_min = 1;	// 取消设置循环次数
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void cylCyclesSetMenuExec(void)
{

}




/*
 * 语言设置菜单
 */
void languageSetMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );		// 打印一个像扳手一样的设置图标
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	draw_dialog( 0 );          // 描绘一个矩形框
	draw_line( 55, 36, 106, 36 ); //打印一条在靠选择栏的直线
	draw_symbol( 43, 23, 12, 12, left_mu, 0 );   //左三角
	draw_symbol( 106, 23, 12, 12, right_mu, 0 );  //右三角

	systems.set_language = systems.language;

	if ( ENGLISH == systems.language )	// 当前语言为英文
	{
		print_str( 49, 3, "Set Language", 0 );	// 打印标题
		switch ( lp->status1 )
		{
		case 0:
			print_str( 56, 23, "English", 1 );   //打印选择栏处
			draw_button( 43, 43, "Ok", 0, ENGLISH );    //打印Ok按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );    //打印Esc按钮
			break;
		case 1:
			print_str( 56, 23, "English", 0 );   //打印选择栏处
			draw_button( 43, 43, "Ok", 1, ENGLISH );    //打印Ok按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );    //打印Esc按钮
			break;
		case 2:
			print_str( 56, 23, "English", 0 );   //打印选择栏处
			draw_button( 43, 43, "Ok", 0, ENGLISH );    //打印Ok按钮
			draw_button( 87, 43, "Esc", 1, ENGLISH );    //打印Esc按钮
			break;
		default: break;
		}
	}
	else	// 否则当前语言为中文
	{
		print_ch_str( 53, 3, "请设置语言", 0 );	// 打印标题
		switch ( lp->status1 )
		{
		case 0:
			print_ch_str( 56, 23, "简体中文", 1 );   //打印选择栏处
			draw_button( 43, 43, "确定", 0, CHINESE );    //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );    //打印取消按钮
			break;
		case 1:
			print_ch_str( 56, 23, "简体中文", 0 );   //打印选择栏处
			draw_button( 43, 43, "确定", 1, CHINESE );    //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );    //打印取消按钮
			break;
		case 2:
			print_ch_str( 56, 23, "简体中文", 0 );   //打印选择栏处
			draw_button( 43, 43, "确定", 0, CHINESE );    //打印确定按钮
			draw_button( 87, 43, "取消", 1, CHINESE );    //打印取消按钮
			break;
		default: break;
		}
	}
}

void languageSetMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if( ENGLISH == systems.language )	// 当前语言为英文
	{
		clr_rect( 56, 23, 48, 12 );
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 0 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 0 );   // 打印选择栏处
			}
			draw_button( 43, 43, "Ok", 1, ENGLISH );    //打印Ok按钮
			break;
		case 1:
			lp->status1 = 0;
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 1 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 1 );   // 打印选择栏处
			}
			draw_button( 43, 43, "Ok", 0, ENGLISH );    //打印Ok按钮
			break;
		case 2:
			lp->status1 = 0;
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 1 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 1 );   // 打印选择栏处
			}
			draw_button( 87, 43, "Esc", 0, ENGLISH );    //打印Esc按钮
			break;
		default: break;
		}
	}
	else	// 否则当前语言为中文
	{
		clr_rect( 56, 23, 48, 12 );
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 0 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 0 );   // 打印选择栏处
			}
			draw_button( 43, 43, "确定", 1, CHINESE );    //打印确定按钮
			break;
		case 1:
			lp->status1 = 0;
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 1 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 1 );   // 打印选择栏处
			}
			draw_button( 43, 43, "确定", 0, CHINESE );    //打印确定按钮
			break;
		case 2:
			lp->status1 = 0;
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 1 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 1 );   // 打印选择栏处
			}
			draw_button( 87, 43, "取消", 0, CHINESE );    //打印取消按钮
			break;
		default: break;
		}
	}
}

void languageSetMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if( ENGLISH == systems.language )	// 当前语言为英文
	{
		clr_rect( 56, 23, 48, 12 );
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 0 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 0 );   // 打印选择栏处
			}
			draw_button( 43, 43, "Ok", 1, ENGLISH );    //打印Ok按钮
			break;
		case 1:
			lp->status1 = 0;
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 1 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 1 );   // 打印选择栏处
			}
			draw_button( 43, 43, "Ok", 0, ENGLISH );    //打印Ok按钮
			break;
		case 2:
			lp->status1 = 0;
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 1 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 1 );   // 打印选择栏处
			}
			draw_button( 87, 43, "Esc", 0, ENGLISH );    //打印Esc按钮
			break;
		default: break;
		}
	}
	else	// 否则当前语言为中文
	{
		clr_rect( 56, 23, 48, 12 );
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 0 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 0 );   // 打印选择栏处
			}
			draw_button( 43, 43, "确定", 1, CHINESE );    //打印确定按钮
			break;
		case 1:
			lp->status1 = 0;
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 1 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 1 );   // 打印选择栏处
			}
			draw_button( 43, 43, "确定", 0, CHINESE );    //打印确定按钮
			break;
		case 2:
			lp->status1 = 0;
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 1 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 1 );   // 打印选择栏处
			}
			draw_button( 87, 43, "取消", 0, CHINESE );    //打印取消按钮
			break;
		default: break;
		}
	}
}

void languageSetMenuOnLeft(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if( ENGLISH == systems.language )	// 当前语言为英文
	{
		switch ( lp->status1 )
		{
		case 0:
			systems.set_language = !(systems.set_language);		// 将设置的语言值取反
			clr_rect( 56, 23, 48, 12 );
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 1 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 1 );   // 打印选择栏处
			}
			break;
		case 1:
			lp->status1 = 2;
			draw_button( 43, 43, "Ok", 0, ENGLISH );    //打印Ok按钮
			draw_button( 87, 43, "Esc", 1, ENGLISH );    //打印Esc按钮
			break;
		case 2:
			lp->status1 = 1;
			draw_button( 43, 43, "Ok", 1, ENGLISH );    //打印Ok按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );    //打印Esc按钮
			break;
		default: break;
		}
	}
	else	// 否则当前语言为中文
	{
		switch ( lp->status1 )
		{
		case 0:
			clr_rect( 56, 23, 48, 12 );
			systems.set_language = !(systems.set_language);
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 1 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 1 );   // 打印选择栏处
			}
			break;
		case 1:
			lp->status1 = 2;
			draw_button( 43, 43, "确定", 0, CHINESE );    //打印确定按钮
			draw_button( 87, 43, "取消", 1, CHINESE );    //打印取消按钮
			break;
		case 2:
			lp->status1 = 1;
			draw_button( 43, 43, "确定", 1, CHINESE );    //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );    //打印取消按钮
			break;
		default: break;
		}
	}
}

void languageSetMenuOnRight(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if( ENGLISH == systems.language )	// 当前语言为英文
	{
		switch ( lp->status1 )
		{
		case 0:
			clr_rect( 56, 23, 48, 12 );
			systems.set_language = !(systems.set_language);
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 1 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 1 );   // 打印选择栏处
			}
			break;
		case 1:
			lp->status1 = 2;
			draw_button( 43, 43, "Ok", 0, ENGLISH );    //打印Ok按钮
			draw_button( 87, 43, "Esc", 1, ENGLISH );    //打印Esc按钮
			break;
		case 2:
			lp->status1 = 1;
			draw_button( 43, 43, "Ok", 1, ENGLISH );    //打印Ok按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );    //打印Esc按钮
			break;
		default: break;
		}
	}
	else	// 否则当前语言为中文
	{
		switch ( lp->status1 )
		{
		case 0:
			clr_rect( 56, 23, 48, 12 );
			systems.set_language = !(systems.set_language);
			if ( ENGLISH == systems.set_language )
			{
				print_str( 56, 23, "English", 1 );   // 打印选择栏处
			}
			else
			{
				print_ch_str( 56, 23, "简体中文", 1 );   // 打印选择栏处
			}
			break;
		case 1:
			lp->status1 = 2;
			draw_button( 43, 43, "确定", 0, CHINESE );    //打印确定按钮
			draw_button( 87, 43, "取消", 1, CHINESE );    //打印取消按钮
			break;
		case 2:
			lp->status1 = 1;
			draw_button( 43, 43, "确定", 1, CHINESE );    //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );    //打印取消按钮
			break;
		default: break;
		}
	}
}

void languageSetMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( 1 == lp->status1 )		// 获取确定焦点
	{
		systems.language = systems.set_language;	// 确认设置语言
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
	else if ( 2 == lp->status1 )		// 获取取消焦点, 取消语言设置
	{
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
}

void languageSetMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;

	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void languageSetMenuExec(void)
{

}


/*
 * 系统时间设置菜单
 */
void sysTimeSetMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );		// 打印一个像扳手一样的设置图标
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	draw_dialog( 0 );          // 描绘一个矩形框

	systems.temp_hour = systems.sys_time.hour;
	systems.temp_min = systems.sys_time.min;

	if ( ENGLISH == systems.language )
	{
		print_str( 44, 3, "Set Sys Time", 0 );
		switch ( lp->status1 )
		{
		case 0:
			print_time( systems.temp_hour, systems.temp_min,
           		59, 23, HOUR );      //打印时间，并使时处于被选中状态
			draw_button( 43, 40, "Ok", 0, ENGLISH );
	        draw_button( 87, 40, "Esc", 0, ENGLISH );
			break;
		case 1:
			print_time( systems.temp_hour, systems.temp_min,
           		59, 23, MIN );      //打印时间，并使分处于被选中状态
	        draw_button( 43, 40, "Ok", 0, ENGLISH );
	        draw_button( 87, 40, "Esc", 0, ENGLISH );
			break;
		case 2:
			print_time( systems.temp_hour, systems.temp_min,
           		59, 23, HOUR_MIN );      //打印时间
	        draw_button( 43, 40, "Ok", 1, ENGLISH );
	        draw_button( 87, 40, "Esc", 0, ENGLISH );
			break;
		case 3:
			print_time( systems.temp_hour, systems.temp_min,
           		59, 23, HOUR_MIN );      //打印时间
	        draw_button( 43, 40, "Ok", 0, ENGLISH );
	        draw_button( 87, 40, "Esc", 1, ENGLISH );
			break;
		default: break;
		}
	}
	else
	{
		print_ch_str( 46, 3, "设置系统时间", 0 );
		switch ( lp->status1 )
		{
		case 0:
			print_time( systems.temp_hour, systems.temp_min,
			     59, 23, HOUR );      //打印时间，并使时处于被选中状态
	        draw_button( 43, 40, "确定", 0, CHINESE );
	        draw_button( 87, 40, "取消", 0, CHINESE );
			break;
		case 1:
			print_time( systems.temp_hour, systems.temp_min,
        		59, 23, MIN );      //打印时间，并使分处于被选中状态
			break;
		case 2:
            print_time( systems.temp_hour, systems.temp_min,
            	59, 23, HOUR_MIN );      //打印时间
	        draw_button( 43, 40, "确定", 1, CHINESE );
	        draw_button( 87, 40, "取消", 0, CHINESE );
			break;
		case 3:
			print_time( systems.temp_hour, systems.temp_min,
			    59, 23, HOUR_MIN );      //打印时间
	        draw_button( 43, 40, "确定", 0, CHINESE );
	        draw_button( 87, 40, "取消", 1, CHINESE );
			break;
		default: break;
		}
	}
}

void sysTimeSetMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		if ( 23 == systems.temp_hour )
		{
			systems.temp_hour = 0;
		}
		else
		{
			systems.temp_hour++;
		}
		print_time( systems.temp_hour, systems.temp_min, 59, 23, HOUR );
		break;
	case 1:
		if ( 59 == systems.temp_min )
		{
			systems.temp_min = 0;
		}
		else
		{
			systems.temp_min++;
		}
		print_time( systems.temp_hour, systems.temp_min, 59, 23, MIN );
		break;
	default: break;
	}
}

void sysTimeSetMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		if ( 0 == systems.temp_hour )
		{
			systems.temp_hour = 23;
		}
		else
		{
			systems.temp_hour--;
		}
		print_time( systems.temp_hour, systems.temp_min, 59, 23, HOUR );
		break;
	case 1:
		if ( 0 == systems.temp_min )
		{
			systems.temp_min = 59;
		}
		else
		{
			systems.temp_min--;
		}
		print_time( systems.temp_hour, systems.temp_min, 59, 23, MIN );
		break;
	default: break;
	}
}

void sysTimeSetMenuOnLeft(void)
{
	struct MENU *lp;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		lp->status1 = 3;
		print_time( systems.temp_hour, systems.temp_min, 59, 23, HOUR_MIN );
		if ( ENGLISH == systems.language )
		{
			draw_button( 87, 40, "Esc", 1, ENGLISH );
		}
		else
		{
			draw_button( 87, 40, "取消", 1, CHINESE );
		}
		break;
	case 1:
		lp->status1 = 0;
		print_time( systems.temp_hour, systems.temp_min, 59, 23, HOUR );
		break;
	case 2:
		lp->status1 = 1;
		print_time( systems.temp_hour, systems.temp_min, 59, 23, MIN );
		if ( ENGLISH == systems.language )
		{
			draw_button( 43, 40, "Ok", 0, ENGLISH );
		}
		else
		{
			draw_button( 43, 40, "确定", 0, CHINESE );
		}
		break;
	case 3:
		lp->status1 = 2;
		if ( ENGLISH == systems.language )
		{
			draw_button( 43, 40, "Ok", 1, ENGLISH );
	        draw_button( 87, 40, "Esc", 0, ENGLISH );
		}
		else
		{
			draw_button( 43, 40, "确定", 1, CHINESE );
	        draw_button( 87, 40, "取消", 0, CHINESE );
		}
		break;
	default: break;
	}
}

void sysTimeSetMenuOnRight(void)
{
	struct MENU *lp;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:
		lp->status1 = 1;
		print_time( systems.temp_hour, systems.temp_min, 59, 23, MIN );
		break;
	case 1:
		lp->status1 = 2;
		print_time( systems.temp_hour, systems.temp_min, 59, 23, HOUR_MIN );
		if ( ENGLISH == systems.language )
		{
			draw_button( 43, 40, "Ok", 1, ENGLISH );
		}
		else
		{
			draw_button( 43, 40, "确定", 1, CHINESE );
		}
		break;
	case 2:
		lp->status1 = 3;
		if ( ENGLISH == systems.language )
		{
			draw_button( 43, 40, "Ok", 0, ENGLISH );
	        draw_button( 87, 40, "Esc", 1, ENGLISH );
		}
		else
		{
			draw_button( 43, 40, "确定", 0, CHINESE );
	        draw_button( 87, 40, "取消", 1, CHINESE );
		}
		break;
	case 3:
		lp->status1 = 0;
		if ( ENGLISH == systems.language )
		{
			draw_button( 87, 40, "Esc", 0, ENGLISH );
		}
		else
		{
			draw_button( 87, 40, "取消", 0, CHINESE );
		}
		print_time( systems.temp_hour, systems.temp_min, 59, 23, HOUR );
		break;
	default: break;
	}
}

void sysTimeSetMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( 2 == lp->status1 )		// “确定”获得焦点
	{
		systems.sys_time.hour = systems.temp_hour;	// 确认设置系统时间
		systems.sys_time.min  = systems.temp_min;
        Set_time( systems.sys_time.hour, systems.sys_time.min, 0 );
		if ( lp->topMenu )
		{
			systems.temp_hour = 0;
			systems.temp_hour = 0;
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
	else if ( 3 == lp->status1 )		// “取消”获得焦点
	{
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
	}
}

void sysTimeSetMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void sysTimeSetMenuExec(void)
{

}


/*
 * 定时关机设置菜单
 */
void timePowerOffSetMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );		// 打印一个像扳手一样的设置图标
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
    draw_dialog(1);     //在左边画一个椭圆框
    fill_rect( 118, 22, 6, 36 );   //填充滚动条
    draw_symbol( 118, 18, 6, 3, gundong_up_mu, 0 );    //画上三角图标
    draw_symbol( 118, 59, 6, 3, gundong_down_mu, 0 );  //画下三角图标
    clr_rect( 119, 24+lp->status1*10, 4, 12 );       //清空滚动条滚动粒所来位置处

    if ( ENGLISH == systems.language )
    {
    	print_str( 40, 3, "Set Power off", 0 );    //打印英文标题
    	switch ( lp->status1 )
    	{
    	case 0:          //在0处，也即是在设置"关机时间"处
            fill_rect( 36, 18, 76, 14 );    //填充第一行，也即第一行的位置获得焦点
            print_str( 38, 19, "Off Time", 1 );
            print_str( 38, 34, "ON", 0 );
            print_str( 38, 49, "Exit", 0 );
    		break;
    	case 1:    //在1处，也即是在"启用"位置处
            fill_rect( 36, 33, 76, 14 );    //在第二行处填充，也即第二行位置获得焦点
    		print_str( 38, 19, "Off Time", 0 );
    		print_str( 38, 34, "ON", 1 );
            print_str( 38, 49, "Exit", 0 );
    		break;
    	case 2:   //在2处，也即是在"退出"位置处
    		print_str( 38, 19, "Off Time", 0 );
    		print_str( 38, 34, "ON", 0 );
            fill_rect( 36, 48, 76, 14 );     //填充第三行，也即第三行位置获得焦点
            print_str( 38, 49, "Exit", 1 );
    		break;
    	default: break;
    	}
    }
    else
    {
    	print_ch_str( 47, 3, "设置定时关机", 0 );
    	switch ( lp->status1 )
    	{
    	case 0:          //在0处，也即是在设置"关机时间"处
            fill_rect( 36, 18, 76, 14 );    //填充第一行，也即第一行的位置获得焦点
            print_ch_str( 38, 19, "关机时间", 1 );
            print_ch_str( 38, 34, "启用", 0 );
            print_ch_str( 38, 49, "退出", 0 );
    		break;
    	case 1:    //在1处，也即是在"启用"位置处
    		print_ch_str( 38, 19, "关机时间", 0 );
            fill_rect( 36, 33, 76, 14 );    //在第二行处填充，也即第二行位置获得焦点
            print_ch_str( 38, 34, "启用", 1 );
            print_ch_str( 38, 49, "退出", 0 );
    		break;
    	case 2:   //在2处，也即是在"退出"位置处
    		print_ch_str( 38, 19, "关机时间", 0 );
    		print_ch_str( 38, 34, "启用", 0 );
            fill_rect( 36, 48, 76, 14 );     //填充第三行，也即第三行位置获得焦点
            print_ch_str( 38, 49, "退出", 1 );
    		break;
    	default: break;
    	}
    }

    power_status_show(lp);
}

void timePowerOffSetMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;
	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );		// 打印一个像扳手一样的设置图标
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
    draw_dialog(1);     //在左边画一个椭圆框
    fill_rect( 118, 22, 6, 36 );   //填充滚动条
    draw_symbol( 118, 18, 6, 3, gundong_up_mu, 0 );    //画上三角图标
    draw_symbol( 118, 59, 6, 3, gundong_down_mu, 0 );  //画下三角图标
    clr_rect( 119, 24+lp->status1*10, 4, 12 );       //清空滚动条滚动粒所来位置处

    fill_rect( 119, 24+lp->status1*10, 4, 12 );
    if ( ENGLISH == systems.language )
    {
    	print_str( 40, 3, "Set Power off", 0 );    //打印英文标题
    	switch ( lp->status1 )
    	{
    	case 0:          //在0处，也即是在设置"关机时间"处
    		lp->status1 = 2;
    		print_str( 38, 19, "Off Time", 0 );
    		print_str( 38, 34, "ON", 0 );
            fill_rect( 36, 48, 76, 14 );     //填充第三行，也即第三行位置获得焦点
            print_str( 38, 49, "Exit", 1 );
    		break;
    	case 1:    //在1处，也即是在"启用"位置处
    		lp->status1 = 0;
            fill_rect( 36, 18, 76, 14 );    //填充第一行，也即第一行的位置获得焦点
            print_str( 38, 19, "Off Time", 1 );
            print_str( 38, 34, "ON", 0 );
            print_str( 38, 49, "Exit", 0 );
    		break;
    	case 2:   //在2处，也即是在"退出"位置处
    		lp->status1 = 1;
            fill_rect( 36, 33, 76, 14 );    //在第二行处填充，也即第二行位置获得焦点
    		print_str( 38, 19, "Off Time", 0 );
    		print_str( 38, 34, "ON", 1 );
            print_str( 38, 49, "Exit", 0 );
    		break;
    	default: break;
    	}
    }
    else
    {
    	print_ch_str( 47, 3, "设置定时关机", 0 );
    	switch ( lp->status1 )
    	{
    	case 0:          //在0处，也即是在设置"关机时间"处
    		lp->status1 = 2;
    		print_ch_str( 38, 19, "关机时间", 0 );
    		print_ch_str( 38, 34, "启用", 0 );
            fill_rect( 36, 48, 76, 14 );     //填充第三行，也即第三行位置获得焦点
            print_ch_str( 38, 49, "退出", 1 );
    		break;
    	case 1:    //在1处，也即是在"启用"位置处
    		lp->status1 = 0;
            fill_rect( 36, 18, 76, 14 );    //填充第一行，也即第一行的位置获得焦点
            print_ch_str( 38, 19, "关机时间", 1 );
            print_ch_str( 38, 34, "启用", 0 );
            print_ch_str( 38, 49, "退出", 0 );
    		break;
    	case 2:   //在2处，也即是在"退出"位置处
    		lp->status1 = 1;
    		print_ch_str( 38, 19, "关机时间", 0 );
            fill_rect( 36, 33, 76, 14 );    //在第二行处填充，也即第二行位置获得焦点
            print_ch_str( 38, 34, "启用", 1 );
            print_ch_str( 38, 49, "退出", 0 );
    		break;
    	default: break;
    	}
    }

    power_status_show(lp);
    clr_rect( 119, 24+lp->status1*10, 4, 12 );
}

void timePowerOffSetMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;
	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );		// 打印一个像扳手一样的设置图标
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
    draw_dialog(1);     //在左边画一个椭圆框
    fill_rect( 118, 22, 6, 36 );   //填充滚动条
    draw_symbol( 118, 18, 6, 3, gundong_up_mu, 0 );    //画上三角图标
    draw_symbol( 118, 59, 6, 3, gundong_down_mu, 0 );  //画下三角图标
    clr_rect( 119, 24+lp->status1*10, 4, 12 );       //清空滚动条滚动粒所来位置处

    fill_rect( 119, 24+lp->status1*10, 4, 12 );
    if ( ENGLISH == systems.language )
    {
    	print_str( 40, 3, "Set Power off", 0 );    //打印英文标题
    	switch ( lp->status1 )
    	{
    	case 0:          //在0处，也即是在设置"关机时间"处
    		lp->status1 = 1;
            fill_rect( 36, 33, 76, 14 );    //在第二行处填充，也即第二行位置获得焦点
    		print_str( 38, 19, "Off Time", 0 );
    		print_str( 38, 34, "ON", 1 );
            print_str( 38, 49, "Exit", 0 );
    		break;
    	case 1:    //在1处，也即是在"启用"位置处
    		lp->status1 = 2;
    		print_str( 38, 19, "Off Time", 0 );
    		print_str( 38, 34, "ON", 0 );
            fill_rect( 36, 48, 76, 14 );     //填充第三行，也即第三行位置获得焦点
            print_str( 38, 49, "Exit", 1 );
    		break;
    	case 2:   //在2处，也即是在"退出"位置处
    		lp->status1 = 0;
            fill_rect( 36, 18, 76, 14 );    //填充第一行，也即第一行的位置获得焦点
            print_str( 38, 19, "Off Time", 1 );
            print_str( 38, 34, "ON", 0 );
            print_str( 38, 49, "Exit", 0 );
    		break;
    	default: break;
    	}
    }
    else
    {
    	print_ch_str( 47, 3, "设置定时关机", 0 );
    	switch ( lp->status1 )
    	{
    	case 0:          //在0处，也即是在设置"关机时间"处
    		lp->status1 = 1;
    		print_ch_str( 38, 19, "关机时间", 0 );
            fill_rect( 36, 33, 76, 14 );    //在第二行处填充，也即第二行位置获得焦点
            print_ch_str( 38, 34, "启用", 1 );
            print_ch_str( 38, 49, "退出", 0 );
    		break;
    	case 1:    //在1处，也即是在"启用"位置处
    		lp->status1 = 2;
    		print_ch_str( 38, 19, "关机时间", 0 );
    		print_ch_str( 38, 34, "启用", 0 );
            fill_rect( 36, 48, 76, 14 );     //填充第三行，也即第三行位置获得焦点
            print_ch_str( 38, 49, "退出", 1 );
    		break;
    	case 2:   //在2处，也即是在"退出"位置处
    		lp->status1 = 0;
            fill_rect( 36, 18, 76, 14 );    //填充第一行，也即第一行的位置获得焦点
            print_ch_str( 38, 19, "关机时间", 1 );
            print_ch_str( 38, 34, "启用", 0 );
            print_ch_str( 38, 49, "退出", 0 );
    		break;
    	default: break;
    	}
    }

    power_status_show(lp);
    clr_rect( 119, 24+lp->status1*10, 4, 12 );
}

void timePowerOffSetMenuOnLeft(void)
{
}

void timePowerOffSetMenuOnRight(void)
{
}

void timePowerOffSetMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:		// 获取设置关机时间焦点
		if ( lp->subMenu )
		{
			win->curfous = lp->subMenu;
			win->curfous->show();
		}
		break;
	case 1:		// 获取设置启用关机设置焦点
		if ( ON != systems.power_status )		// 当前没有启用关机设置
		{
			systems.power_status = ON;
			draw_symbol( 99, 35, 10, 10, gou_mu, 0 );
		}
		else		// 当前启用关机设置
		{
			systems.power_status = OFF;
			clr_rect( 99, 35, 10, 10 );
		}
		break;
	case 2:		// 获取退出设置焦点
		if ( lp->topMenu )
		{
			win->curfous = lp->topMenu;
			win->curfous->show();
		}
		break;
	default: break;
	}
}

void timePowerOffSetMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void timePowerOffSetMenuExec(void)
{

}

void power_status_show(struct MENU* lp)
{
	clr_rect( 98, 34, 12, 12 );
	draw_rect( 98, 34, 12, 12 );
	if ( ON == systems.power_status )
	{
		draw_symbol( 99, 35, 10, 10, gou_mu, 0 );	// 打钩
	}
}

/*
 * 定时关机时间设置菜单
 */
void powerTimeSetMenuShow(void)
{
	struct MENU *lp;
	lp = win->curfous;
	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );		// 打印一个像扳手一样的设置图标
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
    draw_dialog(1);     // 在左边画一个椭圆框

    systems.a_hour = systems.power_time.hour;
    systems.a_min = systems.power_time.min;
    if ( ENGLISH == systems.language )
    {
    	print_str( 40, 3, "Power off Time", 0 );    // 打印标题栏
    	switch ( lp->status1 )
    	{
    	case 0:
			print_time( systems.a_hour,	systems.a_min, 59, 23,HOUR); // 打印时间，并使"时"获得焦点
			draw_button( 43, 43, "OK", 0, ENGLISH );    //打印"确定"按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );   //打印"取消"按钮
    		break;
    	case 1:
			print_time( systems.a_hour,	systems.a_min, 59, 23,MIN); // 打印时间，并使"分"获得焦点
			draw_button( 43, 43, "OK", 0, ENGLISH );    //打印"确定"按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );   //打印"取消"按钮
    		break;
    	case 2:
			print_time( systems.a_hour,	systems.a_min, 59, 23,HOUR_MIN); // 打印时间
			draw_button( 43, 43, "OK", 1, ENGLISH );    //打印"确定"按钮,使确定获得焦点
			draw_button( 87, 43, "Esc", 0, ENGLISH );   //打印"取消"按钮
    		break;
    	case 3:
			print_time( systems.a_hour,	systems.a_min, 59, 23,HOUR_MIN); // 打印时间
			draw_button( 43, 43, "OK", 0, ENGLISH );    //打印"确定"按钮
			draw_button( 87, 43, "Esc", 1, ENGLISH );   //打印"取消"按钮,使取消获得焦点
    		break;
    	default: break;
    	}
    }
    else
    {
    	print_ch_str( 46, 3, "设置关机时间", 0 );   // 打印中文标题
    	switch ( lp->status1 )
    	{
    	case 0:
			print_time( systems.a_hour,	systems.a_min, 59, 23,HOUR); // 打印时间，并使"时"获得焦点
			draw_button( 43, 43, "确定", 0, CHINESE );    //打印"确定"按钮
			draw_button( 87, 43, "取消", 0, CHINESE );   //打印"取消"按钮
    		break;
    	case 1:
			print_time( systems.a_hour,	systems.a_min, 59, 23,MIN); // 打印时间，并使"分"获得焦点
			draw_button( 43, 43, "确定", 0, CHINESE );    //打印"确定"按钮
			draw_button( 87, 43, "取消", 0, CHINESE );   //打印"取消"按钮
    		break;
    	case 2:
			print_time( systems.a_hour,	systems.a_min, 59, 23,HOUR_MIN); // 打印时间
			draw_button( 43, 43, "确定", 1, CHINESE );    //打印"确定"按钮,使确定获得焦点
			draw_button( 87, 43, "取消", 0, CHINESE );   //打印"取消"按钮
    		break;
    	case 3:
			print_time( systems.a_hour,	systems.a_min, 59, 23,HOUR_MIN); // 打印时间
			draw_button( 43, 43, "确定", 0, CHINESE );    //打印"确定"按钮
			draw_button( 87, 43, "取消", 1, CHINESE );   //打印"取消"按钮,使取消获得焦点
    		break;
    	default: break;
    	}
    }
}

void powerTimeSetMenuOnUp(void)
{
	struct MENU *lp;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:		// 时获得焦点
		if ( systems.a_hour == 23 )
		{
			systems.a_hour = 0;
		}
		else
		{
			systems.a_hour++;
		}
		print_time( systems.a_hour,	systems.a_min, 59, 23,HOUR); // 打印时间
		break;
	case 1:		// 分获得焦点
		if ( systems.a_min == 59 )
		{
			systems.a_min = 0;
		}
		else
		{
			systems.a_min++;
		}
		print_time( systems.a_hour,	systems.a_min,59, 23,MIN); // 打印时间
		break;
	default: break;
	}
}

void powerTimeSetMenuOnDown(void)
{
	struct MENU *lp;
	lp = win->curfous;
	switch ( lp->status1 )
	{
	case 0:		// 时获得焦点
		if ( systems.a_hour == 0 )
		{
			systems.a_hour = 23;
		}
		else
		{
			systems.a_hour--;
		}
		print_time( systems.a_hour,	systems.a_min, 59, 23,HOUR); // 打印时间
		break;
	case 1:		// 分获得焦点
		if ( systems.a_min == 0 )
		{
			systems.a_min = 59;
		}
		else
		{
			systems.a_min--;
		}
		print_time( systems.a_hour,	systems.a_min, 59, 23,MIN); // 打印时间
		break;
	default: break;
	}
}

void powerTimeSetMenuOnLeft(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:		// 当前时获得焦点
			lp->status1 = 3;
			print_time( systems.a_hour,	systems.a_min, 59, 23,HOUR_MIN); // 打印时间
			draw_button( 87, 43, "Esc", 1, ENGLISH );   //打印"取消"按钮,使取消获得焦点
			break;
		case 1:		// 当前分获得焦点
			lp->status1 = 0;
			print_time( systems.a_hour,	systems.a_min, 59, 23,HOUR); // 打印时间
			break;
		case 2:		// 当前确定获得焦点
			lp->status1 = 1;
			print_time( systems.a_hour,	systems.a_min, 59, 23,MIN); // 打印时间
			draw_button( 43, 43, "Ok", 0, ENGLISH );    //打印"确定"按钮
			break;
		case 3:		// 当前取消获得焦点
			lp->status1 = 2;
			draw_button( 43, 43, "Ok", 1, ENGLISH );    //打印"确定"按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );   //打印"取消"按钮,使取消获得焦点
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:		// 当前时获得焦点
			lp->status1 = 3;
			print_time( systems.a_hour,	systems.a_min, 59, 23,HOUR_MIN); // 打印时间
			draw_button( 87, 43, "取消", 1, CHINESE );   //打印"取消"按钮,使取消获得焦点
			break;
		case 1:		// 当前分获得焦点
			lp->status1 = 0;
			print_time( systems.a_hour,	systems.a_min, 59, 23,HOUR); // 打印时间
			break;
		case 2:		// 当前确定获得焦点
			lp->status1 = 1;
			print_time( systems.a_hour,	systems.a_min, 59, 23,MIN); // 打印时间
			draw_button( 43, 43, "确定", 0, CHINESE );    //打印"确定"按钮
			break;
		case 3:		// 当前取消获得焦点
			lp->status1 = 2;
			draw_button( 43, 43, "确定", 1, CHINESE );    //打印"确定"按钮
			draw_button( 87, 43, "取消", 0, CHINESE );   //打印"取消"按钮,使取消获得焦点
			break;
		default: break;
		}
	}
}
void powerTimeSetMenuOnRight(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:		// 当前时获得焦点
			lp->status1 = 1;
			print_time( systems.a_hour,	systems.a_min, 59, 23, MIN ); // 打印时间
			break;
		case 1:		// 当前分获得焦点
			lp->status1 = 2;
			print_time( systems.a_hour,	systems.a_min, 59, 23,HOUR_MIN ); // 打印时间
			draw_button( 43, 43, "Ok", 1, ENGLISH );    //打印"确定"按钮
			break;
		case 2:		// 当前确定获得焦点
			lp->status1 = 3;
			draw_button( 43, 43, "Ok", 0, ENGLISH );    //打印"确定"按钮
			draw_button( 87, 43, "Esc", 1, ENGLISH );   //打印"取消"按钮,使取消获得焦点
			break;
		case 3:		// 当前取消获得焦点
			lp->status1 = 0;
			print_time( systems.a_hour,	systems.a_min, 59, 23, HOUR ); // 打印时间
			draw_button( 87, 43, "Esc", 0, ENGLISH );   //打印"取消"按钮,使取消获得焦点
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:		// 当前时获得焦点
			lp->status1 = 1;
			print_time( systems.a_hour,	systems.a_min, 59, 23, MIN ); // 打印时间
			break;
		case 1:		// 当前分获得焦点
			lp->status1 = 2;
			print_time( systems.a_hour,	systems.a_min, 59, 23, HOUR_MIN ); // 打印时间
			draw_button( 43, 43, "确定", 1, CHINESE );    //打印"确定"按钮
			break;
		case 2:		// 当前确定获得焦点
			lp->status1 = 3;
			draw_button( 43, 43, "确定", 0, CHINESE );    //打印"确定"按钮
			draw_button( 87, 43, "取消", 1, CHINESE );   //打印"取消"按钮,使取消获得焦点
			break;
		case 3:		// 当前取消获得焦点
			lp->status1 = 0;
			print_time( systems.a_hour,	systems.a_min, 59, 23, HOUR ); // 打印时间
			draw_button( 87, 43, "取消", 0, CHINESE );   //打印"取消"按钮,使取消获得焦点
			break;
		default: break;
		}
	}
}

void powerTimeSetMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( 2 == lp->status1 )
	{	// 如果当前焦点为“确定”焦点，并且系统当前启用自动关机

		systems.power_time.hour = systems.a_hour;
		systems.power_time.min  = systems.a_min;
		systems.power_time.sec  = systems.a_sec;
	}
	if ( lp->topMenu )
	{
		systems.a_hour = 0;
		systems.a_min = 1;
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void powerTimeSetMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void powerTimeSetMenuExec(void)
{

}


/**
 ** 输入密码菜单
 **/
void inputNumberMenuShow(void)
{
    struct MENU *lp;
    lp = win->curfous;
    clr_lcd();
    draw_rect( 0, 0, 127, 63 );
    draw_rect( 40, 19, 53, 14 );
    
    if ( ENGLISH == systems.language )
    {
        if ( lp->status2 )
        {
            print_str( 8, 5, "Err!Input password!", 0 );
        }
        else
        {
            print_str( 21, 5, "Input password!", 0 );
        }
    }
    else
    {
        if ( lp->status2 )
        {
            print_ch_str( 6, 5, "密码错误", 0 );
            putchar( 54, 5, '!', 0 );
            print_ch_str( 60, 5, "请重新输入", 0 );
        }
        else
        {
            print_ch_str( 35, 5, "请输入密码", 0 );
        }
    }        
    switch ( lp->status1 )
    {
    case 0:
        fill_rect( 43, 20, 8, 12 );
        print_int( 44, 20, password.one_bit, 1 );
        print_int( 52, 20, password.two_bit, 0 );
        print_int( 60, 20, password.three_bit, 0 );
        print_int( 68, 20, password.four_bit, 0 );
        print_int( 76, 20, password.five_bit, 0 );
        print_int( 84, 20, password.six_bit, 0 );
        switch ( systems.language )
        {
        case ENGLISH:
            draw_button( 30, 36, "Yes", 0, ENGLISH );
            draw_button( 75, 36, "No", 0, ENGLISH );
            break;
        case CHINESE:
            draw_button( 30, 36, "确定", 0, CHINESE );
            draw_button( 75, 36, "取消", 0, CHINESE );
            break;
        }
        break;
    case 1:
        print_int( 44, 20, password.one_bit, 0 );
        fill_rect( 43, 20, 8, 12 );
        print_int( 52, 20, password.two_bit, 1 );
        print_int( 60, 20, password.three_bit, 0 );
        print_int( 68, 20, password.four_bit, 0 );
        print_int( 76, 20, password.five_bit, 0 );
        print_int( 84, 20, password.six_bit, 0 );
        switch ( systems.language )
        {
        case ENGLISH:
            draw_button( 30, 36, "Yes", 0, ENGLISH );
            draw_button( 75, 36, "No", 0, ENGLISH );
            break;
        case CHINESE:
            draw_button( 30, 36, "确定", 0, CHINESE );
            draw_button( 75, 36, "取消", 0, CHINESE );
            break;
        }
        break;
    case 2:
        print_int( 44, 20, password.one_bit, 0 );
        print_int( 52, 20, password.two_bit, 0 );
        fill_rect( 59, 20, 8, 12 );
        print_int( 60, 20, password.three_bit, 1 );
        print_int( 68, 20, password.four_bit, 0 );
        print_int( 76, 20, password.five_bit, 0 );
        print_int( 84, 20, password.six_bit, 0 );
        switch ( systems.language )
        {
        case ENGLISH:
            draw_button( 30, 36, "Yes", 0, ENGLISH );
            draw_button( 75, 36, "No", 0, ENGLISH );
            break;
        case CHINESE:
            draw_button( 30, 36, "确定", 0, CHINESE );
            draw_button( 75, 36, "取消", 0, CHINESE );
            break;
        }
        break;
    case 3:
        print_int( 44, 20, password.one_bit, 0 );
        print_int( 52, 20, password.two_bit, 0 );
        print_int( 60, 20, password.three_bit, 0 );
        fill_rect( 67, 20, 8, 12 );
        print_int( 68, 20, password.four_bit, 1 );
        print_int( 76, 20, password.five_bit, 0 );
        print_int( 84, 20, password.six_bit, 0 );
        switch ( systems.language )
        {
        case ENGLISH:
            draw_button( 30, 36, "Yes", 0, ENGLISH );
            draw_button( 75, 36, "No", 0, ENGLISH );
            break;
        case CHINESE:
            draw_button( 30, 36, "确定", 0, CHINESE );
            draw_button( 75, 36, "取消", 0, CHINESE );
            break;
        }
        break;
    case 4:
        print_int( 44, 20, password.one_bit, 0 );
        print_int( 52, 20, password.two_bit, 0 );
        print_int( 60, 20, password.three_bit, 0 );
        print_int( 68, 20, password.four_bit, 0 );
        fill_rect( 75, 20, 8, 12 );
        print_int( 76, 20, password.five_bit, 1 );
        print_int( 84, 20, password.six_bit, 0 );
        switch ( systems.language )
        {
        case ENGLISH:
            draw_button( 30, 36, "Yes", 0, ENGLISH );
            draw_button( 75, 36, "No", 0, ENGLISH );
            break;
        case CHINESE:
            draw_button( 30, 36, "确定", 0, CHINESE );
            draw_button( 75, 36, "取消", 0, CHINESE );
            break;
        }
        break;
    case 5:
        print_int( 44, 20, password.one_bit, 0 );
        print_int( 52, 20, password.two_bit, 0 );
        print_int( 60, 20, password.three_bit, 0 );
        print_int( 68, 20, password.four_bit, 0 );
        print_int( 76, 20, password.five_bit, 0 );
        fill_rect( 83, 20, 8, 12 );
        print_int( 84, 20, password.six_bit, 1 );
        switch ( systems.language )
        {
        case ENGLISH:
            draw_button( 30, 36, "Yes", 0, ENGLISH );
            draw_button( 75, 36, "No", 0, ENGLISH );
            break;
        case CHINESE:
            draw_button( 30, 36, "确定", 0, CHINESE );
            draw_button( 75, 36, "取消", 0, CHINESE );
            break;
        }
        break;
    case 6:
        print_int( 44, 20, password.one_bit, 0 );
        print_int( 52, 20, password.two_bit, 0 );
        print_int( 60, 20, password.three_bit, 0 );
        print_int( 68, 20, password.four_bit, 0 );
        print_int( 76, 20, password.five_bit, 0 );
        print_int( 84, 20, password.six_bit, 0 );
        switch ( systems.language )
        {
        case ENGLISH:
            draw_button( 30, 36, "Yes", 1, ENGLISH );
            draw_button( 75, 36, "No", 0, ENGLISH );
            break;
        case CHINESE:
            draw_button( 30, 36, "确定", 1, CHINESE );
            draw_button( 75, 36, "取消", 0, CHINESE );
            break;
        }
        break;
    case 7:
        print_int( 44, 20, password.one_bit, 0 );
        print_int( 52, 20, password.two_bit, 0 );
        print_int( 60, 20, password.three_bit, 0 );
        print_int( 68, 20, password.four_bit, 0 );
        print_int( 76, 20, password.five_bit, 0 );
        print_int( 84, 20, password.six_bit, 0 );
        switch ( systems.language )
        {
        case ENGLISH:
            draw_button( 30, 36, "Yes", 0, ENGLISH );
            draw_button( 75, 36, "No", 1, ENGLISH );
            break;
        case CHINESE:
            draw_button( 30, 36, "确定", 0, CHINESE );
            draw_button( 75, 36, "取消", 1, CHINESE );
            break;
        }
        break;
    default : break;
    }
}

void inputNumberMenuOnUp(void)
{
    struct MENU *lp;
    lp = win->curfous;
    
    switch ( lp->status1 )
    {
    case 0:
        if ( 9 == password.one_bit )
        {
            password.one_bit = 0;
        }
        else
        {
            password.one_bit++;
        }
        print_int( 44, 20, password.one_bit, 1 );
        break;
    case 1:
        if ( 9 == password.two_bit )
        {
            password.two_bit = 0;
        }
        else
        {
            password.two_bit++;
        }
        print_int( 52, 20, password.two_bit, 1 );
        break;
    case 2:
        if ( 9 == password.three_bit )
        {
            password.three_bit = 0;
        }
        else
        {
            password.three_bit++;
        }
        print_int( 60, 20, password.three_bit, 1 );
        break;
    case 3:
        if ( 9 == password.four_bit )
        {
            password.four_bit = 0;
        }
        else
        {
            password.four_bit++;
        }
        print_int( 68, 20, password.four_bit, 1 );
        break;
    case 4:
        if ( 9 == password.five_bit )
        {
            password.five_bit = 0;
        }
        else
        {
            password.five_bit++;
        }
        print_int( 76, 20, password.five_bit, 1 );
        break;
    case 5:
        if ( 9 == password.six_bit )
        {
            password.six_bit = 0;
        }
        else
        {
            password.six_bit++;
        }
        print_int( 84, 20, password.six_bit, 1 );
        break;
    default: break;
    }
}

void inputNumberMenuOnDown(void)
{
    struct MENU *lp;
    lp = win->curfous;
    
    switch ( lp->status1 )
    {
    case 0:
        if ( 0 == password.one_bit )
        {
            password.one_bit = 9;
        }
        else
        {
            password.one_bit--;
        }
        print_int( 44, 20, password.one_bit, 1 );
        break;
    case 1:
        if ( 0 == password.two_bit )
        {
            password.two_bit = 9;
        }
        else
        {
            password.two_bit--;
        }
        print_int( 52, 20, password.two_bit, 1 );
        break;
    case 2:
        if ( 0 == password.three_bit )
        {
            password.three_bit = 9;
        }
        else
        {
            password.three_bit--;
        }
        print_int( 60, 20, password.three_bit, 1 );
        break;
    case 3:
        if ( 0 == password.four_bit )
        {
            password.four_bit = 9;
        }
        else
        {
            password.four_bit--;
        }
        print_int( 68, 20, password.four_bit, 1 );
        break;
    case 4:
        if ( 0 == password.five_bit )
        {
            password.five_bit = 9;
        }
        else
        {
            password.five_bit--;
        }
        print_int( 76, 20, password.five_bit, 1 );
        break;
    case 5:
        if ( 0 == password.six_bit )
        {
            password.six_bit = 9;
        }
        else
        {
            password.six_bit--;
        }
        print_int( 84, 20, password.six_bit, 1 );
        break;
    default: break;
    }
}

void inputNumberMenuOnLeft(void)
{
    struct MENU *lp;
    lp = win->curfous;
    
    switch ( lp->status1 )
    {
    case 0:
        lp->status1 = 7;
        clr_rect( 43, 20, 8, 12 );
        print_int( 44, 20, password.one_bit, 0 );
        switch ( systems.language )
        {
        case ENGLISH:
            draw_button( 75, 36, "No", 1, ENGLISH );
            break;
        case CHINESE:
            draw_button( 75, 36, "取消", 1, CHINESE );
            break;
        }
        break;
    case 1:
        lp->status1 = 0;
        fill_rect( 43, 20, 8, 12 );
        print_int( 44, 20, password.one_bit, 1 );
        clr_rect( 51, 20, 8, 12 );
        print_int( 52, 20, password.two_bit, 0 );
        break;
    case 2:
        lp->status1 = 1;
        fill_rect( 51, 20, 8, 12 );
        print_int( 52, 20, password.two_bit, 1 );
        clr_rect( 59, 20, 8, 12 );
        print_int( 60, 20, password.three_bit, 0 );
        break;
    case 3:
        lp->status1 = 2;
        fill_rect( 59, 20, 8, 12 );
        print_int( 60, 20, password.three_bit, 1 );
        clr_rect( 67, 20, 8, 12 );
        print_int( 68, 20, password.four_bit, 0 );
        break;
    case 4:
        lp->status1 = 3;
        fill_rect( 67, 20, 8, 12 );
        print_int( 68, 20, password.four_bit, 1 );
        clr_rect( 75, 20, 8, 12 );
        print_int( 76, 20, password.five_bit, 0 );
        break;
    case 5:
        lp->status1 = 4;
        fill_rect( 75, 20, 8, 12 );
        print_int( 76, 20, password.five_bit, 1 );
        clr_rect( 83, 20, 8, 12 );
        print_int( 84, 20, password.six_bit, 0 );
        break;
    case 6:
        lp->status1 = 5;
        fill_rect( 83, 20, 8, 12 );
        print_int( 84, 20, password.six_bit, 1 );
        switch ( systems.language )
        {
        case ENGLISH:
            draw_button( 30, 36, "Yes", 0, ENGLISH );
            break;
        case CHINESE:
            draw_button( 30, 36, "确定", 0, CHINESE );
            break;
        }
        break;
    case 7:
        lp->status1 = 6;
        switch ( systems.language )
        {
        case ENGLISH:
            draw_button( 30, 36, "Yes", 1, ENGLISH );
            draw_button( 75, 36, "No", 0, ENGLISH );
            break;
        case CHINESE:
            draw_button( 30, 36, "确定", 1, CHINESE );
            draw_button( 75, 36, "取消", 0, CHINESE );
            break;
        }
        break;
    default: break;
    }
}

void inputNumberMenuOnRight(void)
{
    struct MENU *lp;
    lp = win->curfous;
    
    switch ( lp->status1 )
    {
    case 0:
        lp->status1 = 1;
        clr_rect( 43, 20, 8, 12 );
        print_int( 44, 20, password.one_bit, 0 );
        fill_rect( 51, 20, 8, 12 );
        print_int( 52, 20, password.two_bit, 1 );
        break;
    case 1:
        lp->status1 = 2;
        fill_rect( 59, 20, 8, 12 );
        print_int( 60, 20, password.three_bit, 1 );
        clr_rect( 51, 20, 8, 12 );
        print_int( 52, 20, password.two_bit, 0 );
        break;
    case 2:
        lp->status1 = 3;
        fill_rect( 67, 20, 8, 12 );
        print_int( 68, 20, password.four_bit, 1 );
        clr_rect( 59, 20, 8, 12 );
        print_int( 60, 20, password.three_bit, 0 );
        break;
    case 3:
        lp->status1 = 4;
        fill_rect( 75, 20, 8, 12 );
        print_int( 76, 20, password.five_bit, 1 );
        clr_rect( 67, 20, 8, 12 );
        print_int( 68, 20, password.four_bit, 0 );
        break;
    case 4:
        lp->status1 = 5;
        fill_rect( 83, 20, 8, 12 );
        print_int( 84, 20, password.six_bit, 1 );
        clr_rect( 75, 20, 8, 12 );
        print_int( 76, 20, password.five_bit, 0 );
        break;
    case 5:
        lp->status1 = 6;
        switch ( systems.language )
        {
        case ENGLISH:
            draw_button( 30, 36, "Yes", 1, ENGLISH );
            break;
        case CHINESE:
            draw_button( 30, 36, "确定", 1, CHINESE );
            break;
        }
        clr_rect( 83, 20, 8, 12 );
        print_int( 84, 20, password.six_bit, 0 );
        break;
    case 6:
        lp->status1 = 7;
        switch ( systems.language )
        {
        case ENGLISH:
            draw_button( 30, 36, "Yes", 0, ENGLISH );
            draw_button( 75, 36, "No", 1, ENGLISH );
            break;
        case CHINESE:
            draw_button( 30, 36, "确定", 0, CHINESE );
            draw_button( 75, 36, "取消", 1, CHINESE );
            break;
        }
        break;
    case 7:
        lp->status1 = 0;
        switch ( systems.language )
        {
        case ENGLISH:
            draw_button( 75, 36, "No", 0, ENGLISH );
            break;
        case CHINESE:
            draw_button( 75, 36, "取消", 0, CHINESE );
            break;
        }
        fill_rect( 43, 20, 8, 12 );
        print_int( 44, 20, password.one_bit, 1 );
        break;
    default: break;
    }
}

void inputNumberMenuOnOk(void)
{
    struct MENU *lp;
    lp = win->curfous;
    
    if ( 6 == lp->status1 )
    {
        if ( password.one_bit == 1 && password.two_bit == 2
             && password.three_bit == 3 && password.four_bit == 4
             && password.five_bit == 5 && password.six_bit == 6 )
        {
            lp->status2 = 0;
            password.one_bit = 0;
            password.two_bit = 0;
            password.three_bit = 0;
            password.four_bit = 0;
            password.five_bit = 0;
            password.six_bit = 0;
            
            if ( lp->subMenu )
            {
                win->curfous = lp->subMenu;
                win->curfous->show();
            }
        }
        else
        {
            lp->status2++;
            if ( lp->subMenu )
            {
                win->curfous = lp->subMenu;
                lp = win->curfous;
                if ( lp->topMenu )
                {
                    win->curfous = lp->topMenu;
                    win->curfous->show();
                }
            }
        }
    }
    else if ( 7 == lp->status1 )
    {
        lp->status2 = 0;
        if ( lp->topMenu )
        {
            win->curfous = lp->topMenu;
            win->curfous->show();
        }
    }
}

void inputNumberMenuOnEsc(void)
{
    struct MENU *lp;
    lp = win->curfous;
    lp->status2 = 0;
    
    if ( lp->topMenu )
    {
        win->curfous = lp->topMenu;
        win->curfous->show();
    }
}

void inputNumberMenuExec(void)
{
    
}


/**
 ** 提示菜单
 **/
void clewMenuShow(void)
{
    struct MENU *lp;
    lp = win->curfous;
    clr_lcd();
    draw_rect( 0, 0, 127, 63 );
    
    if ( ENGLISH == systems.language )
    {
        if ( 0 == lp->status2 )
        {
            print_str( 26, 18, "Really do it?", 0 );
        }
        else
        {
            print_str( 24, 18, "Are you again?", 0 );
        }  
    }
    else
    {
        if ( 0 == lp->status2 )
        {
            print_ch_str( 20, 18, "是否要校准流量", 0 );
            putchar( 105, 18, '?', 0 );
        }
        else
        {
            print_ch_str( 40, 18, "是否继续", 0 );
            putchar( 89, 18, '?', 0 );
        }
    }
    
    if ( ENGLISH == systems.language )
    {
        switch ( lp->status1 )
        {
        case 0:
            draw_button( 25, 36, "Yes", 1, ENGLISH );
            draw_button( 75, 36, "No", 0, ENGLISH );
            break;
        case 1:
            draw_button( 25, 36, "Yes", 0, ENGLISH );
            draw_button( 75, 36, "No", 1, ENGLISH );
            break;
        default: break;
        }
    }
    else
    {
        switch ( lp->status1 )
        {
        case 0:
            draw_button( 25, 36, "确定", 1, CHINESE );
            draw_button( 75, 36, "取消", 0, CHINESE );
            break;
        case 1:
            draw_button( 25, 36, "确定", 0, CHINESE );
            draw_button( 75, 36, "取消", 1, CHINESE );
            break;
        default: break;
        }
    }
}

void clewMenuOnLeft(void)
{
    struct MENU *lp;
    lp = win->curfous;
    if ( ENGLISH == systems.language )
    {
        switch ( lp->status1 )
        {
        case 0:
            lp->status1 = 1;
            draw_button( 25, 36, "Yes", 0, ENGLISH );
            draw_button( 75, 36, "No", 1, ENGLISH );
            break;
        case 1:
            lp->status1 = 0;
            draw_button( 25, 36, "Yes", 1, ENGLISH );
            draw_button( 75, 36, "No", 0, ENGLISH );
            break;
        default: break;
        }
    }
    else
    {
        switch ( lp->status1 )
        {
        case 0:
            lp->status1 = 1;
            draw_button( 25, 36, "确定", 0, CHINESE );
            draw_button( 75, 36, "取消", 1, CHINESE );
            break;
        case 1:
            lp->status1 = 0;
            draw_button( 25, 36, "确定", 1, CHINESE );
            draw_button( 75, 36, "取消", 0, CHINESE );
            break;
        default: break;
        }
    }  
}

void clewMenuOnRight(void)
{
    struct MENU *lp;
    lp = win->curfous;
    if ( ENGLISH == systems.language )
    {
        switch ( lp->status1 )
        {
        case 0:
            lp->status1 = 1;
            draw_button( 25, 36, "Yes", 0, ENGLISH );
            draw_button( 75, 36, "No", 1, ENGLISH );
            break;
        case 1:
            lp->status1 = 0;
            draw_button( 25, 36, "Yes", 1, ENGLISH );
            draw_button( 75, 36, "No", 0, ENGLISH );
            break;
        default: break;
        }
    }
    else
    {
        switch ( lp->status1 )
        {
        case 0:
            lp->status1 = 1;
            draw_button( 25, 36, "确定", 0, CHINESE );
            draw_button( 75, 36, "取消", 1, CHINESE );
            break;
        case 1:
            lp->status1 = 0;
            draw_button( 25, 36, "确定", 1, CHINESE );
            draw_button( 75, 36, "取消", 0, CHINESE );
            break;
        default: break;
        }
    }     
}

void clewMenuOnOk(void)
{
    struct MENU *lp;
    lp = win->curfous;
    if ( 0 == lp->status1 )
    {
        lp->status2 = 1;
        if ( lp->subMenu )
        {
            systems.status = STOP;
            startPump( systems.a_flow );
            systems.presure = getPFromFlow( systems.a_flow );
            
            if(systems.presure > MAX_PRESURE)
            {
                systems.presure = systems.a_flow;
                writePToFlow(systems.presure,systems.a_flow);
            }
            
            changePresure( systems.presure );
            
            win->curfous = lp->subMenu;
            win->curfous->show();
        }
    }    
    else
    {
        lp->status2 = 0;
        if ( lp->topMenu )
        {
            win->curfous = lp->topMenu;
            lp = win->curfous;
            if ( lp->topMenu )
            {
                win->curfous = lp->topMenu;
                win->curfous->show();
            }
        }
    }
}

void clewMenuOnEsc(void)
{
    struct MENU *lp;
    lp = win->curfous;
    lp->status2 = 0;
    if ( lp->topMenu )
    {
        win->curfous = lp->topMenu;
        lp = win->curfous;
        if ( lp->topMenu )
        {
            win->curfous = lp->topMenu;
            win->curfous->show();
        }
    }
}

void clewMenuExec(void)
{
    
}


/*
 * 校准流量菜单
 */
void calibrateFlowMenuShow(void)
{
//    struct MENU *lp;
//    lp = win->curfous;
    clr_lcd();
    print_str( 2, 0, "AMAE", 0 );
    draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );		// 打印一个像扳手一样的设置图标
    draw_line( 33, 12, 33, 63 );		// 打印一条竖线
    draw_dialog(1);     // 在左边画一个椭圆框

    draw_rect( 57, 24, 50, 14 );   //打印一个矩形框，用于放置流量数值
    draw_line( 93, 24, 93, 36 );
    draw_symbol( 94, 25, 12, 12, up_down_mu, 0 );   //打印上下三角符号
    print_str( 64, 38, "mL/min", 0 );    //打印"mL/min"字符在右边

    if ( systems.a_flow >= 1000 )
    {
		print_int( 63, 25, systems.a_flow, 1 );
    }
    else if ( systems.a_flow >= 100 )
    {
    	print_int( 66, 25, systems.a_flow, 1 );
    }
    else if ( systems.a_flow > 10 )
    {
    	print_int( 69, 25, systems.a_flow, 1 );
    }

    if ( ENGLISH == systems.language )
    {
    	print_str( 40, 3, "Calibrate Flow", 0 );    // 打印标题栏
    }
    else
    {
    	print_ch_str( 56, 3, "校准流量", 0 );   // 打印中文标题
    }
}

void calibrateFlowMenuOnUp(void)
{
	if ( systems.a_flow < MAX_FLOW )
	{
		systems.a_flow += 50;
	}
	else
	{
		systems.a_flow = MIN_FLOW;
	}
	clr_rect( 63, 25, 24, 12 );
    if ( systems.a_flow >= 1000 )
    {
		print_int( 63, 25, systems.a_flow, 1 );
    }
    else if ( systems.a_flow >= 100 )
    {
    	print_int( 66, 25, systems.a_flow, 1 );
    }
    else if ( systems.a_flow > 10 )
    {
    	print_int( 69, 25, systems.a_flow, 1 );
    }
    
    systems.presure = getPFromFlow( systems.a_flow );
    
    if( systems.presure > MAX_PRESURE )
    {
        systems.presure = systems.a_flow;
                    
        writePToFlow( systems.presure, systems.a_flow );
    }
    
    changePresure( systems.presure );   // 设置压力值
}

void calibrateFlowMenuOnDown(void)
{
	if ( systems.a_flow > MIN_FLOW )
	{
		systems.a_flow -= 50;
	}
	else
	{
		systems.a_flow = MAX_FLOW;
	}
	clr_rect( 63, 25, 24, 12 );
    if ( systems.a_flow >= 1000 )
    {
		print_int( 63, 25, systems.a_flow, 1 );
    }
    else if ( systems.a_flow >= 100 )
    {
    	print_int( 66, 25, systems.a_flow, 1 );
    }
    else if ( systems.a_flow > 10 )
    {
    	print_int( 69, 25, systems.a_flow, 1 );
    }
    
    systems.presure = getPFromFlow( systems.a_flow );
    
    if( systems.presure > MAX_PRESURE )
    {
        systems.presure = systems.a_flow;
                    
        writePToFlow( systems.presure, systems.a_flow );
    }
    
    changePresure( systems.presure );   //设置压力值
}

void calibrateFlowMenuOnLeft(void)
{
    struct MENU *lp;
    
    lp = win->curfous;
    
    lp->status2 = 0;
    
    if( systems.presure > MIN_PRESURE )
    {
        systems.presure--;
        
        changePresure( systems.presure );
    }
    
    draw_symbol( 47, 25, 9, 12, jian_mu, 0 );
}

void calibrateFlowMenuOnRight(void)
{
    struct MENU *lp;
    
    lp = win->curfous;    
 
    lp->status2 = 0;
    
    if( systems.presure < MAX_PRESURE )
    {
        systems.presure++;
        
        changePresure( systems.presure );
    } 
    
    draw_symbol( 108, 25, 9, 12, plus_mu, 0 );
}

void calibrateFlowMenuOnOk(void)
{
    struct MENU * lp;		// 保存当前级菜单  
    //unsigned long pumpIbuf = 0;    
    //unsigned int pumpI;
    
    lp = win->curfous;

    lp->status2 = 0;
    
    /*    
    for( index=0; index<5; index++ )
    {
        pumpIbuf += ( getIAdc() / BUF_NUM );
    }
    
    pumpI = pumpIbuf / 5;  
    */
    
    stopPump();     //停止泵
    
    writePToFlow( systems.presure, systems.a_flow );
    //writeIToFlow( pumpI, systems.a_flow );   //将电流值写入到表中
    
    if( lp->topMenu )
    {
        win->curfous = lp->topMenu;  //转移到上层菜单
        
        win->curfous->show();   //当前菜单进行显示
    }
}

void calibrateFlowMenuOnEsc(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
        stopPump();     //停止泵
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}

void calibrateFlowMenuExec(void)
{
    struct MENU *lp;
    lp = win->curfous;
    
    if ( lp->status2 == 10 )
    {
        lp->status2 = 0;
        clr_rect( 47, 25, 9, 12 );
        clr_rect( 108, 25, 9, 12 );
    }
    if ( lp->status2 < 10 )
    {
        lp->status2++;
    }
    else
    {
        lp->status2 = 0;
    }
}



/*
 * 流量错误菜单
 */
void errFlowMenuShow(void)
{
//	struct MENU *lp;
//	lp = win->curfous;
	clr_lcd();
	draw_rect( 0, 0, 127, 63 );
	draw_line( 20, 15, 107, 15 );

	if ( ENGLISH == systems.language )
	{
		print_str( 45, 3, "Warning !", 0 );
		print_str( 30, 17, "Flow can't be", 0 );
		if ( systems.a_flow < 40 )
		{
			print_str( 20, 30, "lesser than 40!", 0 );
		}
		else if ( systems.a_flow > MAX_FLOW )
		{
			print_str( 18, 30, "greater than     !", 0 );
            print_int( 96, 30, MAX_FLOW, 0 );
		}

		print_str( 2, 48, "Please Reset!", 0 );
		draw_button( 92, 44, "Ok", 1, ENGLISH );
	}
	else
	{
		print_ch_str( 53, 3, "警告", 0 );
		print_str( 83, 3, "!", 0 );
		if ( systems.a_flow < 40 )
		{
			print_ch_str( 10, 17, "流量值不能小于", 0 );
			print_int( 97, 17, 40, 0 );
			putchar( 109, 17, '!', 0 );
		}
		else if ( systems.a_flow > MAX_FLOW )
		{
			print_ch_str( 10, 17, "流量值不能大于", 0 );
			print_int( 96, 17, MAX_FLOW, 0 );
			putchar( 120, 17, '!', 0 );
		}

		print_ch_str( 18, 30, "请重新设置流量", 0 );
		print_ch_str( 2, 48, "任意键返回", 0 );
		draw_button( 92, 44, "确定", 1, CHINESE );
	}
}

void errFlowMenuOnOk(void)
{
	struct MENU *lp;
	lp = win->curfous;
	if ( lp->topMenu )
	{
		win->curfous = lp->topMenu;
		win->curfous->show();
	}
}



/*
 * 显示时间
 */
void show_time( unsigned int mod )
{
	static unsigned char old_hour = 0;
	static unsigned char old_min = 0;
	static unsigned char old_sec = 0;
	// 打印系统当前时间
	if ( systems.sys_time.sec != old_sec || mod == 1 )
	{	// 系统当前时间秒值发生改变，更新系统当前时间的秒值
		old_sec = systems.sys_time.sec;		// 更新系统当前时间的秒值
		if ( old_sec & 0x01 )
		{
			putchar( 108, 50, ':', 0 );			// 奇数秒打印冒号
		}
		else
		{
			putchar( 108, 50, ' ', 0 );			// 偶数秒打印空格
		}
	}

	// 打印显示系统当前时间的分
	if ( systems.sys_time.min != old_min || mod == 1 )
	{	// 系统当前时间秒值发生改变，更新系统当前时间的秒值
		old_min = systems.sys_time.min;		// 更新系统当前时间的分值
		clr_rect( 114, 50, 12, 12 );
		if ( old_min < 10 )
		{	// printTime.min宽度为1个字符宽度，在其前面填充0

			print_int( 114, 50, 0, 0 );
			print_int( 120, 50, old_min, 0 );
		}
		else
		{
			print_int( 114, 50, old_min, 0 );
		}
	}
	// 打印显示系统当前时间的时
	if ( systems.sys_time.hour != old_hour || mod == 1 )
	{	// 系统当前时间秒值发生改变，更新系统当前时间的秒值
		old_hour = systems.sys_time.hour;		// 更新系统当前时间的时值
		clr_rect( 96, 50, 12, 12 );
		if ( old_hour < 10 )
		{
			print_int( 96, 50, 0, 0 );
			print_int( 102, 50, old_hour, 0 );
		}
		else
		{
			print_int( 96, 50, old_hour, 0 );
		}
	}
}

/*
 * 状态显示函数
 */
void status_show( unsigned int status )             //状态参数显示函数
{
    clr_rect( STAT_X, STAT_Y, 12, 12 );
    
	switch( status )
	{
	case STOP:
		draw_symbol( STAT_X, STAT_Y, 12, 12, status_mu[0], 0 );
		break;
	case SAMPLING:
		draw_symbol( STAT_X, STAT_Y, 12, 12, status_mu[1], 0 );
		break;
	case WAITING:
		draw_symbol( STAT_X, STAT_Y, 12, 12, status_mu[2], 0 );
		break;
	default: break;
	}
}

/*
 * 流量显示函数
 */
void flow_show( unsigned int flow )
{
    clr_rect( 66, 12, 24, 12 );
	if( flow <= 9999 )
	{
		clr_rect( FLOW_X+30, FLOW_Y, 24, 12 );

		if( flow >= 1000 )                  // 如果大于1000，则显示四位
		{
			print_int( FLOW_X+30, FLOW_Y, flow, 0 );    // 显示位置从最左边开始
		}
		else if( flow < 1000 && flow >= 100 )         // 如果大于100，小于1000
		{
			print_int( FLOW_X+36, FLOW_Y, flow, 0 );   //则从左边数过来1位再显示
		}
		else if( flow < 100 && flow >= 10 )         // 如果大于100 小于10
		{
			print_int( FLOW_X+42, FLOW_Y, flow, 0 );   //则从左边数过来2位再显示
		}
		else
		{
			print_int( FLOW_X+48, FLOW_Y, flow, 0 );   //如果小于10，则从左边数起第三位开始显示
		}
	}
    
    if ( COMPLETE == systems.status )
    {
        clr_rect( FLOW_X+30, FLOW_Y, 24, 12 );
    }
}

/*
 * 显示已用时间
 */
void used_time_show( unsigned int time, unsigned int sec )   // 已采样时间显示函数
{
	if ( time <= 9999 )
	{
		clr_rect( USED_X+42, USED_Y, 24, 12 );     // 首先清空原来的数据

		if ( time >= 1000 )                  // 如果大于1000，则显示四位
		{
			print_int( USED_X+42, USED_Y,time, 0 );    // 显示位置从最左边开始
		}
		else if ( time < 1000 && time >= 100 )         // 如果大于100，小于1000
		{
			print_int( USED_X+48, USED_Y, time, 0 );   // 则从左边数过来1位再显示
		}
		else if ( time < 100 && time >= 10 )         // 如果大于100 小于10
		{
			print_int( USED_X+54, USED_Y, time, 0 );   // 则从左边数过来2位再显示
		}
		else
		{
			print_int( USED_X+60, USED_Y, time, 0 );   // 如果小于10，则从左边数起第三位开始显示
		}
	}

	if ( sec < 60 )
	{
		clr_rect( USED_X+72, USED_Y, 12, 12 );
		if( sec >= 10 )
		{
			print_int( USED_X+72, USED_Y, sec, 0 );
		}
		else
		{
			putchar( USED_X+72, USED_Y, '0', 0 );
			putchar( USED_X+78, USED_Y, sec+'0', 0 );
		}
	}
}

/*
 * 显示已采体积
 */
void used_volume_show( double new_volume )
{
    double volume = new_volume / 1000;
    if ( volume >= 100.0 )
    {
        print_float( USED_X+42, USED_Y, volume, 2, 0 );
    }
    else if ( volume >= 10 )
    {
        print_float( USED_X+42, USED_Y, volume, 3, 0 );
    }
    else if ( volume > 0 )
    {
        print_float( USED_X+42, USED_Y, volume, 4, 0 );
    }
    else if ( volume <= 0.001 )
    {
        putchar( USED_X+72, USED_Y, '0', 0 );
    }
}

/*
 *  进度条和进度显示,percent为进度
 */
void percent_show( double percent ) // 进度条和进度显示,percent为进度
{
	unsigned int per_int;
	unsigned int gewei;
	unsigned int shiwei;
	if ( percent >= 0 )
	{
		clr_rect( 100, 36, 18, 12 );
		clr_rect( PERC_X+1, PERC_Y+2, 60, 8 );
		per_int = (unsigned int)( percent*100 );
		if ( per_int == 100 )
		{
			print_str( PERC_X+65, PERC_Y, "100", 0 );
			fill_rect( PERC_X+1, PERC_Y+2, 60, 8 );
		}
		else if ( per_int >= 10 && per_int < 100 )
		{
			gewei = per_int % 10;
			putchar( PERC_X+77, PERC_Y, gewei+'0', 0 );
			shiwei = ( per_int - gewei ) / 10;
			putchar( PERC_X+71, PERC_Y, shiwei+'0', 0 );

			fill_rect( PERC_X+1, PERC_Y+2, (unsigned char)( percent*60 ), 8 );
		}
		else
		{
			putchar( PERC_X+77, PERC_Y, per_int+'0', 0 );
			fill_rect( PERC_X+1, PERC_Y+2, (unsigned char)( percent*60 ), 8 );
		}
	}
}


/*
 * 流量设置函数
 */
void flowSetShow( struct MENU *lp )
{
	unsigned int ge, shi, bai, qian;
    
	clr_lcd();
	print_str( 2, 0, "AMAE", 0 );
	draw_symbol( 5, 18, 22, 40, setmod_mu, 0 );		// 打印一个像扳手一样的设置图标
	draw_line( 33, 12, 33, 63 );		// 打印一条竖线
	draw_dialog( 0 );          // 描绘一个矩形框

    draw_rect( 57, 17, 50, 14 );   //打印一个矩形框，用于放置流量数值
    draw_line( 93, 18, 93, 30 );
    draw_symbol( 94, 18, 12, 12, up_down_mu, 0 );   //打印上下三角符号
    print_str( 64, 31, "mL/min", 0 );    //打印"mL/min"字符在右边

    qian = (unsigned int)(systems.a_flow / 1000);
    bai  = (unsigned int)(systems.a_flow % 1000 / 100 );
    shi  = (unsigned int)(systems.a_flow % 100 / 10 );
    ge   = (unsigned int)(systems.a_flow % 10);

    putchar( 84, 18, ge+'0', 0 );
	if ( ENGLISH == systems.language )
	{
		print_str( 43, 3, "Set the Flow", 0 );       // 打印标题栏
		switch ( lp->status1 )
		{
		case 0:    //使千位获得焦点
			fill_rect( 59, 17, 8, 14 );
			putchar( 60, 18, qian+'0', 1 );
			putchar( 68, 18, bai+'0', 0 );
			putchar( 76, 18, shi+'0', 0 );
//			putchar( 84, 18, ge+'0', 0 );
			draw_button( 43, 43, "Ok", 0, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );  //打印取消按钮
			break;
		case 1:    //使百位获得焦点
			putchar( 60, 18, qian+'0', 0 );
			fill_rect( 67, 17, 8, 14 );
			putchar( 68, 18, bai+'0', 1 );
			putchar( 76, 18, shi+'0', 0 );
//			putchar( 84, 18, ge+'0', 0 );
			draw_button( 43, 43, "Ok", 0, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );  //打印取消按钮
			break;
		case 2:    //使十位获得焦点
			putchar( 60, 18, qian+'0', 0 );
			putchar( 68, 18, bai+'0', 0 );
			fill_rect( 75, 17, 8, 14 );
			putchar( 76, 18, shi+'0', 1 );
//			putchar( 84, 18, ge+'0', 0 );
			draw_button( 43, 43, "Ok", 0, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );  //打印取消按钮
			break;
/*		case 3:    //使个位获得焦点
			putchar( 60, 18, qian+'0', 0 );
			putchar( 68, 18, bai+'0', 0 );
			putchar( 76, 18, shi+'0', 0 );
			fill_rect( 83, 17, 8, 14 );
//			putchar( 84, 18, ge+'0', 1 );
			draw_button( 43, 43, "Ok", 0, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );  //打印取消按钮
			break;*/
		case 3:    //使确定获得焦点
			putchar( 60, 18, qian+'0', 0 );
			putchar( 68, 18, bai+'0', 0 );
			putchar( 76, 18, shi+'0', 0 );
//			putchar( 84, 18, ge+'0', 0 );
			draw_button( 43, 43, "Ok", 1, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );  //打印取消按钮
			break;
		case 4:    //使取消获得焦点
			putchar( 60, 18, qian+'0', 0 );
			putchar( 68, 18, bai+'0', 0 );
			putchar( 76, 18, shi+'0', 0 );
//			putchar( 84, 18, ge+'0', 0 );
			draw_button( 43, 43, "Ok", 0, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 1, ENGLISH );  //打印取消按钮
			break;
		default: break;
		}
	}
	else
	{
		print_ch_str( 52, 3, "请设置流量", 0 );       // 打印标题栏
		switch ( lp->status1 )
		{
		case 0:    //使千位获得焦点
			fill_rect( 59, 17, 8, 14 );
			putchar( 60, 18, qian+'0', 1 );
			putchar( 68, 18, bai+'0', 0 );
			putchar( 76, 18, shi+'0', 0 );
//			putchar( 84, 18, ge+'0', 0 );
			draw_button( 43, 43, "确定", 0, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );  //打印取消按钮
			break;
		case 1:    //使百位获得焦点
			putchar( 60, 18, qian+'0', 0 );
			fill_rect( 67, 17, 8, 14 );
			putchar( 68, 18, bai+'0', 1 );
			putchar( 76, 18, shi+'0', 0 );
//			putchar( 84, 18, ge+'0', 0 );
			draw_button( 43, 43, "确定", 0, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );  //打印取消按钮
			break;
		case 2:    //使十位获得焦点
			putchar( 60, 18, qian+'0', 0 );
			putchar( 68, 18, bai+'0', 0 );
			fill_rect( 75, 17, 8, 14 );
			putchar( 76, 18, shi+'0', 1 );
//			putchar( 84, 18, ge+'0', 0 );
			draw_button( 43, 43, "确定", 0, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );  //打印取消按钮
			break;
/*		case 3:    //使个位获得焦点
			putchar( 60, 18, qian+'0', 0 );
			putchar( 68, 18, bai+'0', 0 );
			putchar( 76, 18, shi+'0', 0 );
			fill_rect( 83, 17, 8, 14 );
//			putchar( 84, 18, ge+'0', 1 );
			draw_button( 43, 43, "确定", 0, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );  //打印取消按钮
			break;*/
		case 3:    //使确定获得焦点
			putchar( 60, 18, qian+'0', 0 );
			putchar( 68, 18, bai+'0', 0 );
			putchar( 76, 18, shi+'0', 0 );
//			putchar( 84, 18, ge+'0', 0 );
			draw_button( 43, 43, "确定", 1, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );  //打印取消按钮
			break;
		case 4:    //使取消获得焦点
			putchar( 60, 18, qian+'0', 0 );
			putchar( 68, 18, bai+'0', 0 );
			putchar( 76, 18, shi+'0', 0 );
//			putchar( 84, 18, ge+'0', 0 );
			draw_button( 43, 43, "确定", 0, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 1, CHINESE );  //打印取消按钮
			break;
		default: break;
		}
	}
}

void flowSetUp( struct MENU *lp )
{
	unsigned int shi, bai, qian;

	switch ( lp->status1 )
	{
	case 0:
		qian = (unsigned int)(systems.a_flow / 1000);
		systems.a_flow -= qian * 1000;
		if ( 5 == qian )
		{
			qian = 0;
		}
		else
		{
			qian++;
		}
		putchar( 60, 18, qian+'0', 1 );
		systems.a_flow += qian * 1000;
        
        if ( systems.a_flow < MIN_FLOW )
        {
            systems.a_flow = MIN_FLOW;
            bai = (unsigned int)(( systems.a_flow % 1000 ) / 100 );
            putchar( 68, 18, bai+'0', 0 );
            shi = 0;
            putchar( 76, 18, shi+'0', 0 );
        }
        
        if ( systems.a_flow > MAX_FLOW )
        {
            bai = (unsigned int)(( systems.a_flow % 1000 ) / 100 );
            systems.a_flow -= bai * 100;
            bai = 0;
            putchar( 68, 18, bai+'0', 0 );
        }
		break;
	case 1:
		bai = (unsigned int)(( systems.a_flow % 1000 ) / 100 );
		systems.a_flow -= bai * 100;
		if ( 9 == bai )
		{
			bai = 0;
		}
		else
		{
			bai++;
		}
		putchar( 68, 18, bai+'0', 1 );
		systems.a_flow += bai * 100;
        
        if ( systems.a_flow < MIN_FLOW )
        {
            qian = 1;
            systems.a_flow += qian * 1000;
            putchar( 60, 18, qian+'0', 0 );
        }
        
        if ( systems.a_flow > MAX_FLOW )
        {
            qian = (unsigned int)(systems.a_flow / 1000);
            systems.a_flow -= qian * 1000;
            qian = 0;
            putchar( 60, 18, qian+'0', 0 );
        }
        
		break;
	case 2:
		shi  = (unsigned int)(( systems.a_flow % 100 ) / 10 );
		systems.a_flow -= shi * 10;
		if ( 5 == shi )
		{
			shi = 0;
		}
		else
		{
			shi = 5;
		}
        putchar( 76, 18, shi+'0', 1 );
        systems.a_flow += shi * 10;

        if ( systems.a_flow > MAX_FLOW )
        {
            qian = (unsigned int)(systems.a_flow / 1000);
            systems.a_flow -= qian * 1000;
            qian = 0;
            putchar( 60, 18, qian+'0', 0 );
        }
        
        if ( systems.a_flow < MIN_FLOW )
        {
            qian = 1;
            systems.a_flow += qian * 1000;
            putchar( 60, 18, qian+'0', 0 );
        }
        
		break;
/*	case 3:
		ge   = (unsigned int)( systems.a_flow % 10 );
		systems.a_flow -= ge;
		if ( 9 == ge )
		{
			ge = 0;
		}
		else
		{
			ge++;
		}
        putchar( 84, 18, ge+'0', 1 );
        systems.a_flow += ge;
		break;*/
	case 3:
		break;
	case 4:
		break;
	default: break;
	}
}

void flowSetDown( struct MENU *lp )
{
	unsigned int shi, bai, qian;

	switch ( lp->status1 )
	{
	case 0:
		qian = (unsigned int)(systems.a_flow / 1000);
		systems.a_flow -= qian * 1000;
		if ( 0 == qian )
		{
			qian = 5;
		}
		else
		{
			qian--;
		}
		putchar( 60, 18, qian+'0', 1 );
		systems.a_flow += qian * 1000;
        
        if ( systems.a_flow > MAX_FLOW )
        {
            bai = (unsigned int)(( systems.a_flow % 1000 ) / 100 );
            systems.a_flow -= bai * 100;
            bai = 0;
            putchar( 68, 18, bai+'0', 0 );
        }
        
        if ( systems.a_flow < MIN_FLOW )
        {
            systems.a_flow = MIN_FLOW;
            bai = (unsigned int)(( systems.a_flow % 1000 ) / 100 );
            putchar( 68, 18, bai+'0', 0 );
            shi = 0;
            putchar( 76, 18, shi+'0', 0 );
        }
		break;
	case 1:
		bai = (unsigned int)(( systems.a_flow % 1000 ) / 100 );
		systems.a_flow -= bai * 100;
		if ( 0 == bai )
		{
			bai = 9;
		}
		else
		{
			bai--;
		}
		putchar( 68, 18, bai+'0', 1 );
		systems.a_flow += bai * 100;
        
        if ( systems.a_flow < MIN_FLOW )
        {
            qian = 1;
            systems.a_flow += qian * 1000;
            putchar( 60, 18, qian+'0', 0 );
        }
        
        if ( systems.a_flow > MAX_FLOW )
        {
            qian = (unsigned int)(systems.a_flow / 1000);
            systems.a_flow -= qian * 1000;
            qian = 0;
            putchar( 60, 18, qian+'0', 0 );
        }
		break;
	case 2:
		shi  = (unsigned int)(( systems.a_flow % 100 ) / 10 );
		systems.a_flow -= shi * 10;
		if ( 0 == shi )
		{
			shi = 5;
		}
		else
		{
			shi = 0;
		}
        putchar( 76, 18, shi+'0', 1 );
        systems.a_flow += shi * 10;
        
        if ( systems.a_flow > MAX_FLOW )
        {
            qian = (unsigned int)(systems.a_flow / 1000);
            systems.a_flow -= qian * 1000;
            qian = 0;
            putchar( 60, 18, qian+'0', 0 );
        }
        
        if ( systems.a_flow < MIN_FLOW )
        {
            qian = 1;
            systems.a_flow += qian * 1000;
            putchar( 60, 18, qian+'0', 0 );
        }
		break;
/*	case 3:
		ge   = (unsigned int)( systems.a_flow % 10 );
		systems.a_flow -= ge;
		if ( 0 == ge )
		{
			ge = 9;
		}
		else
		{
			ge--;
		}
        putchar( 84, 18, ge+'0', 1 );
        systems.a_flow += ge;
		break;*/
	case 3:
		break;
	case 4:
		break;
	default: break;
	}
}

void flowSetLeft( struct MENU *lp )
{
	unsigned int shi, bai, qian;

	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 4;
			qian = (unsigned int)( systems.a_flow / 1000);
			clr_rect( 59, 18, 8, 12 );
			putchar( 60, 18, qian+'0', 0 );
			draw_button( 87, 43, "Esc", 1, ENGLISH );  //打印取消按钮
			break;
		case 1:
			lp->status1 = 0;
			qian = (unsigned int)(systems.a_flow / 1000);
			bai  = (unsigned int)( systems.a_flow % 1000 / 100 );
			fill_rect( 59, 18, 8, 12 );
			putchar( 60, 18, qian+'0', 1 );
			clr_rect( 67, 18, 8, 12 );
			putchar( 68, 18, bai+'0', 0 );
			break;
		case 2:
			lp->status1 = 1;
			bai = (unsigned int)( systems.a_flow % 1000 / 100 );
			shi = (unsigned int)(( systems.a_flow % 100 ) / 10 );
			fill_rect( 67, 18, 8, 12 );
			putchar( 68, 18, bai+'0', 1 );
			clr_rect( 75, 18, 8, 12 );
			putchar( 76, 18, shi+'0', 0 );
			break;
/*		case 3:
			lp->status1 = 2;
			shi = (unsigned int)(( systems.a_flow % 100 ) / 10 );
			ge  = (unsigned int)( systems.a_flow % 10 );
			fill_rect( 75, 18, 8, 12 );
			putchar( 76, 18, shi+'0', 1 );
			clr_rect( 83, 18, 8, 12 );
			putchar( 84, 18, ge+'0', 0 );
			break;*/
		case 3:
			lp->status1 = 2;
//			ge  = (unsigned int)( systems.a_flow % 10 );
//			fill_rect( 83, 18, 8, 12 );
//			putchar( 84, 18, ge+'0', 1 );
			
            shi = (unsigned int)(( systems.a_flow % 100 ) / 10 );
			fill_rect( 75, 18, 8, 12 );
			putchar( 76, 18, shi+'0', 1 );
            
			draw_button( 43, 43, "Ok", 0, ENGLISH );  //打印确定按钮
			break;
		case 4:
			lp->status1 = 3;
			draw_button( 43, 43, "Ok", 1, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 0, ENGLISH );  //打印取消按钮
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 4;
			qian = (unsigned int)(systems.a_flow / 1000);
			clr_rect( 59, 18, 8, 12 );
			putchar( 60, 18, qian+'0', 0 );
			draw_button( 87, 43, "取消", 1, CHINESE );  //打印取消按钮
			break;
		case 1:
			lp->status1 = 0;
			qian = (unsigned int)(systems.a_flow / 1000);
			bai  = (unsigned int)( systems.a_flow % 1000 / 100 );
			fill_rect( 59, 18, 8, 12 );
			putchar( 60, 18, qian+'0', 1 );
			clr_rect( 67, 18, 8, 12 );
			putchar( 68, 18, bai+'0', 0 );
			break;
		case 2:
			lp->status1 = 1;
			bai = (unsigned int)( systems.a_flow % 1000 / 100 );
			shi = (unsigned int)(( systems.a_flow % 100 ) / 10 );
			fill_rect( 67, 18, 8, 12 );
			putchar( 68, 18, bai+'0', 1 );
			clr_rect( 75, 18, 8, 12 );
			putchar( 76, 18, shi+'0', 0 );
			break;
/*		case 3:
			lp->status1 = 2;
			shi = (unsigned int)(( systems.a_flow % 100 ) / 10 );
			ge  = (unsigned int)( systems.a_flow % 10 );
			fill_rect( 75, 18, 8, 12 );
			putchar( 76, 18, shi+'0', 1 );
			clr_rect( 83, 18, 8, 12 );
			putchar( 84, 18, ge+'0', 0 );
			break;*/
		case 3:
			lp->status1 = 2;
//			ge  = (unsigned int)( systems.a_flow % 10 );
//			fill_rect( 83, 18, 8, 12 );
//			putchar( 84, 18, ge+'0', 1 );
            
			shi = (unsigned int)(( systems.a_flow % 100 ) / 10 );
			fill_rect( 75, 18, 8, 12 );
			putchar( 76, 18, shi+'0', 1 );
            
			draw_button( 43, 43, "确定", 0, CHINESE );  //打印确定按钮
			break;
		case 4:
			lp->status1 = 3;
			draw_button( 43, 43, "确定", 1, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 0, CHINESE );  //打印取消按钮
			break;
		default: break;
		}
	}
}

void flowSetRight( struct MENU *lp )
{
	unsigned int shi, bai, qian;

	if ( ENGLISH == systems.language )
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			qian = (unsigned int)(systems.a_flow / 1000);
			bai  = (unsigned int)( systems.a_flow % 1000 / 100 );
			clr_rect( 59, 18, 8, 12 );
			putchar( 60, 18, qian+'0', 0 );
			fill_rect( 67, 18, 8, 12 );
			putchar( 68, 18, bai+'0', 1 );
			break;
		case 1:
			lp->status1 = 2;
			bai = (unsigned int)( systems.a_flow % 1000 / 100 );
			shi = (unsigned int)(( systems.a_flow % 100 ) / 10 );
			clr_rect( 67, 18, 8, 12 );
			putchar( 68, 18, bai+'0', 0 );
			fill_rect( 75, 18, 8, 12 );
			putchar( 76, 18, shi+'0', 1 );
			break;
/*		case 2:
			lp->status1 = 3;
			shi = (unsigned int)(( systems.a_flow % 100 ) / 10 );
			ge  = (unsigned int)( systems.a_flow % 10 );
			clr_rect( 75, 18, 8, 12 );
			putchar( 76, 18, shi+'0', 0 );
			fill_rect( 83, 18, 8, 12 );
			putchar( 84, 18, ge+'0', 1 );
			break;*/
		case 2:
			lp->status1 = 3;
//			ge = (unsigned int)( systems.a_flow % 10 );
//			clr_rect( 83, 18, 8, 12 );
//			putchar( 84, 18, ge+'0', 0 );
            
			shi = (unsigned int)(( systems.a_flow % 100 ) / 10 );
			clr_rect( 75, 18, 8, 12 );
			putchar( 76, 18, shi+'0', 0 );
            
			draw_button( 43, 43, "Ok", 1, ENGLISH );  //打印确定按钮
			break;
		case 3:
			lp->status1 = 4;
			draw_button( 43, 43, "Ok", 0, ENGLISH );  //打印确定按钮
			draw_button( 87, 43, "Esc", 1, ENGLISH );  //打印取消按钮
			break;
		case 4:
			lp->status1 = 0;
			qian = (unsigned int)(systems.a_flow / 1000);
			fill_rect( 59, 18, 8, 12 );
			putchar( 60, 18, qian+'0', 1 );
			draw_button( 87, 43, "Esc", 0, ENGLISH );  //打印取消按钮
			break;
		default: break;
		}
	}
	else
	{
		switch ( lp->status1 )
		{
		case 0:
			lp->status1 = 1;
			qian = (unsigned int)(systems.a_flow / 1000);
			bai  = (unsigned int)( systems.a_flow % 1000 / 100 );
			clr_rect( 59, 18, 8, 12 );
			putchar( 60, 18, qian+'0', 0 );
			fill_rect( 67, 18, 8, 12 );
			putchar( 68, 18, bai+'0', 1 );
			break;
		case 1:
			lp->status1 = 2;
			bai = (unsigned int)( systems.a_flow % 1000 / 100 );
			shi = (unsigned int)(( systems.a_flow % 100 ) / 10 );
			clr_rect( 67, 18, 8, 12 );
			putchar( 68, 18, bai+'0', 0 );
			fill_rect( 75, 18, 8, 12 );
			putchar( 76, 18, shi+'0', 1 );
			break;
/*		case 2:
			lp->status1 = 3;
			shi = (unsigned int)(( systems.a_flow % 100 ) / 10 );
			ge  = (unsigned int)( systems.a_flow % 10 );
			clr_rect( 75, 18, 8, 12 );
			putchar( 76, 18, shi+'0', 0 );
			fill_rect( 83, 18, 8, 12 );
			putchar( 84, 18, ge+'0', 1 );
			break;*/
		case 2:
			lp->status1 = 3;
//			ge = (unsigned int)( systems.a_flow % 10 );
//			clr_rect( 83, 18, 8, 12 );
//			putchar( 84, 18, ge+'0', 0 );
            
			shi = (unsigned int)(( systems.a_flow % 100 ) / 10 );
			clr_rect( 75, 18, 8, 12 );
			putchar( 76, 18, shi+'0', 0 );
            
			draw_button( 43, 43, "确定", 1, CHINESE );  //打印确定按钮
			break;
		case 3:
			lp->status1 = 4;
			draw_button( 43, 43, "确定", 0, CHINESE );  //打印确定按钮
			draw_button( 87, 43, "取消", 1, CHINESE );  //打印取消按钮
			break;
		case 4:
			lp->status1 = 0;
			qian = (unsigned int)(systems.a_flow / 1000);
			fill_rect( 59, 18, 8, 12 );
			putchar( 60, 18, qian+'0', 1 );
			draw_button( 87, 43, "取消", 0, CHINESE );  //打印取消按钮
			break;
		default: break;
		}
	}
}


void group_status_set( unsigned int x_pos, unsigned int y_pos )
{
	clr_rect( x_pos+60, y_pos, 12, 12 );
	draw_rect( x_pos+60, y_pos, 12, 12 );
	if( 1 == systems.groups[systems.set_group].srb )
	{
		draw_symbol( x_pos+61, y_pos+1, 10, 10, gou_mu, 0 );
	}
}




void draw_dialog( int mod )            //打印一个用于设置参数的对话框，在屏幕的左部
{
	clr_rect( 35, 0, 93, 64 );    //描绘一个椭圆框的处理过程
	draw_line( 38, 0, 124, 0 );
	draw_point( 37, 1 );
	draw_point( 36, 2 );

	if( mod )
	{
		draw_line( 35, 3, 35, 63 );
		draw_line( 35, 63, 124, 63 );
	}
	else
	{
		 draw_line( 35, 3, 35, 60 );
		 draw_point( 36, 61 );
		 draw_point( 37, 62 );
		 draw_line( 38, 63, 124, 63 );
	}

	draw_point( 125, 62 );
	draw_point( 126, 61 );

	draw_line( 127, 3, 127, 60 );
	draw_point( 125, 1 );
	draw_point( 126, 2 );

	draw_line( 40, 15, 122, 15 );       //打印一条靠标题栏的直线
}


void groupMoveFont(void)
{
    static unsigned int cyls;
    static char *move[10] = { "第", "组","组正","组正在","组正在采","组正在采样",
                            "正在采样","在采样","采样","样" };
    static char *move_wait[10] = { "第", "组","组正","组正在","组正在等","组正在等待",
                            "正在等待","在等待","等待","待" };
    
    switch ( systems.status )
    {
    case SAMPLING:
        if ( ENGLISH == systems.language )
        {
            print_str( 38, 50, "Groups", 0 );
            print_int( 76, 50, systems.cur_group + 1, 0 );
        }
        else
        {
            clr_rect( 35, 50, 61, 12 );
            switch ( cyls )
            {
            case 0:
                print_ch_str( 83, 50, move[0], 0 );
                break;
            case 1:
                print_ch_str( 71, 50, move[0], 0 );
                if ( systems.cur_group < 9 )
                {
                    print_int( 86, 50, systems.cur_group + 1, 0 );
                }
                else
                {
                    print_int( 83, 50, systems.cur_group + 1, 0 );
                }
                break;
            case 2:
                print_ch_str( 59, 50, move[0], 0 );
                if ( systems.cur_group < 9 )
                {
                    print_int( 74, 50, systems.cur_group + 1, 0 );
                }
                else
                {
                    print_int( 71, 50, systems.cur_group + 1, 0 );
                }
                print_ch_str( 83, 50, move[1], 0 );
                break;
            case 3:
                print_ch_str( 47, 50, move[0], 0 );
                if ( systems.cur_group < 9 )
                {
                    print_int( 62, 50, systems.cur_group + 1, 0 );
                }
                else
                {
                    print_int( 59, 50, systems.cur_group + 1, 0 );
                }
                print_ch_str( 71, 50, move[2], 0 );
                break;
            case 4:
                print_ch_str( 35, 50, move[0], 0 );
                if ( systems.cur_group < 9 )
                {
                    print_int( 50, 50, systems.cur_group + 1, 0 );
                }
                else
                {
                    print_int( 47, 50, systems.cur_group + 1, 0 );
                }
                print_ch_str( 59, 50, move[3], 0 );
                break;
            case 5:
                if ( systems.cur_group < 9 )
                {
                    print_int( 38, 50, systems.cur_group + 1, 0 );
                }
                else
                {
                    print_int( 35, 50, systems.cur_group + 1, 0 );
                }
                print_ch_str( 47, 50, move[4], 0 );
                break;
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
                print_ch_str( 35, 50, move[cyls-1], 0 );
                break;
            default: break;
            }
        }
        break;
    case WAITING:
        if ( ENGLISH == systems.language )
        {
            print_str( 38, 50, "Groups", 0 );
            print_int( 76, 50, systems.cur_group + 1, 0 );
        }
        else
        {
            clr_rect( 35, 50, 61, 12 );
            switch ( cyls )
            {
            case 0:
                print_ch_str( 83, 50, move_wait[0], 0 );
                break;
            case 1:
                print_ch_str( 71, 50, move_wait[0], 0 );
                if ( systems.cur_group < 9 )
                {
                    print_int( 86, 50, systems.cur_group + 1, 0 );
                }
                else
                {
                    print_int( 83, 50, systems.cur_group + 1, 0 );
                }
                break;
            case 2:
                print_ch_str( 59, 50, move_wait[0], 0 );
                if ( systems.cur_group < 9 )
                {
                    print_int( 74, 50, systems.cur_group + 1, 0 );
                }
                else
                {
                    print_int( 71, 50, systems.cur_group + 1, 0 );
                }
                print_ch_str( 83, 50, move_wait[1], 0 );
                break;
            case 3:
                print_ch_str( 47, 50, move_wait[0], 0 );
                if ( systems.cur_group < 9 )
                {
                    print_int( 62, 50, systems.cur_group + 1, 0 );
                }
                else
                {
                    print_int( 59, 50, systems.cur_group + 1, 0 );
                }
                print_ch_str( 71, 50, move_wait[2], 0 );
                break;
            case 4:
                print_ch_str( 35, 50, move_wait[0], 0 );
                if ( systems.cur_group < 9 )
                {
                    print_int( 50, 50, systems.cur_group + 1, 0 );
                }
                else
                {
                    print_int( 47, 50, systems.cur_group + 1, 0 );
                }
                print_ch_str( 59, 50, move_wait[3], 0 );
                break;
            case 5:
                if ( systems.cur_group < 9 )
                {
                    print_int( 38, 50, systems.cur_group + 1, 0 );
                }
                else
                {
                    print_int( 35, 50, systems.cur_group + 1, 0 );
                }
                print_ch_str( 47, 50, move_wait[4], 0 );
                break;
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
                print_ch_str( 35, 50, move_wait[cyls-1], 0 );
                break;
            default: break;
            }
        }
        break;
    }

    if ( 10 == cyls )
    {
        cyls = 0;
    }
    else
    {
        cyls++;
    }
}

void cylsMoveFont(void)
{
    static unsigned int cyls;
    static char *move[12] = { "第", "次", "次循", "次循环", "次循环正", "次循环正在", "循环正在采",
                            "环正在采样", "正在采样", "在采样", "采样", "样" };
    static char *move_wait[12] = { "第", "次","次循", "次循环", "次循环正", "次循环正在", "循环正在等",
                            "环正在等待", "正在等待", "在等待", "等待", "待" };
    
    switch ( systems.status )
    {
    case SAMPLING:
        if ( ENGLISH == systems.language )
        {
            print_str( 38, 50, "Cycles", 0 );
            print_int( 76, 50, systems.cur_cyls + 1, 0 );
        }
        else
        {
            clr_rect( 35, 50, 61, 12 );
            switch ( cyls )
            {
            case 0:
                print_ch_str( 83, 50, move[0], 0 );
                break;
            case 1:
                print_ch_str( 71, 50, move[0], 0 );
                if ( systems.cur_cyls < 9 )
                {
                    print_int( 86, 50, systems.cur_cyls + 1, 0 );
                }
                else
                {
                    print_int( 83, 50, systems.cur_cyls + 1, 0 );
                }
                break;
            case 2:
                print_ch_str( 59, 50, move[0], 0 );
                if ( systems.cur_cyls < 9 )
                {
                    print_int( 74, 50, systems.cur_cyls + 1, 0 );
                }
                else
                {
                    print_int( 71, 50, systems.cur_cyls + 1, 0 );
                }
                print_ch_str( 83, 50, move[1], 0 );
                break;
            case 3:
                print_ch_str( 47, 50, move[0], 0 );
                if ( systems.cur_cyls < 9 )
                {
                    print_int( 62, 50, systems.cur_cyls + 1, 0 );
                }
                else
                {
                    print_int( 59, 50, systems.cur_cyls + 1, 0 );
                }
                print_ch_str( 71, 50, move[2], 0 );
                break;
            case 4:
                print_ch_str( 35, 50, move[0], 0 );
                if ( systems.cur_cyls < 9 )
                {
                    print_int( 50, 50, systems.cur_cyls + 1, 0 );
                }
                else
                {
                    print_int( 47, 50, systems.cur_cyls + 1, 0 );
                }
                print_ch_str( 59, 50, move[3], 0 );
                break;
            case 5:
                if ( systems.cur_cyls < 9 )
                {
                    print_int( 38, 50, systems.cur_cyls + 1, 0 );
                }
                else
                {
                    print_int( 35, 50, systems.cur_cyls + 1, 0 );
                }
                print_ch_str( 47, 50, move[4], 0 );
                break;
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
                print_ch_str( 35, 50, move[cyls-1], 0 );
                break;
            default: break;
            }
        }
        break;
    case WAITING:
        if ( ENGLISH == systems.language )
        {
            print_str( 38, 50, "Cycles", 0 );
            print_int( 76, 50, systems.cur_cyls + 1, 0 );
        }
        else
        {
            clr_rect( 35, 50, 61, 12 );
            switch ( cyls )
            {
            case 0:
                print_ch_str( 83, 50, move_wait[0], 0 );
                break;
            case 1:
                print_ch_str( 71, 50, move_wait[0], 0 );
                if ( systems.cur_cyls < 9 )
                {
                    print_int( 86, 50, systems.cur_cyls + 1, 0 );
                }
                else
                {
                    print_int( 83, 50, systems.cur_cyls + 1, 0 );
                }
                break;
            case 2:
                print_ch_str( 59, 50, move_wait[0], 0 );
                if ( systems.cur_cyls < 9 )
                {
                    print_int( 74, 50, systems.cur_cyls + 1, 0 );
                }
                else
                {
                    print_int( 71, 50, systems.cur_cyls + 1, 0 );
                }
                print_ch_str( 83, 50, move_wait[1], 0 );
                break;
            case 3:
                print_ch_str( 47, 50, move_wait[0], 0 );
                if ( systems.cur_cyls < 9 )
                {
                    print_int( 62, 50, systems.cur_cyls + 1, 0 );
                }
                else
                {
                    print_int( 59, 50, systems.cur_cyls + 1, 0 );
                }
                print_ch_str( 71, 50, move_wait[2], 0 );
                break;
            case 4:
                print_ch_str( 35, 50, move_wait[0], 0 );
                if ( systems.cur_cyls < 9 )
                {
                    print_int( 50, 50, systems.cur_cyls + 1, 0 );
                }
                else
                {
                    print_int( 47, 50, systems.cur_cyls + 1, 0 );
                }
                print_ch_str( 59, 50, move_wait[3], 0 );
                break;
            case 5:
                if ( systems.cur_cyls < 9 )
                {
                    print_int( 38, 50, systems.cur_cyls + 1, 0 );
                }
                else
                {
                    print_int( 35, 50, systems.cur_cyls + 1, 0 );
                }
                print_ch_str( 47, 50, move_wait[4], 0 );
                break;
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
                print_ch_str( 35, 50, move_wait[cyls-1], 0 );
                break;
            default: break;
            }
        }
        break;
    }

    if ( 12 == cyls )
    {
        cyls = 0;
    }
    else
    {
        cyls++;
    }
}




