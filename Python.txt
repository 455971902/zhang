对于单个字节的编码

ord（‘ A ’）：  表示为65的整数

chr ( '65 '):   表示字符转化为'A'

python 对bytes类型的数据用带b的前缀的单引号或者是双引号表示：

x = b'ABC'
python 对bytes类型的数据用带b的前缀的单引号或者是双引号表示：

x = b'ABC'

在bytes中无法显示为ASCII字符的字节，用\x##显示

在将bytes数据变为str 就需要用decode

>>> b'ABC'.decode('ascii')
'ABC'

如果bytes中包含无法解码的字节，decode()方法会报错：

>>> b'\xe4\xb8\xad\xff'.decode('utf-8')

Traceback (most recent call last):
  ...

如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节：

>>> b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore')
'中'

我们经常会输出类似'亲爱的xxx你好！你xx月的话费是xx，余额是xx'之类的字符串
而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。

>>> 'hello, %s' %' world'
hello world

>>>'hi, %s, you have $ %d' % ('yu juan , 100000)

format()

另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次
替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：

>>> 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)
'Hello, 小明, 成绩提升了 17.1%'

Python 内置数据类型：list 
>>> classmates = ['zhangxu', 'Bob', 'yujuan']
>>>len(classmates)
3

用索引可以直接访问list中的每一个元素 索引是从0开始的：
>>> classmates[0]
zhangxu

>>> classmates[-1]  （从最后一个开始，一次类推可以获取倒数 2、3、4）
yujuan

list 是一个可变的有序表，可以向list中追加元素到末尾
>>> classmates.append ('Adam')
>>>classmates
['zhangxu', 'jack', 'yujuan', 'Adam']

要删除指定位置的元素用POP(i)的方法，其中i是索引的位置
>>> classmates.pop(1)
'jack'
>>>classmates
['zhangxu','yujuan']

要把某个元素替换成别的元素可以直接复制给对应的索引位置：
classmates【3】
----------------------------------------------------------------------------------------
list元素也可以是另一个list 
另一种有序序列列表叫元组， tuple ：：tuple和list非常相似，但是tuple一旦初始化后不能修改

空类型		只有一个类型

（）      （1，）



if age>=18:    (注释：：不能丢了" : ")
pfint('you age is ',age)
print('adult')

也可以给if 添加一个elif 语句，如果是true的话执行语句，不是的话执行elif

elif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是：

if <条件判断1>:
    <执行1>
elif <条件判断2>:
    <执行2>
elif <条件判断3>:
    <执行3>
else:
    <执行4>

----------------------------------------------------------------------------------------

python 的循环方式

1、有两种一种是 for...in循环  ， 一次吧list或者tuple中的每个元素迭代出来

name = ['zhangxu', 'Bob', 'yujuan']




----------------------------------------------------------------------------------------
2019/3/4

>>>	list (range(5))
	[0,1,2,3,4]
	
	
	循环：
			for x in [1,2,3,4,5] 	讲数组一次复制给x进行循环
			
	第二种循环是while循环，只要满足条件就不断循环，条件不满足是退出循环
	
	eg：
		sum = 0
		n = 99
		while n>0:
		sum  = sum +n 
		n = n - 2
		print(sum)
		
		再循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出
		
	在循环中，{
				break语句可以提前退出循环	
		
			    continue语句，跳过当前的这次U型你还，直接开始下一次循环
			  }  通常都是配套 if 语句进行使用
			  
			  attention： 尽量少使用break 和 continue语句 造成代码逻辑分叉较多，易出错
			  
			  

------------------------------------ dict-----------------------------------------------

	python 内置dictionary 其他语言中成为map 使用（KEY  -- VALUE)进行储存
	
>>> d = {'zhangxu' : 95, 'yujuan' : 98, .......}
>>> d['zhangxu']
95

由于一个key只能对应一个value 所以当多次对一个key放入一个value，后面的值会把前面给pass

要删除一个key，用pop（key）方法，对应的value也会从dictionary中删除：

>>> d.pop('zhangxu')
95
>>> d
{'yujuan' : 98}
			在使用中保证KEY不能变。
			
------------------------------------set-------------------------------------------------
	set和dict类似，但是不存储value，由于key不能重复，所以在set中没有重复的key
	
要创建一个set，需要提供一个list作为集合输入

>>> s = set([1,2,3])
>>> s 
{1,2,3}

通过add（key)方法可以添加元素到set中，可以重复添加，但不会有效果:

>>> s.add(4)
>>> s 
{1,2,3,4}

通过remove（key）可以删除元素：

-----------------------------------函数-------------------------------------------------

		在python中　，定义一个函数要用def语句，依次写出函数名、括号、括号中的参数和’：'
		然后在缩进块中编写函数体。函数返回 用return返回。
		　
def  my_abs(x)
	if x >= 0:
	return x
	else:
		return -x 


空函数 ： pass 语句 ：
	def nop （）：
	pass
缺少了pass 代码就会运行错误


&& 如何设置默认参数
	当函数有多个参数时，把变化大的参数放在前面，变化小的参数放在后面。变化小的参数就
可以作为默认参数。

                 目的：       （主要降低调用函数的难度）

	eg：
		def enroll(name,gender):
		print ('name' , name)
		print ('gender' , gender)
		
		调用enroll（）函数只需要传入两个参数：
>>> enroll('sarah', 'f')
name: sarah
gender: f

默认参数就直接赋值
def enroll( name , gender , age=6 ,  city = 'beijing')
		print ('name' , name)
		print ('gender' , gender)
		print ('age' , age)
		print ('city' , city)
		
查找时不需要提供年龄和城市，只提供必须的两个参数：
>>> enroll('sarah', 'f')
name: sarah
gender: f 
age: 6
city: beijing         只有与默认参数不符的学生提供额外的信息：


默认参数的坑：
{
先定义一个函数，传入一个list ，添加一个END再返回：

def add_end(L=[])
	L.append('END')
	return L
	
当正常调用时

>>> add_end([1,2,3])
[1,2,3,'END']
>>> add_end(['x','y','z'])
['x','y','z','END']

当使用默认参数调用时
>>> add_end()
['END', 'END']
>>> add_end()
['END', 'END', 'END']           attention：定义默认参数时：默认参数必须指向不变对象！！

修改上面的坑： 
>>> def add_end(L=None)
		if L is None:
		L=[]

----------------------------------------------------------------------------------------
2019/3/5
----------------------------------------------------------------------------------------
		
可变参数  ’*‘
关键字参数

他可以扩展函数的功能，关键字参数允许你传入0个或者n个含参数名的参数，这些参数在内部自动
	组装成一个dict
	
	def person(name, age, **kw):
		print('name:', name, 'age:',age, 'other:',kw)
		
		函数person除了必选的参数name和age ，在调用函数时可以只传入必选参数：
>>>person（'zhangxu', 30)
name: zhangxu age: 30 other: {}

>>> extra = {'city': 'beijing', 'job'：’Engineer'}
>>> person('Jack', 24, **extra)
name:jack age:24 other:{'city': 'beijing','job':'engineer'}


----------------------------------------------------------------------------------------
命名关键字参数：
	对于关键字参数，函数的调用者传入不受限制的参数。之余传入了哪些，就需要函数内部通过kw
	
	def person(name,age,**kw):
		if 'city' in kw:            #有city参数
		pass
		if 'job' in kw:
		pass							#有job参数
	print（’name:' name, 'age:',age, 'other:', kw)
	
	如果要限制关键字参数的名字，只接受city和job作为关键字参数
	def person(name,age, *,city,job):
		print(name, age,city,job)

和关键字参数**kw不同，命名关键词参数需要一个特殊的分隔符*，*后面的参数被视为命名关键字参数


小结：

Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。

默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！

要注意定义可变参数和关键字参数的语法：

*args是可变参数，args接收的是一个tuple；

**kw是关键字参数，kw接收的是一个dict。

以及调用函数时如何传入可变参数和关键字参数的语法：

可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；

关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。

使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。

命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。

定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。

----------------------------------------------------------------------------------------
2019/3/6

递归函数
	
	在函数内部，可以调用其他函数，如果一个函数在内部调用自身，这个函数就是递归函数
	
eg： 计算n！
	def fact（n）：
		if n == 1:
			return 1
		return n * fact（n-1）：
>>> fact(3)
6

递归函数优点：简单 逻辑清晰。
	在计算机中， 函数调用是通过栈（stack）这种数据结构实现的。每当挤入一个函数调用，
栈 就会加一层栈侦，没当函数返回时，栈就会减一层栈侦。由于栈不是无限的，所以递归调用
的次数过多，会导致栈的溢出。

优化：
def fact（n）：
	return fact_iter(n, 1)

def fact_iter(num, product):
	if num == 1：
		return product
	return fact_iter(num-1. num*product)


L = []
n = 1
while n <=99:
L.append(n)
n = n+2
 
 
提取前三个数
>>> L[0:3}          python提供了切片（slice）操作符，简化这种操作
[0,1,2]           如果第一个数是0还可以神略   >>>L[:3]

>>> L[-3:0]
[1,2,3]

             可以通过切片轻松取出某一段数列。比如前10个数：

>>> L[:10]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
后10个数：

>>> L[-10:]
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
前11-20个数：

>>> L[10:20]
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
前10个数，每两个取一个：

>>> L[:10:2]
[0, 2, 4, 6, 8]
所有数，每5个取一个：

>>> L[::5]
[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]
甚至什么都不写，只写[:]就可以原样复制一个list：

>>> L[:]
[0, 1, 2, 3, ..., 99]
tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍
是tuple：

>>> (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)
字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：

>>> 'ABCDEFG'[:3]
'ABC'
>>> 'ABCDEFG'[::2]
'ACE


----------------------------------------------------------------------------------------
2019/3/7


列表生成式

list comprehension ，是Python内置的创建list的生成式。

eg：生成list[1,2,3....8,9,10] 
可以用
list(range(1,11)):

>>> L = []
>>> for x in range(1,11):
		L.append(x*x)
>>> L
[1,4,9,16,...81,100]

但是比较繁琐 利用列表生成式可以用一句来生成上面的list：

>>> [x*x for x in range (1,11)]
[1,4,9,16,...81,100]

写列表生成式时，要把生成的元素'x*x'放在前面，后面跟上for循环，就可以把list创建出来

在for循环后面可以加上if判断，可以筛选出仅偶数的平方
>>> [x*x for x in range(1,11) if x%2 == 0]


-------------------------------------生成器---------------------------------------------

在Python中 可以不必创建完整的list，从而节省大量的空间。可以一边循环，一边计算的机制，call
生成器： generator ：

>>> L = [X*X for x in range(10)]
>>> L
[0,1,4,9,16,25,36,49,64,81]
>>> g=(x*x for x in range(10))
>>> g
<generator object <genexper> at 0x1022ef630>


创建L和g的区别在于最外层的[]和(),L是一个list ，g是一个生成器
>>> next(g)
0
>>> next(g)
1
...

使用for循环
>>> g = (x*x for x in rang (10))
>>> for n in g:
		print(n)
0
1
4
...
所以我们创建了一个generator,基本上不会调用next（），而是通过for循环进行迭代它

eg： 著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都由前面二数相加
1,1,2,3,5,8,13,21,34,55....

def fib(max):
	n,a,b = 0,0,1
	while n<max:
	print(b)
	a,b=b,a+b 
	n=n+1
	return 'done'
	
>>> fib(?)
...
'done'

上面的函数和generator差一点点，要把fib变成生成器，只需要把print（b）改为 yield b

def fib(max):
	n,a,b = 0,0,1
	while n<max:
	yield b
	a,b=b, a+b 
	n=n+1
	return 'done'

	这是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再
是一个普通的函数，而是一个生成器
>>> fib(6)
>>> f
<generator object fib at 0x104feaaa0>


::这里生成器和函数的执行流程不一样，函数是循序执行。遇到return语句或者是最后一行函数语句
就返回。而变成generator的函数，在每次调用next（）的时候执行，遇到yield语句返回，再次执行
时从上次返回的yield语句处继续执行。

	
小结：：

generator是非常强大的工具，在Python中，可以简单地把列表生成式改成generator，也可以通过
函数实现复杂逻辑的generator。

要理解generator的工作原理，它是在for循环的过程中不断计算出下一个元素，并在适当的条件
结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，
就是结束generator的指令，for循环随之结束。

请注意区分普通函数和generator函数，普通函数调用直接返回结果：

>>> r = abs(6)
>>> r
6
generator函数的“调用”实际返回一个generator对象：

>>> g = fib(6)
>>> g
<generator object fib at 0x1022ef948>


------------------------------------迭代器----------------------------------------------
	可以直接作用于for循环的数据类型有以下几种
1、是集合数据类型，如：：list、tuple、dict、set、str等
2、是generator，包括生成器和自带yield的generator function
	这些可以直接作用于for循环的对象都可以称为可迭代对象：Iterable。
	
可以使用isinstance()判断一个对象是否是Iterable对象：

>>>from collection import Iterable
>>>isinstance ([], Iterable)
True
>>>isinstance({},Iterable)
True
>>>isinstance('abc',Iterable)
True
>>> isinstance((x for x in range(10)), Iterable)
True
>>> isinstance(100, Iterable)
False


小结------------------------------------------------------------------------------------

凡是可作用于for循环的对象都是Iterable类型；

凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；

集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个
Iterator对象。

Python的for循环本质上就是通过不断调用next()函数实现的，例如：

for x in [1, 2, 3, 4, 5]:
    pass
实际上完全等价于：

# 首先获得Iterator对象:
it = iter([1, 2, 3, 4, 5])
# 循环:
while True:
    try:
        # 获得下一个值:
        x = next(it)
    except StopIteration:
        # 遇到StopIteration就退出循环
        break

	函数是Python內建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用
就可以把复杂的任务分散成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向
过程的程序设计的基本单元。

	而函数式编程---function programming 虽然也可以归结到面向过程的程序设计，但其思想更接
近数学计算。



----------------------------------------------------------------------------------------






















